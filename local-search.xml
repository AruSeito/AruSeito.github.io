<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hybrid原理解析</title>
    <link href="/article/e4052a99/"/>
    <url>/article/e4052a99/</url>
    
    <content type="html"><![CDATA[<h2 id="hybrid-是什么？"><a href="#hybrid-是什么？" class="headerlink" title="hybrid 是什么？"></a>hybrid 是什么？</h2><p>hybrid 其实可以简单粗暴的理解为 一个原生应用内调用 webview，然后 h5 嵌套在 webview 中，并且 h5 可以与 native 应用进行交互。一个非常好的例子就是微信小程序/微信 H5 这种，在使用的时候通过调用 jsbridge 的方法，来调用微信原生的一些操作，比如分享到 xxx 这种。</p><p>所以 hybrid 开发重点应该是中间这个 jsbridge。</p><h2 id="jsbridge-通信的方式"><a href="#jsbridge-通信的方式" class="headerlink" title="jsbridge 通信的方式"></a>jsbridge 通信的方式</h2><ol><li><p>URL Schema：客户端通过拦击 webview 请求来完成。</p></li><li><p>native 向 webview 中的 js 执行环境,注⼊ API, 以此来完成通讯。</p></li></ol><h3 id="URL-Schema"><a href="#URL-Schema" class="headerlink" title="URL Schema"></a>URL Schema</h3><ol><li>原理</li></ol><p>在 webview 中发送的请求都会被客户端监听到捕获到。</p><ol start="2"><li><p>定义自己的私有协议</p></li><li><p>请求的发送</p></li></ol><p>webview 中请求的发送，一般用 iframe 方式。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> doc = <span class="hljs-built_in">window</span>.document;<br><span class="hljs-keyword">const</span> body = doc.body;<br><span class="hljs-keyword">const</span> iframe = doc.createElement(<span class="hljs-string">&quot;iframe&quot;</span>);<br><br>iframe.style.display = <span class="hljs-string">&quot;none&quot;</span>;<br>iframe.src = <span class="hljs-string">&quot;jsbridge://openCamera&quot;</span>;<br><br>body.append(iframe);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 采用回掉的方式更合理，发送请求成功后，客户端返回给我们，然后我们收到消息去移除。</span><br>  body.removeChild(iframe);<br>&#125;, <span class="hljs-number">200</span>);<br></code></pre></div></td></tr></table></figure><p>这种会有个安全性问题。所以客户端一般情况下会设置个域名白名单，只有发出的请求是从白名单内发的才可以。</p><ol start="4"><li>客户端拦截协议请求。</li></ol><p>具体操作不太清楚，客户端需要处理的事情了。</p><p>拦截到请求之后对<code>iframe.scr</code>进行一个分解，提取方法名，参数等。</p><ol start="5"><li>请求处理完成后的回调</li></ol><ul><li>H5 调用特定方法的时候，需要通过 webviewApi 的名称+参数作为唯一标识，注册事件</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handlerId = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">const</span> eventName = <span class="hljs-string">`setLeftButton_<span class="hljs-subst">$&#123;handlerId&#125;</span>`</span>;<br><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> Event(eventName);<br><br><span class="hljs-built_in">window</span>.addEventListener(eventName, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 做一些业务逻辑</span><br>&#125;);<br><br><span class="hljs-comment">// 然后用上面封装好的iframe那个方法给他发送出去。</span><br></code></pre></div></td></tr></table></figure><ul><li>客户端在接收到请求的时候，完成自己的处理后，dispatchEvent，携带回调的数据处罚自定义事件</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">event.data = &#123; <span class="hljs-attr">error</span>: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-built_in">window</span>.dispatchEvent(event);<br></code></pre></div></td></tr></table></figure><p>真正与客户端交互的逻辑靠我自己不太好搞，还得搞一些原生方法，所以我们可以用 websocket 来模拟一下。</p><p>在 node 层起个 staticServer+websocket，然后在 html 里触发相应的 native 方法的时候就发送个 ws 消息，然后 node 层就相当于 native 层，再处理收到消息后的逻辑，然后再把消息发送回去。<a href="https://github.com/AruSeito/daily-practice/blob/main/others/jsBridge/index.js">模拟源码</a></p><h3 id="注入-API"><a href="#注入-API" class="headerlink" title="注入 API"></a>注入 API</h3><p>URL Schema 缺点：如果使用 iframe 这样发出请求，url 过长的话会造成 url 被截断。</p><p>注入 API 缺点：</p><p>注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p><p>如果方法特别多的话，window 上挂超多方法，内存泄露问题很严重。</p><ol><li>向 native 传递信息</li></ol><p>native 会在 window 上挂载一个对象，然后直接 window.方法调用就可以传递消息了。</p><p>一般情况下会对参数进行编码，比如转换为 base64</p><ol start="2"><li>准备接收 native 的回调</li></ol><p>在 window 上去声明接收回调的 api</p><ol start="3"><li>native 调用回调函数</li></ol>]]></content>
    
    
    <categories>
      
      <category>原理解析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hybrid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再探webpack-dev-server</title>
    <link href="/article/d836125a/"/>
    <url>/article/d836125a/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于热更新的文章:<a href="https://aruseito.github.io/article/57ff1b88/">开着飞机修引擎-热更新</a>，但是只描述了 ws 是如何通知的，只是简单带过了客户端这面的更新流程，这次我们打开<a href="https://github.com/webpack/webpack-dev-server">源码</a>，从头到尾一探究竟。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>我们在上一篇文章中已经知道热更新的推送是依赖于 ws 的，所以我们先从熟悉的地方入手，找到创建 ws 的方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// lib/Server.js</span><br><span class="hljs-function"><span class="hljs-title">createWebSocketServer</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.webSocketServer = <span class="hljs-keyword">new</span> (<span class="hljs-built_in">this</span>.getServerTransport())(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.webSocketServer.implementation.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">client, request</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// ...一些配置的准备与检查</span><br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options.hot === <span class="hljs-literal">true</span> || <span class="hljs-built_in">this</span>.options.hot === <span class="hljs-string">&quot;only&quot;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.sendMessage([client], <span class="hljs-string">&quot;hot&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options.liveReload) &#123;<br>        <span class="hljs-built_in">this</span>.sendMessage([client], <span class="hljs-string">&quot;liveReload&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options.client &amp;&amp; <span class="hljs-built_in">this</span>.options.client.progress) &#123;<br>        <span class="hljs-built_in">this</span>.sendMessage([client], <span class="hljs-string">&quot;progress&quot;</span>, <span class="hljs-built_in">this</span>.options.client.progress);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options.client &amp;&amp; <span class="hljs-built_in">this</span>.options.client.reconnect) &#123;<br>        <span class="hljs-built_in">this</span>.sendMessage([client], <span class="hljs-string">&quot;reconnect&quot;</span>, <span class="hljs-built_in">this</span>.options.client.reconnect);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.options.client &amp;&amp; <span class="hljs-built_in">this</span>.options.client.overlay) &#123;<br>        <span class="hljs-built_in">this</span>.sendMessage([client], <span class="hljs-string">&quot;overlay&quot;</span>, <span class="hljs-built_in">this</span>.options.client.overlay);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stats) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-built_in">this</span>.sendStats([client], <span class="hljs-built_in">this</span>.getStats(<span class="hljs-built_in">this</span>.stats), <span class="hljs-literal">true</span>);<br>    &#125;);<br>  &#125;<br></code></pre></div></td></tr></table></figure><p>咱们在启用的时候仔细看 ws 的响应就是上面这串代码。在看一下它的<code>sendMessage</code>的实现。<br>一顿操作结束后调了个<code>sendStats</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">sendStats</span>(<span class="hljs-params">clients, stats, force</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> shouldEmit =<br>    !force &amp;&amp;<br>    stats &amp;&amp;<br>    (!stats.errors || stats.errors.length === <span class="hljs-number">0</span>) &amp;&amp;<br>    (!stats.warnings || stats.warnings.length === <span class="hljs-number">0</span>) &amp;&amp;<br>    <span class="hljs-built_in">this</span>.currentHash === stats.hash;<br><br>  <span class="hljs-keyword">if</span> (shouldEmit) &#123;<br>    <span class="hljs-built_in">this</span>.sendMessage(clients, <span class="hljs-string">&quot;still-ok&quot;</span>);<br><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.currentHash = stats.hash;<br>  <span class="hljs-built_in">this</span>.sendMessage(clients, <span class="hljs-string">&quot;hash&quot;</span>, stats.hash);<br><br>  <span class="hljs-keyword">if</span> (stats.errors.length &gt; <span class="hljs-number">0</span> || stats.warnings.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (stats.warnings.length &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">this</span>.sendMessage(clients, <span class="hljs-string">&quot;warnings&quot;</span>, stats.warnings);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (stats.errors.length &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">this</span>.sendMessage(clients, <span class="hljs-string">&quot;errors&quot;</span>, stats.errors);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">this</span>.sendMessage(clients, <span class="hljs-string">&quot;ok&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个方法主要是拿到了编译好的文件的 hash,并记录下来，然后广播出去。如果有错误或者警告就将错误/警告发送出去，不然发送 ok，</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">sendMessage</span>(<span class="hljs-params">clients, type, data</span>)</span> &#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> clients) &#123;<br>     <span class="hljs-comment">// `sockjs` uses `1` to indicate client is ready to accept data</span><br>     <span class="hljs-comment">// `ws` uses `WebSocket.OPEN`, but it is mean `1` too</span><br>     <span class="hljs-keyword">if</span> (client.readyState === <span class="hljs-number">1</span>) &#123;<br>       client.send(<span class="hljs-built_in">JSON</span>.stringify(&#123; type, data &#125;));<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure><p>这里他为什么要遍历呢？不知道大家有没有仔细看过，如果我有两个 tab 页都打开了这个页面，更改一个的话，两个都会触发热更新，其实是跟这里有关，他把链接好的客户端都存在了一个数组里，然后开始遍历，只有状态为 Open 的时候才会发送日志。</p><p>我们更新内容之后 ws 还会发送一个”invalid”的内容，我们根据这个找到</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">setupHooks</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.compiler.hooks.invalid.tap(<span class="hljs-string">&quot;webpack-dev-server&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webSocketServer) &#123;<br>      <span class="hljs-built_in">this</span>.sendMessage(<span class="hljs-built_in">this</span>.webSocketServer.clients, <span class="hljs-string">&quot;invalid&quot;</span>);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-built_in">this</span>.compiler.hooks.done.tap(<span class="hljs-string">&quot;webpack-dev-server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">stats</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webSocketServer) &#123;<br>      <span class="hljs-built_in">this</span>.sendStats(<span class="hljs-built_in">this</span>.webSocketServer.clients, <span class="hljs-built_in">this</span>.getStats(stats));<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.stats = stats;<br>  &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的<code>this.webSocketServer</code>就是在上面 createWebSocketServer 中 new 出来的。<br><code>this.compiler.hooks.invalid</code>是指 webpack 的 compiler 的勾子：在一个观察中的 compilation 无效时执行。<br><code>this.compiler.hooks.done</code>也是指 webpack 的 compiler 的钩子：在 compilation 完成时执行。<br><code>tap</code>是指绑定某方法到事件钩子上，还有<code>tapAsync</code>,<code>tapPromise</code>异步的钩子。</p><p>在编译完成时又调用了<code>this.sendStats</code>，以上就是服务端处理的一个流程。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>服务端发送了，客户端肯定得会接收，所以我们去客户端下面找一下关于 ws 的方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-src/socket.js</span><br><span class="hljs-keyword">const</span> socket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initSocket</span>(<span class="hljs-params">url, handlers, reconnect</span>) </span>&#123;<br>  client = <span class="hljs-keyword">new</span> Client(url);<br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 打开/关闭的方法。</span><br><br>  client.onMessage(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-built_in">JSON</span>.parse(data);<br><br>    <span class="hljs-keyword">if</span> (handlers[message.type]) &#123;<br>      handlers[message.type](message.data);<br>    &#125;<br>  &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>可以看到他接收到消息的时候调了个<code>handlers</code>,然后再看看哪里调用了<code>socket</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-src/index.js</span><br><span class="hljs-keyword">import</span> socket <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./socket.js&quot;</span>;<br><span class="hljs-comment">// ...</span><br>socket(socketURL, onSocketMessage, options.reconnect);<br></code></pre></div></td></tr></table></figure><p>ok,再根据第二个参数找到 handlers</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> onSocketMessage = &#123;<br>  <span class="hljs-function"><span class="hljs-title">hot</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parsedResourceQuery.hot === <span class="hljs-string">&quot;false&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    options.hot = <span class="hljs-literal">true</span>;<br><br>    log.info(<span class="hljs-string">&quot;Hot Module Replacement enabled.&quot;</span>);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">liveReload</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parsedResourceQuery[<span class="hljs-string">&quot;live-reload&quot;</span>] === <span class="hljs-string">&quot;false&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    options.liveReload = <span class="hljs-literal">true</span>;<br><br>    log.info(<span class="hljs-string">&quot;Live Reloading enabled.&quot;</span>);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">invalid</span>(<span class="hljs-params"></span>)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;App updated. Recompiling...&quot;</span>);<br><br>    <span class="hljs-comment">// Fixes #1042. overlay doesn&#x27;t clear if errors are fixed but warnings remain.</span><br>    <span class="hljs-keyword">if</span> (options.overlay) &#123;<br>      hide();<br>    &#125;<br><br>    sendMessage(<span class="hljs-string">&quot;Invalid&quot;</span>);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">hash</span>(<span class="hljs-params">hash</span>)</span> &#123;<br>    status.previousHash = status.currentHash;<br>    status.currentHash = hash;<br>  &#125;,<br>  <span class="hljs-comment">// ...省略一堆方法</span><br>  <span class="hljs-function"><span class="hljs-title">ok</span>(<span class="hljs-params"></span>)</span> &#123;<br>    sendMessage(<span class="hljs-string">&quot;Ok&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (options.overlay) &#123;<br>      hide();<br>    &#125;<br><br>    reloadApp(options, status);<br>  &#125;,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>hot</code>和<code>liveReload</code>都是改变了某个选项的值，不管他。<br>接着看 invalid,再接收到服务端的<code>invalid</code>后会再向服务端发一个<code>Invalid</code><br>hash ，将上一个 hash 和当前 hash 存起来。<br>ok，执行 reloadApp 的方法。status 如下。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> status = &#123;<br>  <span class="hljs-attr">isUnloading</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement</span><br>  <span class="hljs-comment">// eslint-disable-next-line camelcase</span><br>  <span class="hljs-attr">currentHash</span>: <span class="hljs-keyword">typeof</span> __webpack_hash__ !== <span class="hljs-string">&quot;undefined&quot;</span> ? __webpack_hash__ : <span class="hljs-string">&quot;&quot;</span>,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>然后我们再来看<code>reloadApp</code>方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reloadApp</span>(<span class="hljs-params">&#123; hot, liveReload &#125;, status</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (status.isUnloading) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> &#123; currentHash, previousHash &#125; = status;<br>  <span class="hljs-keyword">const</span> isInitial = currentHash.indexOf(previousHash) &gt;= <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (isInitial) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...省略</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>先根据 status 判断是不是没有 loading 上，然后再判断当前 hash 与上一个 hash 是否相等，如果相等则不需要更新。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reloadApp</span>(<span class="hljs-params">&#123; hot, liveReload &#125;, status</span>) </span>&#123;<br>  <span class="hljs-comment">// ...省略</span><br>  <span class="hljs-keyword">const</span> search = self.location.search.toLowerCase();<br>  <span class="hljs-keyword">const</span> allowToHot = search.indexOf(<span class="hljs-string">&quot;webpack-dev-server-hot=false&quot;</span>) === -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> allowToLiveReload =<br>    search.indexOf(<span class="hljs-string">&quot;webpack-dev-server-live-reload=false&quot;</span>) === -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (hot &amp;&amp; allowToHot) &#123;<br>    log.info(<span class="hljs-string">&quot;App hot update...&quot;</span>);<br><br>    hotEmitter.emit(<span class="hljs-string">&quot;webpackHotUpdate&quot;</span>, status.currentHash);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&quot;undefined&quot;</span> &amp;&amp; self.window) &#123;<br>      <span class="hljs-comment">// broadcast update to window</span><br>      self.postMessage(<span class="hljs-string">`webpackHotUpdate<span class="hljs-subst">$&#123;status.currentHash&#125;</span>`</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// allow refreshing the page only if liveReload isn&#x27;t disabled</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (liveReload &amp;&amp; allowToLiveReload) &#123;<br>    <span class="hljs-keyword">let</span> rootWindow = self;<br><br>    <span class="hljs-comment">// use parent window for reload (in case we&#x27;re in an iframe with no valid src)</span><br>    <span class="hljs-keyword">const</span> intervalId = self.setInterval(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (rootWindow.location.protocol !== <span class="hljs-string">&quot;about:&quot;</span>) &#123;<br>        <span class="hljs-comment">// reload immediately if protocol is valid</span><br>        applyReload(rootWindow, intervalId);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        rootWindow = rootWindow.parent;<br><br>        <span class="hljs-keyword">if</span> (rootWindow.parent === rootWindow) &#123;<br>          <span class="hljs-comment">// if parent equals current window we&#x27;ve reached the root which would continue forever, so trigger a reload anyways</span><br>          applyReload(rootWindow, intervalId);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接着搜索 url 参数，如果 url 参数包含<code>webpack-dev-server-hot=false</code>则不会进入热更新的逻辑，如果包含<code>webpack-dev-server-live-reload=false</code>则不会进刷新的逻辑。</p><p>如果进了热更新逻辑，则广播<code>webpackHotUpdate</code>事件。<br>如果进了刷新的逻辑，就刷新页面了。</p><p>再接着找<code>webpackHotUpdate</code>在哪注册的。发现是在 webpack 内置的一个消息，我们去<code>&quot;webpack/hot/emitter.js&quot;</code>下找。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// webpack/hot/dev-server.js</span><br><span class="hljs-keyword">var</span> upToDate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upToDate</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> lastHash.indexOf(__webpack_hash__) &gt;= <span class="hljs-number">0</span>;<br>&#125;;<br>hotEmitter.on(<span class="hljs-string">&quot;webpackHotUpdate&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">currentHash</span>) </span>&#123;<br>  lastHash = currentHash;<br>  <span class="hljs-keyword">if</span> (!upToDate() &amp;&amp; <span class="hljs-built_in">module</span>.hot.status() === <span class="hljs-string">&quot;idle&quot;</span>) &#123;<br>    log(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;[HMR] Checking for updates on the server...&quot;</span>);<br>    check();<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>存储最后一次的 hash 值，判断是否更新了并且当前是否处于空闲状态。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> check = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">module</span>.hot<br>    .check(<span class="hljs-literal">true</span>)<br>    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">updatedModules</span>) </span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>    &#125;)<br>    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>      <span class="hljs-comment">// ...省略</span><br>    &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>可以看到 check 里调用了一个 module.hot.check，我们找到这个东西，进去看看返回的 promise 是什么<br>在<code>/HotModuleReplacement.runtime.js</code>文件内找到 hotCheck</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hotCheck</span>(<span class="hljs-params">applyOnUpdate</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (currentStatus !== <span class="hljs-string">&quot;idle&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;check() is only allowed in idle status&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> setStatus(<span class="hljs-string">&quot;check&quot;</span>)<br>    .then($hmrDownloadManifest$)<br>    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">update</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (!update) &#123;<br>        <span class="hljs-keyword">return</span> setStatus(applyInvalidatedModules() ? <span class="hljs-string">&quot;ready&quot;</span> : <span class="hljs-string">&quot;idle&quot;</span>).then(<br>          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;,<br>        );<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> setStatus(<span class="hljs-string">&quot;prepare&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> updatedModules = [];<br>        blockingPromises = [];<br>        currentUpdateApplyHandlers = [];<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(<br>          <span class="hljs-built_in">Object</span>.keys($hmrDownloadUpdateHandlers$).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">            promises,</span></span><br><span class="hljs-params"><span class="hljs-function">            key,</span></span><br><span class="hljs-params"><span class="hljs-function">          </span>) </span>&#123;<br>            $hmrDownloadUpdateHandlers$[key](<br>              update.c,<br>              update.r,<br>              update.m,<br>              promises,<br>              currentUpdateApplyHandlers,<br>              updatedModules,<br>            );<br>            <span class="hljs-keyword">return</span> promises;<br>          &#125;,<br>          []),<br>        ).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">return</span> waitForBlockingPromises(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (applyOnUpdate) &#123;<br>              <span class="hljs-keyword">return</span> internalApply(applyOnUpdate);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> setStatus(<span class="hljs-string">&quot;ready&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> updatedModules;<br>              &#125;);<br>            &#125;<br>          &#125;);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里的操作总结一句话就是先设置成 check 状态，然后再设置 prepare 状态，如果 applyOnUpdate 为 false 再设置成 ready。</p><p>这两个<code>$</code>包裹的是运行时方法，在他的上一层有替换。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">generate</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> Template.getFunctionContent(<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./HotModuleReplacement.runtime.js&quot;</span>)<br>)<br>.replace(<span class="hljs-regexp">/\$getFullHash\$/g</span>, RuntimeGlobals.getFullHash)<br>.replace(<br><span class="hljs-regexp">/\$interceptModuleExecution\$/g</span>,<br>RuntimeGlobals.interceptModuleExecution<br>)<br>.replace(<span class="hljs-regexp">/\$moduleCache\$/g</span>, RuntimeGlobals.moduleCache)<br>.replace(<span class="hljs-regexp">/\$hmrModuleData\$/g</span>, RuntimeGlobals.hmrModuleData)<br>.replace(<span class="hljs-regexp">/\$hmrDownloadManifest\$/g</span>, RuntimeGlobals.hmrDownloadManifest)<br>.replace(<br><span class="hljs-regexp">/\$hmrInvalidateModuleHandlers\$/g</span>,<br>RuntimeGlobals.hmrInvalidateModuleHandlers<br>)<br>.replace(<br><span class="hljs-regexp">/\$hmrDownloadUpdateHandlers\$/g</span>,<br>RuntimeGlobals.hmrDownloadUpdateHandlers<br>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>hmrDownloadManifest</code>大概就是对照<code>hash</code>进行文件请求一个<code>[hash].update.json</code> 下来,然后传递给下一层，这块最好是打断点进去看，不然找源文件有点头秃，都是运行时代码。总结一句话：<code>hmrDownloadUpdateHandlers</code>里面会有个 jsonp 方法，如果配置了 CSS 的相关 loader 还会有个<code>miniCss</code>的方法，jsonp 方法里面会调用<code>loadUpdateChunk</code>，然后<code>loadUpdateChunk</code>内又调用了<code>loadScript</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// lib/runtime/LoadScriptRuntimeModule.js</span><br>fn = <span class="hljs-string">&quot;loadScript&quot;</span><span class="hljs-string">`<span class="hljs-subst">$&#123;fn&#125;</span> = <span class="hljs-subst">$&#123;runtimeTemplate.basicFunction(</span></span><br><span class="hljs-subst"><span class="hljs-string">  <span class="hljs-string">&quot;url, done, key, chunkId&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">  [</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;if(inProgress[url]) &#123; inProgress[url].push(done); return; &#125;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;var script, needAttach;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;if(key !== undefined) &#123;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    Template.indent([</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-string">&#x27;var scripts = document.getElementsByTagName(&quot;script&quot;);&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-string">&quot;for(var i = 0; i &lt; scripts.length; i++) &#123;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      Template.indent([</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&quot;var s = scripts[i];&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">`if(s.getAttribute(&quot;src&quot;) == url<span class="hljs-subst">$&#123;</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">          uniqueName</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            ? <span class="hljs-string">&#x27; || s.getAttribute(&quot;data-webpack&quot;) == dataWebpackPrefix + key&#x27;</span></span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            : <span class="hljs-string">&quot;&quot;</span></span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">        &#125;</span>) &#123; script = s; break; &#125;`</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      ]),</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-string">&quot;&#125;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    ]),</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;&#125;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;if(!script) &#123;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    Template.indent([</span></span><br><span class="hljs-subst"><span class="hljs-string">      <span class="hljs-string">&quot;needAttach = true;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      createScript.call(code, <span class="hljs-built_in">this</span>.chunk),</span></span><br><span class="hljs-subst"><span class="hljs-string">    ]),</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;&#125;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;inProgress[url] = [done];&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;var onScriptComplete = &quot;</span> +</span></span><br><span class="hljs-subst"><span class="hljs-string">      runtimeTemplate.basicFunction(</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&quot;prev, event&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">        Template.asString([</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;// avoid mem leaks in IE.&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;script.onerror = script.onload = null;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;clearTimeout(timeout);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;var doneFns = inProgress[url];&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;delete inProgress[url];&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;script.parentNode &amp;&amp; script.parentNode.removeChild(script);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">`doneFns &amp;&amp; doneFns.forEach(<span class="hljs-subst">$&#123;runtimeTemplate.returningFunction(</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            <span class="hljs-string">&quot;fn(event)&quot;</span>,</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            <span class="hljs-string">&quot;fn&quot;</span>,</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">          )&#125;</span>);`</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">&quot;if(prev) return prev(event);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">        ]),</span></span><br><span class="hljs-subst"><span class="hljs-string">      ),</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;;&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">`var timeout = setTimeout(onScriptComplete.bind(null, undefined, &#123; type: &#x27;timeout&#x27;, target: script &#125;), <span class="hljs-subst">$&#123;loadTimeout&#125;</span>);`</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;script.onerror = onScriptComplete.bind(null, script.onerror);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;script.onload = onScriptComplete.bind(null, script.onload);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">    <span class="hljs-string">&quot;needAttach &amp;&amp; document.head.appendChild(script);&quot;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">  ],</span></span><br><span class="hljs-subst"><span class="hljs-string">)&#125;</span>;`</span>;<br></code></pre></div></td></tr></table></figure><p>loadScript 的操作：创建个 script 标签，把 url 赋值给 src 吧啦吧啦一系列操作，最后给给这个加到 html 的 head 的尾部，如果给断点打在最后一行这个，就可以看到了。等到 onLoad 完之后，会再把这个 script 标签移除掉。<code>script.parentNode &amp;&amp; script.parentNode.removeChild(script)</code>相关逻辑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首次启动：</p><p>源代码 =&gt; 编译（compiler） =&gt; bundle.js 产物（这里是默认不分割代码的结果） =&gt; 浏览器访问端口 =&gt; 服务器返回静态资源（html，css，js 等）<br>浏览器与 dev-server 建立 Socket 连接，首次收到 hash</p><p>更新：</p><p>源代码修改 =&gt; 增量编译（compiler） =&gt; HMR（基于新内容生成[hash].update.js(on)）=&gt; 向浏览器推送消息（包括新的 hash） =&gt; 浏览器创建 script 标签下载[hash].update.js =&gt; 调用页面更新的方法（module.hot.accept）</p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小试PWA</title>
    <link href="/article/246388ad/"/>
    <url>/article/246388ad/</url>
    
    <content type="html"><![CDATA[<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>首先 PWA 的与正常的 web 都是一样的，只是在 html 引入了一个叫<code>manifest.webmanifest</code>的 json 文件。官方名：应用清单</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;manifest&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./manifest.webmanifest&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Progressive Web App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// manifest.webmanifest</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Progressive Web App&quot;</span>,<br>  <span class="hljs-attr">&quot;short_name&quot;</span>: <span class="hljs-string">&quot;PWA&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;test pwa&quot;</span>,<br>  <span class="hljs-attr">&quot;start_url&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>  <span class="hljs-attr">&quot;display&quot;</span>: <span class="hljs-string">&quot;standalone&quot;</span>,<br>  <span class="hljs-attr">&quot;background_color&quot;</span>: <span class="hljs-string">&quot;#fff&quot;</span>,<br>  <span class="hljs-attr">&quot;icons&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;src&quot;</span>: <span class="hljs-string">&quot;./icon.png&quot;</span>,<br>      <span class="hljs-attr">&quot;sizes&quot;</span>: <span class="hljs-string">&quot;672x672&quot;</span>,<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;image/png&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>字段说明</p><ul><li>name：应用程序的全名（必须）</li><li>short_name：简称</li><li>description：程序的简介</li><li>icons：安装下来显示的图标（必须）</li><li>start_url：启动程序时启动的入口 比如我是<code>localhost/1/2/index.html</code>访问的主页，那我这个地方就要填写<code>./1/2/index.html</code></li><li>display：程序的显示方式。可以是 fullscreen，standalone，minimal-ui，browser。</li><li>background_color：默认背景的颜色，在安装期间和启动时会用到。</li></ul><p>更多可查看<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Manifest 字段说明</a></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>因为 pwa 是基于 service worker 的，所以需要搞个证书，搭建一个 HTTPS 环境。</p><h3 id="生成-SSL-证书"><a href="#生成-SSL-证书" class="headerlink" title="生成 SSL 证书"></a>生成 SSL 证书</h3><p>首先新建一个配置文件 ssl.conf 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs conf">[ req ]<br>default_bits       = 4096<br>distinguished_name = req_distinguished_name<br>req_extensions     = req_ext<br><br>[ req_distinguished_name ]<br>countryName                 = Country Name (2 letter code)<br>countryName_default         = GB<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = England<br>localityName                = Locality Name (eg, city)<br>localityName_default        = Brighton<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Hallmarkdesign<br>organizationalUnitName            = Organizational Unit Name (eg, section)<br>organizationalUnitName_default    = IT<br>commonName                  = Common Name (e.g. server FQDN or YOUR name)<br>commonName_max              = 64<br>commonName_default          = localhost<br><br>[ req_ext ]<br>subjectAltName = @alt_names<br><br>[alt_names]<br>IP.1    = 127.0.0.1<br>DNS.1   = localhost<br></code></pre></div></td></tr></table></figure><ol><li><p>生成私钥 <code>openssl genrsa -out private.key 4096</code></p></li><li><p>生成证书请求文件（CSR）<code>openssl req -new -sha256 -out private.csr -key private.key -config ssl.conf</code></p></li><li><p>生成证书 <code>openssl x509 -req -days 3650 -in private.csr -signkey private.key -out private.crt -extensions req_ext -extfile ssl.conf</code></p></li></ol><p>然后在 nginx 啥的上导入进去就可以了</p><p>TIPS:VSCODE 可以安装个<a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">liveServer</a>，然后在设置里填入一下 key 和 crt 的绝对路径就可以了。</p><p>环境准备好了，可以开始撸代码了</p><h3 id="代码环节"><a href="#代码环节" class="headerlink" title="代码环节"></a>代码环节</h3><p>因为 SW 可以缓存请求，我们可以先搞个请求出来。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNews</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<br>    <span class="hljs-string">&quot;https://www.fastmock.site/mock/90081b6542ca917fc651013fe10b3815/api/getNews&quot;</span>,<br>  );<br>  <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> res.json();<br><br>  <span class="hljs-keyword">const</span> main = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#main&quot;</span>);<br>  main.innerHTML = json.title;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注册 SW</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">registerSW</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 判断浏览器是否支持SW</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;serviceWorker&quot;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 注册SW</span><br>      <span class="hljs-keyword">await</span> navigator.serviceWorker.register(<span class="hljs-string">&quot;./sw.js&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;SW register failed&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  getNews();<br>  registerSW();<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>然后开始写 SW 具体的一些操作。</p><p>首先定义一个<code>cacheName</code>,<code>const cacheName = &quot;news@v2&quot;</code>。</p><p>然后再定义一下我们要缓存的文件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 这个一定要写全，不然在浏览器上不会出现安装的按钮</span><br><span class="hljs-keyword">const</span> staticAssets = [<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-string">&quot;./index.html&quot;</span>, <span class="hljs-string">&quot;./index.js&quot;</span>, <span class="hljs-string">&quot;./sw.js&quot;</span>];<br></code></pre></div></td></tr></table></figure><p>接着再安装 SW</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JS"><span class="hljs-comment">// self相当于window，只不过这个self此时代表的SW</span><br>self.addEventListener(<span class="hljs-string">&quot;install&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// SW环境下用来存储的东西</span><br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.open(cacheName);<br>  <span class="hljs-keyword">await</span> cache.addAll(staticAssets);<br><br>  <span class="hljs-comment">// 手动触发sw的activate生命周期</span><br>  <span class="hljs-keyword">return</span> self.skipWaiting();<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>再写激活状态的需要执行的东西</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">self.addEventListener(<span class="hljs-string">&quot;activate&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 更新客户端上的sw相关文件</span><br>  self.clients.claim();<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>因为我们还有一个网络请求，所以我们要对网络请求也进行缓存</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">self.addEventListener(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-keyword">async</span> (e) =&gt; &#123;<br>  <span class="hljs-comment">// e是请求</span><br>  <span class="hljs-keyword">const</span> req = e.request;<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> URL(req.url);<br><br>  <span class="hljs-comment">// 如果请求的origin和当前origin相等，进行缓存匹配</span><br>  <span class="hljs-keyword">if</span> (url.origin === location.origin) &#123;<br>    e.respondWith(cacheFirst(req));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    e.respondWith(newtworkAndCache(req));<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cacheFirst</span>(<span class="hljs-params">req</span>) </span>&#123;<br>  <span class="hljs-comment">// 打开存储器</span><br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.open(cacheName);<br>  <span class="hljs-comment">// 查询是否有匹配的缓存</span><br>  <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> cache.match(req);<br>  <span class="hljs-comment">// 如果有就返回，没有就进行网络请求。</span><br>  <span class="hljs-keyword">return</span> cached || fetch(req);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newtworkAndCache</span>(<span class="hljs-params">req</span>) </span>&#123;<br>  <span class="hljs-comment">// 打开存储器</span><br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.open(cacheName);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 进行网络请求</span><br>    <span class="hljs-keyword">const</span> fresh = <span class="hljs-keyword">await</span> fetch(req);<br>    <span class="hljs-comment">// 将缓存放到存储里去</span><br>    <span class="hljs-keyword">await</span> cache.put(req, fresh.clone());<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 如果请求失败后，找缓存中是否有该请求</span><br>    <span class="hljs-keyword">const</span> cached = <span class="hljs-keyword">await</span> cache.match(req);<br>    <span class="hljs-keyword">return</span> cached;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这时再进入网页请求的话就会看到所有资源请求之前都带有一个小齿轮，这代表 SW 已经好了</p><p>在 chromeDevTools-应用分栏下可以看到有个清单和 ServiceWorker 的分类，可以在清单下看到为什么不能安装，按照提示进行修改就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存背锅？</title>
    <link href="/article/85e77354/"/>
    <url>/article/85e77354/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我们国内站有做中国传统节假日的提醒，因为中国传统节假日不太方便计算，所以每年都要在对象存储桶里更新对应的文件。</p><p>大前天接到工单反馈说我们没有 2022 年的日历提醒，然后运维同学就在对应文件进行了文件的更新。</p><p>过了一会儿之后测试同学跟我说：web 这面没办法拉取到最新的文件，但是直接访问请求可以拿到。还给我截图看了一下请求头，说我没按照当时的方案做：请求的时候加上<code>if-modified-since</code>这个。</p><p>我寻思着这些东西现在浏览器不都是会自动加上吗？然后自己去线上看了一下，也拉到了最新的节日信息，无法复现。然后用了另外几个同学的电脑（一定会有缓存，但是最近两天没打开过线上的）看了一下也没问题。</p><p>一脸懵逼，只能先甩锅再说：当时做这个功能的时候不是测试过缓存吗？当时都是正常的，最近也没需求改动这个，肯定没问题啊。</p><h2 id="追因"><a href="#追因" class="headerlink" title="追因"></a>追因</h2><p>先清楚自己的缓存，然后在测试环境看一下请求，没什么大问题。多了几个特殊字段引起了我的注意：<code>x-swift-cachetime</code>和<code>x-swift-savetime</code>。</p><p>查看了一下阿里云的说明：</p><ul><li><code>x-swift-savetime</code>:代表开始在 cdn 上缓存的时间</li><li><code>x-swift-cachetime</code>:cdn 默认缓存时间,超过了这个时间，该缓存就丢弃了，需要重新回源获取。</li><li><code>age</code>:代表在 cdn 上已经缓存的时间</li></ul><p>一个大胆的想法在我脑海中成立：</p><p>运维在更新好文件之后，并没有按照以往的强制刷新 cdn 缓存，然后因为我们的线上环境<code>cachetime</code>是 3600s，所以测试同学可能是在 3600s 内在 web 页面进行了测试，发现没有更新，然后去直接访问文件链接，但是这时候已经过了 3600s，所以一面拿到的是老的，一面拿到的是新的。</p><p>然后开始实践</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>首先在测试环境看了一下<code>cachetime</code>为 13，那我在 13s 内和 13s 后分别请求一次这个文件看看什么效果。</p><p>13s 内请求发现：chromeDevTools 显示状态代码 200，来自磁盘缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20211030/13%E5%86%85%E8%AF%B7%E6%B1%82.png" alt="13s内的请求"></p><p>13 后请求发现：状态码还是 200，请求头内带上了<code>if-modified-since</code>和<code>if-none-match</code>，响应 tab 里提示此请求没有可用的响应数据</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20211030/13%E5%A4%96%E8%AF%B7%E6%B1%82.png" alt="13s后的请求"></p><p>ok，破案。和我想的一样。</p>]]></content>
    
    
    <categories>
      
      <category>随手记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协商缓存</tag>
      
      <tag>强制缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的实现</title>
    <link href="/article/66276cbc/"/>
    <url>/article/66276cbc/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h2><p>只渲染可是区域的列表节点，滚动的时候进行数据的动态替换。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><p>计算出当前可视区域起始数据的索引 startIndex</p></li><li><p>计算出当前可视区域结束数据的索引 endIndex</p></li><li><p>计算出当前可视区域内的数据，并渲染</p></li><li><p>滚动发生时，计算 startIndex 对应的数据，在整个列表的偏移位置 startOffset ，并且更新到列表上</p></li></ol><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><ul><li><p>真正渲染的元素 virtual-list</p></li><li><p>撑开高度的元素，保证滚动 virtual-list-phantom</p></li><li><p>容器元素 virtual-list-container</p></li></ul><h2 id="监听滚动"><a href="#监听滚动" class="headerlink" title="监听滚动"></a>监听滚动</h2><p>监听 virtual-list-container 的滚动事件，获取滚动条到顶部的距离 scrollTop</p><h2 id="需要准备的数据"><a href="#需要准备的数据" class="headerlink" title="需要准备的数据"></a>需要准备的数据</h2><p>可视区域的高度：screenHeight</p><p>列表项的高度：itemSize</p><p>列表数据：listData</p><p>当前的滚动位置：scrollTop</p><h2 id="得出最终想要的数据"><a href="#得出最终想要的数据" class="headerlink" title="得出最终想要的数据"></a>得出最终想要的数据</h2><p>列表总高度:<code>listHeight = itemSize * listData.length</code></p><p>可显示的列表项数:<code>showedCount = Math.ceil(screenHeight / itemSize)</code></p><p>数据的起始索引:<code>startIndex = Math.floor(scrollTop / itemSize)</code></p><p>数据的结束索引:<code>endIndex = startIndex + showedCount</code></p><p>列表显示的数据:<code>showedData = listData.slice(startIndex,endIndex)</code></p><p>偏移量（列表数据的第一个数据到现在开头数据的索引的差值）<code>startOffset = scrollTop - (scrollTop % itemSize)</code></p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p><a href="https://github.com/AruSeito/daily-practice/blob/main/my-react-app/src/component/VirtualList.jsx">Github</a></p>]]></content>
    
    
    <categories>
      
      <category>手撕源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面性能调优记录</title>
    <link href="/article/86b01b74/"/>
    <url>/article/86b01b74/</url>
    
    <content type="html"><![CDATA[<p>前两天收到测试的反馈，日历页面会非常卡，每次切换月份都要卡顿 10s 多。</p><p>我寻思最近也没有这面的需求啊，也没有改动过什么，为啥会卡呢。</p><p>致命甩锅三连问：</p><ol><li><p>是不是电脑问题啊，你先把你没用的都关了再看一下</p></li><li><p>最近也没这面的需求，要卡应该之前就卡了，不会这时卡啊。</p></li><li><p>不行你换个浏览器试试。</p></li></ol><p>虽然测试这面应付过去了，但是本着求实的态度，默默的自己打开了 DevTools 开始按照测试说的操作来看一下是否有报错/网络请求卡顿之类的。</p><p>然后发现有个请求，从进入 pending 到 200 大概经历了 10s，我点开这个请求一看，我麻了。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210919/%E8%AF%B7%E6%B1%82.jpeg" alt="请求"></p><p>然后看了一下它的 waterfall，发现各项指标都正常，总共花费 60ms+。那应该跟网络请求没关系。</p><p>然后打卡 Performance 开始录制。录制完之后我再一次麻了。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210919/performance.png" alt="performance"></p><p>问题很大啊。先不管这些，先看一下这个请求为什么卡住，首先从火炬图上可以看到的是他在这一个片段里执行了 N 此<code>mergeWithServer</code>，这个方法应该是 redux 的。</p><p>然后点开他对应的最上层打开 callTree 一层一层看，发现<code>mergeWithServer</code>这个方法下<code>dispatch</code>一共占了 6s 多。</p><p>那问题也就出现在这。看一下源码怎么写的</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">ids.map(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 一系列操作</span><br>  dispatch(doSomeThing(data));<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>好家伙，难怪网络请求直接会被卡死，原来主线程都被卡死了。有 150 个 id，在这 dispatch 了 150 次。。。浏览器主线程直接被卡死了。</p><p>优化方案非常简单：</p><p>在 map 的时候把数据直接做好，然后只 dispatch 一次就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redux</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emoji在Chrome显示问题</title>
    <link href="/article/a835eac3/"/>
    <url>/article/a835eac3/</url>
    
    <content type="html"><![CDATA[<p>前几天接到一个莫名其妙的需求，说文本中有 emoji，然后文字和 emoji 粘连了，需要分开。</p><p>但是我打开看了一下产品说的位置，发现并没有粘连。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210919/%E4%BA%A7%E5%93%81%E6%88%AA%E5%9B%BE.png" alt="产品看到的"></p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210919/%E6%88%91%E7%9A%84%E6%88%AA%E5%9B%BE.png" alt="我看到的"></p><p>开始一顿甩锅操作，致命三连问：</p><ol><li><p>你是什么浏览器？</p></li><li><p>浏览器什么版本？</p></li><li><p>是不是浏览器调整了其他字体。</p></li></ol><p>发现这些居然跟我的都一样，居然会产生这种差异。</p><p>在经过一系列搜索后找到了答案：</p><p>原文连接:<a href="https://segmentfault.com/q/1010000011020467?utm_source=sf-similar-question">emoji 和文字会重合</a></p><p>原因如下：</p><p>Chrome 渲染 emoji 的方式与其他浏览器（如 Safari）相比有些不同。在 Retina 屏幕下，Chrome 渲染正常，而在非 Retina 屏幕下会出现 emoji 与文字重叠的问题。</p><p>我惊呆了。不太敢相信是这个问题，然后我就把笔记本接到一块非 retina 屏上来回拖动，还真是这样，在 retina 上会更小一点。</p><p>解决方案也很简单，就是在 emoji 下插入一个空格。</p><p>PS： 原文答案这种解决方案也可以，只不过我们有的地方并不适合给 emoji 单独插一个 span 来解决，所以采用了 js 的方法。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 从👇这个源更新正则表达式</span><br><span class="hljs-comment">// https://github.com/twitter/twemoji-parser/blob/master/src/lib/regex.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addSpaceAfterEmoji = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> reg =<br>    <span class="hljs-regexp">/(?:\ud83d\udc68\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc68\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc68\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc68\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc68\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffc-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffd-\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb\udffc\udffe\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffd\udfff]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc68\ud83c[\udffb-\udffe]|\ud83d\udc69\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83d\udc69\ud83c[\udffb-\udffe]|\ud83e\uddd1\ud83c\udffb\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffc\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffd\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udffe\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\ud83c\udfff\u200d\ud83e\udd1d\u200d\ud83e\uddd1\ud83c[\udffb-\udfff]|\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1|\ud83d\udc6b\ud83c[\udffb-\udfff]|\ud83d\udc6c\ud83c[\udffb-\udfff]|\ud83d\udc6d\ud83c[\udffb-\udfff]|\ud83d[\udc6b-\udc6d])|(?:\ud83d[\udc68\udc69]|\ud83e\uddd1)(?:\ud83c[\udffb-\udfff])?\u200d(?:\u2695\ufe0f|\u2696\ufe0f|\u2708\ufe0f|\ud83c[\udf3e\udf73\udf7c\udf84\udf93\udfa4\udfa8\udfeb\udfed]|\ud83d[\udcbb\udcbc\udd27\udd2c\ude80\ude92]|\ud83e[\uddaf-\uddb3\uddbc\uddbd])|(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75]|\u26f9)((?:\ud83c[\udffb-\udfff]|\ufe0f)\u200d[\u2640\u2642]\ufe0f)|(?:\ud83c[\udfc3\udfc4\udfca]|\ud83d[\udc6e\udc70\udc71\udc73\udc77\udc81\udc82\udc86\udc87\ude45-\ude47\ude4b\ude4d\ude4e\udea3\udeb4-\udeb6]|\ud83e[\udd26\udd35\udd37-\udd39\udd3d\udd3e\uddb8\uddb9\uddcd-\uddcf\uddd6-\udddd])(?:\ud83c[\udffb-\udfff])?\u200d[\u2640\u2642]\ufe0f|(?:\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83c\udff3\ufe0f\u200d\u26a7\ufe0f|\ud83c\udff3\ufe0f\u200d\ud83c\udf08|\ud83c\udff4\u200d\u2620\ufe0f|\ud83d\udc15\u200d\ud83e\uddba|\ud83d\udc3b\u200d\u2744\ufe0f|\ud83d\udc41\u200d\ud83d\udde8|\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc6f\u200d\u2640\ufe0f|\ud83d\udc6f\u200d\u2642\ufe0f|\ud83e\udd3c\u200d\u2640\ufe0f|\ud83e\udd3c\u200d\u2642\ufe0f|\ud83e\uddde\u200d\u2640\ufe0f|\ud83e\uddde\u200d\u2642\ufe0f|\ud83e\udddf\u200d\u2640\ufe0f|\ud83e\udddf\u200d\u2642\ufe0f|\ud83d\udc08\u200d\u2b1b)|[#*0-9]\ufe0f?\u20e3|(?:[©®\u2122\u265f]\ufe0f)|(?:\ud83c[\udc04\udd70\udd71\udd7e\udd7f\ude02\ude1a\ude2f\ude37\udf21\udf24-\udf2c\udf36\udf7d\udf96\udf97\udf99-\udf9b\udf9e\udf9f\udfcd\udfce\udfd4-\udfdf\udff3\udff5\udff7]|\ud83d[\udc3f\udc41\udcfd\udd49\udd4a\udd6f\udd70\udd73\udd76-\udd79\udd87\udd8a-\udd8d\udda5\udda8\uddb1\uddb2\uddbc\uddc2-\uddc4\uddd1-\uddd3\udddc-\uddde\udde1\udde3\udde8\uddef\uddf3\uddfa\udecb\udecd-\udecf\udee0-\udee5\udee9\udef0\udef3]|[\u203c\u2049\u2139\u2194-\u2199\u21a9\u21aa\u231a\u231b\u2328\u23cf\u23ed-\u23ef\u23f1\u23f2\u23f8-\u23fa\u24c2\u25aa\u25ab\u25b6\u25c0\u25fb-\u25fe\u2600-\u2604\u260e\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638-\u263a\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267b\u267f\u2692-\u2697\u2699\u269b\u269c\u26a0\u26a1\u26a7\u26aa\u26ab\u26b0\u26b1\u26bd\u26be\u26c4\u26c5\u26c8\u26cf\u26d1\u26d3\u26d4\u26e9\u26ea\u26f0-\u26f5\u26f8\u26fa\u26fd\u2702\u2708\u2709\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u2764\u27a1\u2934\u2935\u2b05-\u2b07\u2b1b\u2b1c\u2b50\u2b55\u3030\u303d\u3297\u3299])(?:\ufe0f|(?!\ufe0e))|(?:(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75\udd90]|[\u261d\u26f7\u26f9\u270c\u270d])(?:\ufe0f|(?!\ufe0e))|(?:\ud83c[\udf85\udfc2-\udfc4\udfc7\udfca]|\ud83d[\udc42\udc43\udc46-\udc50\udc66-\udc69\udc6e\udc70-\udc78\udc7c\udc81-\udc83\udc85-\udc87\udcaa\udd7a\udd95\udd96\ude45-\ude47\ude4b-\ude4f\udea3\udeb4-\udeb6\udec0\udecc]|\ud83e[\udd0c\udd0f\udd18-\udd1c\udd1e\udd1f\udd26\udd30-\udd39\udd3d\udd3e\udd77\uddb5\uddb6\uddb8\uddb9\uddbb\uddcd-\uddcf\uddd1-\udddd]|[\u270a\u270b]))(?:\ud83c[\udffb-\udfff])?|(?:\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f|\ud83c\udde6\ud83c[\udde8-\uddec\uddee\uddf1\uddf2\uddf4\uddf6-\uddfa\uddfc\uddfd\uddff]|\ud83c\udde7\ud83c[\udde6\udde7\udde9-\uddef\uddf1-\uddf4\uddf6-\uddf9\uddfb\uddfc\uddfe\uddff]|\ud83c\udde8\ud83c[\udde6\udde8\udde9\uddeb-\uddee\uddf0-\uddf5\uddf7\uddfa-\uddff]|\ud83c\udde9\ud83c[\uddea\uddec\uddef\uddf0\uddf2\uddf4\uddff]|\ud83c\uddea\ud83c[\udde6\udde8\uddea\uddec\udded\uddf7-\uddfa]|\ud83c\uddeb\ud83c[\uddee-\uddf0\uddf2\uddf4\uddf7]|\ud83c\uddec\ud83c[\udde6\udde7\udde9-\uddee\uddf1-\uddf3\uddf5-\uddfa\uddfc\uddfe]|\ud83c\udded\ud83c[\uddf0\uddf2\uddf3\uddf7\uddf9\uddfa]|\ud83c\uddee\ud83c[\udde8-\uddea\uddf1-\uddf4\uddf6-\uddf9]|\ud83c\uddef\ud83c[\uddea\uddf2\uddf4\uddf5]|\ud83c\uddf0\ud83c[\uddea\uddec-\uddee\uddf2\uddf3\uddf5\uddf7\uddfc\uddfe\uddff]|\ud83c\uddf1\ud83c[\udde6-\udde8\uddee\uddf0\uddf7-\uddfb\uddfe]|\ud83c\uddf2\ud83c[\udde6\udde8-\udded\uddf0-\uddff]|\ud83c\uddf3\ud83c[\udde6\udde8\uddea-\uddec\uddee\uddf1\uddf4\uddf5\uddf7\uddfa\uddff]|\ud83c\uddf4\ud83c\uddf2|\ud83c\uddf5\ud83c[\udde6\uddea-\udded\uddf0-\uddf3\uddf7-\uddf9\uddfc\uddfe]|\ud83c\uddf6\ud83c\udde6|\ud83c\uddf7\ud83c[\uddea\uddf4\uddf8\uddfa\uddfc]|\ud83c\uddf8\ud83c[\udde6-\uddea\uddec-\uddf4\uddf7-\uddf9\uddfb\uddfd-\uddff]|\ud83c\uddf9\ud83c[\udde6\udde8\udde9\uddeb-\udded\uddef-\uddf4\uddf7\uddf9\uddfb\uddfc\uddff]|\ud83c\uddfa\ud83c[\udde6\uddec\uddf2\uddf3\uddf8\uddfe\uddff]|\ud83c\uddfb\ud83c[\udde6\udde8\uddea\uddec\uddee\uddf3\uddfa]|\ud83c\uddfc\ud83c[\uddeb\uddf8]|\ud83c\uddfd\ud83c\uddf0|\ud83c\uddfe\ud83c[\uddea\uddf9]|\ud83c\uddff\ud83c[\udde6\uddf2\uddfc]|\ud83c[\udccf\udd8e\udd91-\udd9a\udde6-\uddff\ude01\ude32-\ude36\ude38-\ude3a\ude50\ude51\udf00-\udf20\udf2d-\udf35\udf37-\udf7c\udf7e-\udf84\udf86-\udf93\udfa0-\udfc1\udfc5\udfc6\udfc8\udfc9\udfcf-\udfd3\udfe0-\udff0\udff4\udff8-\udfff]|\ud83d[\udc00-\udc3e\udc40\udc44\udc45\udc51-\udc65\udc6a\udc6f\udc79-\udc7b\udc7d-\udc80\udc84\udc88-\udca9\udcab-\udcfc\udcff-\udd3d\udd4b-\udd4e\udd50-\udd67\udda4\uddfb-\ude44\ude48-\ude4a\ude80-\udea2\udea4-\udeb3\udeb7-\udebf\udec1-\udec5\uded0-\uded2\uded5-\uded7\udeeb\udeec\udef4-\udefc\udfe0-\udfeb]|\ud83e[\udd0d\udd0e\udd10-\udd17\udd1d\udd20-\udd25\udd27-\udd2f\udd3a\udd3c\udd3f-\udd45\udd47-\udd76\udd78\udd7a-\uddb4\uddb7\uddba\uddbc-\uddcb\uddd0\uddde-\uddff\ude70-\ude74\ude78-\ude7a\ude80-\ude86\ude90-\udea8\udeb0-\udeb6\udec0-\udec2\uded0-\uded6]|[\u23e9-\u23ec\u23f0\u23f3\u267e\u26ce\u2705\u2728\u274c\u274e\u2753-\u2755\u2795-\u2797\u27b0\u27bf\ue50a])|\ufe0f/g</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&quot;string&quot;</span><br>    ? str.replace(reg, <span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> word + <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;)<br>    : str;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>然后顺利解决收工。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emoji</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手撕一个eventBus</title>
    <link href="/article/27b53d37/"/>
    <url>/article/27b53d37/</url>
    
    <content type="html"><![CDATA[<p>首先需要知道 eventBus 中的方法都有哪些。按照方法进行基础框架的搭建</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eventBus</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">// 触发事件</span><br>  <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">eventName, ...args</span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">// 注册事件</span><br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, cb</span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">// 注册事件但只触发一次</span><br>  <span class="hljs-function"><span class="hljs-title">onOnce</span>(<span class="hljs-params">eventName, cb</span>)</span> &#123;&#125;<br><br>  <span class="hljs-comment">// 取消事件</span><br>  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>new 的时候对 event 进行初始化。然后分别填入逻辑</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eventBus</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.events = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">eventName, ...args</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> cb = <span class="hljs-built_in">this</span>.events[eventName];<br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;没这个事件啊&quot;</span>);<br>    &#125;<br><br>    cb.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb.apply(<span class="hljs-built_in">this</span>, args));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, cb</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events[eventName]) &#123;<br>      <span class="hljs-built_in">this</span>.events[eventName] = [];<br>    &#125;<br>    <span class="hljs-built_in">this</span>.events[eventName].push(cb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">onOnce</span>(<span class="hljs-params">eventName, cb</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> func = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.off(eventName, func);<br>      cb.apply(<span class="hljs-built_in">this</span>, args);<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.on(eventName, func);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, cb</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      <span class="hljs-built_in">this</span>.events[eventName] = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.events[event] = <span class="hljs-built_in">this</span>.events[event].filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item !== cb);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手撕源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eventBus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期面试复盘</title>
    <link href="/article/c0cc8344/"/>
    <url>/article/c0cc8344/</url>
    
    <content type="html"><![CDATA[<h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><p>就记住这几个。</p><ol><li><p>react-router 动态路由</p></li><li><p>Webpack 中的 loader 和 plugin 区别<br>Loader 的作用是让 webpack 拥有加载和解析非 JavaScript 文件的能力。Plugin 是扩展 Webpack 的功能，在 webpack 运行的生命周期中。</p></li><li><p>Chunk 和 bundle 的区别<br>chunk 是打包过程中的文件，bundle 是打包的结果。</p></li><li><p>Webpack 的构建优化<br>可以看我另外一篇写的构建优化</p></li><li><p>Hook：useEffect useRef useCallback useMemo<br>解释了一下用法，原理。什么时候用。</p></li><li><p>描述 Redux 数据流<br>单项数据流：dispatch(Action)-&gt;Reducer-&gt;Store.</p></li><li><p>React-sugar 用过吗？<br>没用过。</p></li><li><p>React 是如何数据驱动视图的<br>看<a href="https://react.iamkasong.com/">卡颂大佬的 React 源码解析</a>。</p></li><li><p>Node 的事件循环（10 为分界线）<br>看我摘抄淘宝前端团队的那篇文章《JavaScript 之事件循环》</p></li><li><p>强缓存协商缓存</p><ul><li>强缓存：cache- control 和 expiress</li><li>协商缓存：last-modify 和 If-Modified-Since：和时间有关，时间不一致会有问题。Etag 和 If-None-Match：服务端先对文件生成唯一标识 ETag，在第一次请求的时候带回来，第二次请求的时候请求头会有 If-None-Match：ETag 值的形式，如果 ETag 不匹配就拿新资源，匹配就返回 304。</li></ul></li><li><p>怎么判断啥时候该去请求最新的资源，啥时候去请求 service Worker<br>这个没回答，因为不了解 ServiceWorker，然后跟面试官讲了一下我所知道的 serviceWorker，PWA 以及用 serviceWorker 实现的 mock 方案这些。<br>具体可以看<a href="https://www.cnblogs.com/blueball/p/13268160.html">service Worker</a>第十点的缓存管理，大概就是在 servicerWoker 的 install 阶段时，open 待版本号的 cache，版本号变了就会更新了。</p></li><li><p>实现深拷贝<br>当时没实现出来，哈哈哈哈哈，只是面试官说了一下递归，遇到 object 就下一层这样的一个思路。因为但是只记得处理 Object</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">value, hashMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(value);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> hashKey = hashMap.get(value);<br>  <span class="hljs-keyword">if</span> (hashKey) &#123;<br>    <span class="hljs-keyword">return</span> hashKey;<br>  &#125;<br><br><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> value.constructor();<br>  hashMap.set(value, result);<br>  <span class="hljs-built_in">Object</span>.keys(value).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    result[key] = deepClone(value[key], hashMap);<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="13"><li>数组去重<br>哈哈哈哈哈，这个我也没实现。我比较皮的说了一句 <code>Array.from(new Set())</code>，然后面试官说不行。<br>然后我就搞了个 Map，遍历全部全部元素，key 就是 array[i]。然后面试官问我这种方式遇到<code>undefined</code>怎么办，我说<code>undefined</code>是可以作为 key 的，之前手滑给过一次 undefined，然后引发了 bug 哈哈哈哈，然后又问我能不能存<code>[1,2,3,[4,5]]</code>的第三项，我当时不太确定能不能存，告诉面试官不确定。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayNonRepeatfy</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>  <span class="hljs-keyword">let</span> array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span>(map.has(arr[i])) &#123;<br>      map.set(arr[i], i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      map.set(arr[i], i);<br>      array.push(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过这种不能应对<code>[1,2,3,[4,5],5,[4,5]]</code>去重。可以判断一下是<code>Array.isArray(num)||(typeof num === &quot;object&quot; &amp;&amp; num !== null)</code>，然后用 JSON.stringify 一下再存到 Map 里，在 has 判断的时候也先序列化一下。</p><ol start="14"><li>实现一个 moment.format<br>这个当时也没实现，也是仅仅实现了个不传 paramDate 和 formatStr 的最简单版本，只是跟面试官说了一下要想实现传入 formatStr 的这个，用正则会方便点。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> format = <span class="hljs-function">(<span class="hljs-params">paramDate, formatStr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(paramDate) || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">const</span> year = date.getFullYear();<br>  <span class="hljs-keyword">const</span> month = date.getMonth() + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> day = date.getDate();<br>  <span class="hljs-keyword">const</span> week = date.getDay();<br>  <span class="hljs-keyword">const</span> hour = date.getHours();<br>  <span class="hljs-keyword">const</span> minute = date.getMinutes();<br>  <span class="hljs-keyword">const</span> second = date.getSeconds();<br><br>  <span class="hljs-keyword">return</span> formatStr<br>    ? formatStr.replace(<br>        <span class="hljs-regexp">/Y&#123;2,4&#125;|M&#123;1,2&#125;|D&#123;1,2&#125;|d&#123;1,4&#125;|H&#123;1,2&#125;|m&#123;1,2&#125;|s&#123;1,2&#125;/g</span>,<br>        <span class="hljs-function">(<span class="hljs-params">match</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">switch</span> (match) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;YY&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(year).slice(-<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;YYY&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;YYYY&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(year);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;M&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(month);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;MM&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(month).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;D&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(day);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;DD&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(day).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;d&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(week);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dd&quot;</span>:<br>              <span class="hljs-keyword">return</span> weeks[week];<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ddd&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;周&quot;</span> + weeks[week];<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dddd&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;星期&quot;</span> + weeks[week];<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;H&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(hour);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;HH&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(hour).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;m&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(minute);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;mm&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(minute).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;s&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(second);<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ss&quot;</span>:<br>              <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(second).padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">default</span>:<br>              <span class="hljs-keyword">return</span> match;<br>          &#125;<br>        &#125;<br>      )<br>    : <span class="hljs-string">`<span class="hljs-subst">$&#123;year&#125;</span>-<span class="hljs-subst">$&#123;month&#125;</span>-<span class="hljs-subst">$&#123;day&#125;</span> <span class="hljs-subst">$&#123;hour&#125;</span>:<span class="hljs-subst">$&#123;minute&#125;</span>:<span class="hljs-subst">$&#123;second&#125;</span>`</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ol start="15"><li><p>实现一个符合 promise/A+的 promise。</p><p>看我前段时间写的手撕 promise</p></li><li><p>看代码题</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.异步输出</span><br><span class="hljs-comment">//请写出输出内容</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  <span class="hljs-keyword">await</span> async2(); <span class="hljs-comment">//等这个执行完。</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);<br>    resolve();<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>); <span class="hljs-comment">//1.进hong</span><br>&#125;, <span class="hljs-number">0</span>);<br><br>async1();<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise3&quot;</span>);<br>  resolve(); <span class="hljs-comment">//3].进微任务</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise4&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script end&quot;</span>);<br></code></pre></div></td></tr></table></figure><ol start="17"><li>实现一个 sleep 函数，多种方式，比如 sleep(1000)</li></ol><p>阻塞 js 执行就可以</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">num, fn</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - start &lt; num);<br>  fn();<br>&#125;;<br><br><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      resolve();<br>    &#125;, num);<br>  &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure><ol start="18"><li>合并两个有序整数数组，使之成为一个有序数组，function(arr, brr) ，假设 arr 长度刚好容纳所有数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> nums1First = nums1.length - nums2.length - <span class="hljs-number">1</span>,<br>    nums1Second = nums1.length - <span class="hljs-number">1</span>,<br>    nums2First = nums2.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (nums1First &gt;= <span class="hljs-number">0</span> &amp;&amp; nums2First &gt;= <span class="hljs-number">0</span>) &#123;<br>    nums1[nums1Second--] =<br>      nums1[nums1First] &gt; nums2[nums2First]<br>        ? nums1[nums1First--]<br>        : nums2[nums2First--];<br>  &#125;<br>  nums1.splice(<span class="hljs-number">0</span>, nums2First + <span class="hljs-number">1</span>, ...nums2.slice(<span class="hljs-number">0</span>, nums2First + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">return</span> nums1;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="美团打车"><a href="#美团打车" class="headerlink" title="美团打车"></a>美团打车</h2><ol><li>实现 checkbox 组件，提供给其他人使用</li><li>看代码题</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-keyword">const</span> people = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;,<br>&#125;;<br><span class="hljs-comment">// Q1</span><br>people.sayName();<br><span class="hljs-keyword">const</span> temp = people.sayName;<br><span class="hljs-comment">// Q2</span><br>temp();<br><span class="hljs-comment">// Q3 能否利用call/apply使输出结果为张三</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li>给定一个数组，移除所有相邻相同数字，直到没有相邻相同数字为止。</li></ol><p>Input:  [1, 2, 3, 3, 4, 4, 2, 5, 7, 7, 5, 6, 8, 1]<br>Output:  [1, 6, 8, 1]</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> filter = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> res = [];<br>  arr.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (res[res.length - <span class="hljs-number">1</span>] === item) &#123;<br>      res.pop();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(item);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ol start="4"><li>hash contentHash chunkHash 区别</li></ol><p>hash：工程级别，修改任何一个文件都会导致所有文件 hash 改变</p><p>chunkHash：模块级别的，根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。</p><p>contentHash：文件内容级别的，内容不同产生的 hash 就不同。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《自顶向下学 React 源码》学习笔记</title>
    <link href="/article/3f8812bd/"/>
    <url>/article/3f8812bd/</url>
    
    <content type="html"><![CDATA[<h2 id="如何学？"><a href="#如何学？" class="headerlink" title="如何学？"></a>如何学？</h2><p>将 React 完整的运行过程可以分为三个部分：产生更新、决定更新什么组件、将更新的组件渲染到页面。即：调度、协调、渲染。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p><a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">React 哲学</a>:React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式</p><p>目前 web 端快速响应的两大瓶颈：计算能力和网络延迟。对应的也就分别是 CPU 和 IO。</p><p>1000ms/60Hz = 16.6ms 浏览器刷新一次。</p><p>在这 16.6ms 之间，会依次 JS 脚本执行-&gt;样式布局-&gt;样式绘制</p><p>如果 JS 的脚本执行时间超过 16.6ms，就会掉帧。</p><p>以前的方案主要有：防抖和节流。但是治标不治本。</p><p>防抖：指定时间内不继续操作后执行。</p><p>节流：指定时间内只执行一次。</p><p>React 的做法是实现一种异步可中断的更新机制。</p><p>浏览器预留时间给 React，React 用这部分时间来干自己的事，如果这段时间内没干完，那么 React 就将控制权交回给浏览器，等下一次的预留时间。所以浏览器就有充足的时间进行样式布局+样式绘制。</p><h2 id="架构的演化"><a href="#架构的演化" class="headerlink" title="架构的演化"></a>架构的演化</h2><h3 id="老-React-的架构（15-及以前）"><a href="#老-React-的架构（15-及以前）" class="headerlink" title="老 React 的架构（15 及以前）"></a>老 React 的架构（15 及以前）</h3><p>老 React 中可以分为两部分：决定渲染组件（协调器）-》将组件渲染到视图中（渲染器）。</p><p>协调器（Reconciler）中会进行 Diff 算法，算出哪些需要更新，然后将要更新的内容交给渲染器（Render）中。</p><p>问题：</p><p>协调器与渲染器是依次执行工作。如果同时更新多个节点，第一个 DOM 会先发生变化，但是因为更新过程是同步的，所以会同时渲染出来。如果在这种老的架构上实现异步可中断许安然的话，在渲染过程中发生中断，协调器和渲染工作还在继续，但是第一个组件会先渲染完，其他组件没变化，所以推出了 16 这种架构。</p><h3 id="新-React-的架构（16-及以后）"><a href="#新-React-的架构（16-及以后）" class="headerlink" title="新 React 的架构（16 及以后）"></a>新 React 的架构（16 及以后）</h3><p>新 React 中分为三部分：调度更新（调度器）-&gt;决定更新什么（协调器）-&gt;将组件更新到视图中（渲染器）。</p><p>调度器会对更新项分配优先级，将高优先级的先交给协调器，接着创建虚拟 DOM，然后协调器进行 Diff 算法，给变化的 DOM 打上标记，再将更新的内容交给渲染器，由渲染器来执行视图操作，。如果在进行 Diff 的过程中来了新的更高优先级的更新项，则将正在 Diff 的更新项中断，先进行高优先级的 Diff。循环以上操作。因为这些操作都在内存中操作，用户并不会感知。（跟离线操作 DOM 一个意思）</p><h2 id="React-的新架构-—-Fiber"><a href="#React-的新架构-—-Fiber" class="headerlink" title="React 的新架构 —- Fiber"></a>React 的新架构 —- Fiber</h2><p>Fiber 是协程的一种实现方式，另一种协程的实现方式为 Generator。不采用 Generator 的原因：Generator 和 async 一样都具有传染性。更新可以中断并继续，更新具有优先级，高优先级可以打断低优先级。</p><h3 id="Fiber-的含义"><a href="#Fiber-的含义" class="headerlink" title="Fiber 的含义"></a>Fiber 的含义</h3><h4 id="从架构的角度来说"><a href="#从架构的角度来说" class="headerlink" title="从架构的角度来说"></a>从架构的角度来说</h4><ul><li><p>老 React 的架构：Reconciler 采用递归的方式执行，数据保存在递归的调用栈中，所以被称为 Stack Reconciler。</p></li><li><p>新 React 的架构：Reconciler 基于 Fiber 的节点实现，所以成为 Fiber Reconciler</p></li></ul><h4 id="从静态数据结构来说"><a href="#从静态数据结构来说" class="headerlink" title="从静态数据结构来说"></a>从静态数据结构来说</h4><p>每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的 DOM 节点等信息。</p><p>一个 React 应用中只能有一个 FiberRootNode，一个 FiberRootNode 最多有两个 RootFiber。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210807/%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="静态数据结构"></p><p>为什么父节点连接子节点用 child，子节点使用 Return 连接父节点？因为 React 15 中 Stack Reconciler 采用递归的方式，先从根递到子节点，在从子节点归到根，所以归阶段函数处理完会用 Return。在 Fiber Reconciler 采用遍历的方式，实现可中断的递归，所以复用了这种方式。</p><h4 id="作为动态工作单元"><a href="#作为动态工作单元" class="headerlink" title="作为动态工作单元"></a>作为动态工作单元</h4><p>每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</p><h3 id="Fiber-的工作原理"><a href="#Fiber-的工作原理" class="headerlink" title="Fiber 的工作原理"></a>Fiber 的工作原理</h3><h4 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h4><p>正常动画播放：先删除前一帧，然后计算当前帧，显示当前帧。如果当前帧计算量特别大就会有特别长的白屏时间。</p><p>在内存中绘制当前帧，绘制完后替换前一帧。（这不还是离线操作 DOM 的操作）</p><h4 id="Fiber-树双缓存"><a href="#Fiber-树双缓存" class="headerlink" title="Fiber 树双缓存"></a>Fiber 树双缓存</h4><h5 id="挂载时"><a href="#挂载时" class="headerlink" title="挂载时"></a>挂载时</h5><ol><li><p>运行<code>ReactDom.render</code>会创建一个 <code>FiberRoot</code> 和 <code>rootFiber</code>。<code>FiberRoot</code> 是整个应用的根结点，有且仅有一个。然后 <code>FiberRoot</code> 的 <code>current</code> 指针会指向页面上已经渲染好了的 Fiber 树上（<code>FiberRoot.current = rootFiber</code>）。<code>fiberRoot</code> 的 <code>current</code> 会指向当前页面上已渲染内容对应 Fiber 树，即 <code>current Fiber 树</code>。因为是首屏渲染，所以 rootFiber 下并没有任何东西。</p></li><li><p>进入<code>Render</code>阶段，根据组件的 JSX 创建 Fiber 树（<code>workInProgress Fiber</code>）。在创建的过程中会尝试复用<code>current fiber</code>上已有节点的属性。</p></li><li><p>进入<code>Commit</code>阶段 ，将 current 指针指向 <code>workInProgress 树</code>，成为 <code>current Fiber 树</code>。</p></li></ol><h5 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h5><ol><li><p>进入<code>Render</code>阶段，根据组件的 JSX 一棵新的 <code>workInProgress Fiber</code>。在创建的过程中会尝试复用<code>current fiber</code>上已有节点的属性。</p></li><li><p><code>workInProgress Fiber 树</code>在<code>Render阶段</code>完成构建后进入<code>Commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>。</p></li></ol><h2 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h2><p>Render 阶段指 调和器工作的阶段，主要是打标记（effectTag）是 Update 还是 Replace 等操作，并非指 Render 运行的阶段。Render 方法运行的阶段成为 Commit 阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210808/%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="三个阶段"></p><h3 id="挂载时-1"><a href="#挂载时-1" class="headerlink" title="挂载时"></a>挂载时</h3><p>用<code>CRA</code>创建一个最基础的 React 应用，用 devTool 录制一个从 0 到 1 的火炬图。</p><p>在 Render 阶段经历了如下：（可以在 beginWork 和 completeWork 打个断点看一下，看笔记想不起来记得再手动调试一次,记得对着 CRA 创建的 DEMO 代码看）</p><p>废话连篇:首先进入 BeginWork 的三个参数分别为 <code>current, workInProgress, renderLanes</code>。因为是首次运行，所以 current 的 Tag 为<code>3</code>，代表<code>HostRoot</code>，然后恢复脚本执行。又到了 BeginWork 的断点处，这时<code>current</code>为空,<code>workInProgress</code>的 ElementType 为<code>f APP()</code>。再放开<code>workInProgress</code>又变成<code>div</code>。再放开是<code>header</code>,然后再放开是<code>img</code>，这时候因为 img 没有任何子节点，所以再放开后到了 completeWork，执行完后，会再寻找 img 的兄弟节点，然后找到了 P 标签，进入<code>beginWork</code>，再找 P 的子节点，先<code>Edit </code>begin 再 completed，接着是<code>Code</code>，因为 Code 内的子节点是纯文本，所以直接采用优化方案，不会找子节点，直接进入<code>completeWork</code>,然后再是最后的文本<code>and save to reload.</code>，执行完后进入父节点的<code>completeWork</code>。</p><p>总结：根 beginWork-&gt;子节点 beginWork-如果有子节点-&gt;一直直行到最后一个子节点时，执行父节点的 completeWork; -如果子节点没有子节点-&gt;执行自己的 completeWork-&gt;然后找到兄弟元素。(深度优先遍历，遇到有唯一文本节点的，不会创建他的 Fiber 节点)</p><p>专业总结:首先从<code>rootFiber</code>开始向下深度优先遍历,为遍历到的每个 Fiber 节点调用<code>beginWork</code>方法。当遍历到没有子组件的组件时就会进入“归”阶段。在归阶段调用<code>completeWork</code>,当某个 Fiber 节点执行完<code>completeWork</code>，如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。</p><p><a href="https://react.iamkasong.com/process/reconciler.html#%E4%BE%8B%E5%AD%90">卡颂老师的 DEMO</a></p><p>为什么 EffectTag 是用二进制？ 因为如果要插入一个元素到页面中，然后还要替换他的属性，那就要标记成 Update 和 Placement。用二进制可以很快的进行标记。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> NoFlags = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b00000000000000000000000</span>;<br><br><span class="hljs-keyword">const</span> Placement = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b00000000000000000000010</span>;<br><br><span class="hljs-keyword">const</span> Update = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b00000000000000000000100</span>;<br><br><span class="hljs-keyword">const</span> PlacementAndUpdate = <span class="hljs-comment">/*           */</span> Placement | Update;<br><br><span class="hljs-comment">// 首先有个元素,初始状态为没变化</span><br><span class="hljs-keyword">let</span> effectTag = NoFlags;<br><br><span class="hljs-comment">// 先插入，按位或</span><br>effectTag |= Placement; <span class="hljs-comment">//2 === 0b00000000000000000000010</span><br><span class="hljs-comment">// 然后更新</span><br>effectTag |= Update; <span class="hljs-comment">// 6 === 0b00000000000000000000110</span><br><br>(effectTag &amp; PlacementAndUpdate) !== NoFlags; <span class="hljs-comment">//True</span><br></code></pre></div></td></tr></table></figure><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>beginWork：当一个节点进入 beginWork 时，目的是为了创建当前 Fiber 节点的第一个子 Fiber 节点，判断当前 Fiber 节点的类型，进入不同的 Update 逻辑。在进入 Update 逻辑后，会先判断 WorkInProgress Fiber 中是否有对应的 Current Fiber，来决定是否标记 EffectTag（在 17.0.3 中更名为 ReactFiberFlags），接着判断当前 Fiber 节点的 child 的类型，来执行不同的创建操作，创建不同的子 Fiber 节点。</p><p>completeWork：根据 WorkInProgress 的 tag，进入不同操作。首先为 Fiber 节点创建对应的 DOM 节点， 然后挂到 Fiber 节点的 StateNode （已经构建好的 DOM 树）上。然后将 DOM 节点插入到之前创建好的 DOM 树中，然后初始化 DOM 对象的属性。</p><p><img src="https://react.iamkasong.com/img/beginWork.png" alt="beginWork"><br><img src="https://react.iamkasong.com/img/completeWork.png" alt="completeWork"></p><h3 id="更新时-1"><a href="#更新时-1" class="headerlink" title="更新时"></a>更新时</h3><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>beginWork：先判断是否可以复用，如果可以复用直接 Clone 在 current 中对应的 Fiber 节点。如果不能复用，判断当前 Fiber 节点的类型，进入不同的 Update 逻辑，在这里面会使用 JSX 对象与 current Fiber 节点进行对比，将对比的结果创建一个 fiber 节点并返回。</p><p>completeWork：先 diff props，返回一个需要更新的属性名称构成的数组（[key1，value1,key2,value2…]）然后赋值给 workInpProgress.updateQueue，最后再将 effectTag 的 fiber 挂载在父级 fiber 的 effectList 末尾，并返回 workInProgress Fiber 树。</p><p>作为 DOM 操作的依据，commit 阶段需要找到所有有 effectTag 的 Fiber 节点并依次执行 effectTag 对应操作？</p><p>每个执行完 completeWork 且存在 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。effectList 中第一个 Fiber 节点保存在 fiber.firstEffect，最后一个元素保存在 fiber.lastEffect。类似 appendAllChildren，在“归”阶段，所有有 effectTag 的 Fiber 节点都会被追加在 effectList 中，最终形成一条以 rootFiber.firstEffect 为起点的单向链表。这样，在 commit 阶段只需要遍历 effectList 就能执行所有 effect 了。</p><ul><li>注意：近期 React 团队有在重构 Effect List（v18），老的会生成 Effect List，然后在 commit 阶段，直接遍历 EffectList 就能找到所有副作用的节点并执行对应的操作。在重构会会将子节点的副作用冒泡到父节点的 SubtreeFlags 属性。详细可见卡老师的另外一篇文章<a href="https://mp.weixin.qq.com/s/-UNN45YttXJPA2TlrnSy3Q">React Effects List 大重构，是为了他？</a></li></ul><h2 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/image-hosting-service@main/2021/12/05/20211205130037.png" alt="2021/12/05/20211205130037"><br>主要工作分为三部分：</p><ul><li><p>before mutation 阶段（执行 DOM 操作前）</p></li><li><p>mutation 阶段（执行 DOM 操作）</p></li><li><p>layout 阶段（执行 DOM 操作后）</p></li></ul><h3 id="beforeMutation-阶段"><a href="#beforeMutation-阶段" class="headerlink" title="beforeMutation 阶段"></a>beforeMutation 阶段</h3><ol><li><p>遍历 effectList 并调用<code>commitBeforeMutationEffects</code>函数处理</p></li><li><p>commitBeforeMutationEffects 处理有三步</p><ol><li><p>处理 DOM 节点渲染/删除后 focus 和 blur 逻辑</p></li><li><p>如果是类组件会调用<code>getSnapshotBeforeUpdate</code>生命周期：通过<code>finishedWork.stateNode</code>取得对应 Fiber 节点的原型。如果是函数组件会直接 return 出去。</p></li><li><p>调度<code>useEffect</code>：如果是函数组件，并且他的<code>useEffect</code>被标记为<code>Passive</code> 会在这调度。以 NormalSchedulerPriority 为优先级，异步执行<code>flushPassiveEffects</code>（也就是<code>useEffect</code>的回调函数），由于<code>commit</code>阶段是同步执行的，所以<code>useEffect</code>的回调函数是在 commit 阶段执行完执行的。</p></li></ol></li></ol><h3 id="mutation-阶段"><a href="#mutation-阶段" class="headerlink" title="mutation 阶段"></a>mutation 阶段</h3><ol><li><p>遍历 effectList，并调用<code>commitMutationEffects</code></p></li><li><p><code>commitMutationEffects</code>会遍历 effectList，对每个 Fiber 节点执行如下三个操作：</p><ol><li><p>根据 ContentReset effectTag 重置文字节点</p></li><li><p>更新 ref（对应生命周期图中的 更新 DOM 和 refs）</p></li><li><p>根据 effectTag 分别处理，其中 effectTag 包括（Placement | Update | Deletion | Hydrating）</p></li></ol></li></ol><h4 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h4><p>当 Fiber 节点含有 Placement effectTag，意味着该 Fiber 节点对应的 DOM 节点需要插入到页面中。调用 commitPlacement</p><ol><li><p>向上递归获取该 Fiber 节点的父级 Fiber 节点。</p></li><li><p>根据 fiber 节点找到对应的 DOM 节点（通过 fiber 节点上的 stateNode 属性），然后根据 Fiber 的 Tag 判断是不是 container（HostRoot 和 HostPortal 标记为 true，HostComponent 和 FundamentalComponent 标记为 false）</p></li><li><p>获取该 Fiber 节点的兄弟 DOM。</p></li><li><p>根据 DOM 兄弟节点存在决定调用<code>insertBefore</code> 或<code>appendChild</code>执行 DOM 插入操作</p></li></ol><ul><li>getHostSibling（获取兄弟 DOM 节点）的执行很耗时，当在同一个父 Fiber 节点下依次执行多个插入操作，getHostSibling 算法的复杂度为指数级。</li></ul><p>这是由于 Fiber 节点不只包括 HostComponent，所以 Fiber 树和渲染的 DOM 树节点并不是一一对应的。要从 Fiber 节点找到 DOM 节点很可能跨层级遍历。</p><h4 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h4><p>当 Fiber 节点含有 Update effectTag，意味着该 Fiber 节点需要更新。调用的方法为 commitWork，他会根据 Fiber.tag 分别处理。</p><p>当 fiber.tag 为 FunctionComponent，会调用 commitHookEffectListUnMount。该方法会遍历 effectList，执行所有 useLayoutEffect hook 的销毁函数。</p><p>当 fiber.tag 为 HostComponent，会调用 commitUpdate，更新 Props 和 DOM 的属性。最终会在 updateDOMProperties 中将 render 阶段 completeWork 中为 Fiber 节点赋值的 updateQueue 对应的内容（diff 的结果）渲染在页面上。</p><h4 id="PlacementAndUpdate-effect"><a href="#PlacementAndUpdate-effect" class="headerlink" title="PlacementAndUpdate effect"></a>PlacementAndUpdate effect</h4><p>先执行 placement effect 的内容，再执行 Update effect 的内容</p><h4 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h4><p>当 Fiber 节点含有 Deletion effectTag，意味着该 Fiber 节点对应的 DOM 节点需要从页面中删除。调用的方法为 commitDeletion。</p><ol><li><p>如果是<code>HostComponent</code>或<code>HostText</code>,递归查找的，首先找到它的父级 Fiber 节点，然后在找到它的子孙节点（因为这个整体相当于一个树，消除一个节点，他的下级也要被销毁）。然后调用<code>commitUnmount</code>。</p></li><li><p>如果是函数组件及其相似的，遍历 effectList，进行注册 useEffect 的回调（将 fiber 节点和 effect 的回调放到一个 unmountEffects 队列中）进行调度。</p></li><li><p>如果是类组件，会解绑 Ref，然后调用生命周期中的 componentWillUnmount</p></li><li><p>如果是 <code>HostComponent</code>，会解绑 Ref</p></li></ol><h3 id="mutation-阶段之后-Layout-阶段之前"><a href="#mutation-阶段之后-Layout-阶段之前" class="headerlink" title="mutation 阶段之后 Layout 阶段之前"></a>mutation 阶段之后 Layout 阶段之前</h3><p>在这里会执行双缓存的原理，将 current 指针从 current 树，指向 workInProgress 树。</p><p>为什么在这里执行？</p><p>简单说就是为了确保每个阶段的树能对应上。</p><p>因为 mutation 阶段时需要执行 componentWillUnmount，需要操作 current 树，而 layout 阶段要执行 componentDidMount/Update，需要跟新的 current 树对应上</p><p>卡老师总结版：componentWillUnmount 会在 mutation 阶段执行，此时 current Fiber 树还指向前一次更新的 Fiber 树，在生命周期钩子内获取的 DOM 还是更新前的。componentDidMount 和 componentDidUpdate 会在 layout 阶段执行。此时 current Fiber 树已经指向更新后的 Fiber 树，在生命周期钩子内获取的 DOM 就是更新后的。</p><h3 id="Layout-阶段"><a href="#Layout-阶段" class="headerlink" title="Layout 阶段"></a>Layout 阶段</h3><p>Layout 阶段也是遍历 effectList，执行 commitLayoutEffects 方法。</p><ol><li><p>如果是函数组件会执行<code>useLayoutEffect</code>，如果是类组件会根据 current 有无来判断执行<code>componentDidMount</code>还是<code>componentDidUpdate</code>，并且还会生成会取一个<code>updateQueue</code>，这里存放的其实是 setState 的第二个参数，依赖于未更新前的 dom 属性来操作，也是在这调用的。如果<code>HostRoot</code>，也会有一个<code>updateQueue</code>，存放的是 render 的第三个参数。</p></li><li><p>hostComponent 或 class Component 存在 Ref 时，处理 Ref。</p></li></ol><h4 id="UseEffect-和-UseLayoutEffect-区别"><a href="#UseEffect-和-UseLayoutEffect-区别" class="headerlink" title="UseEffect 和 UseLayoutEffect 区别"></a>UseEffect 和 UseLayoutEffect 区别</h4><table><thead><tr><th align="center"></th><th align="center">useEffect</th><th align="center">useLayoutEffect</th></tr></thead><tbody><tr><td align="center">beforeMutation</td><td align="center">调度 flushPassiveEffects</td><td align="center">无</td></tr><tr><td align="center">mutation</td><td align="center">无</td><td align="center">执行 destroy</td></tr><tr><td align="center">layout</td><td align="center">注册 destroy 和 create</td><td align="center">执行 create</td></tr><tr><td align="center">commit 阶段完成后</td><td align="center">执行 flushPassiveEffects，内部执行注册的回调</td><td align="center">无</td></tr></tbody></table><h3 id="useEffect-的异步调用"><a href="#useEffect-的异步调用" class="headerlink" title="useEffect 的异步调用"></a>useEffect 的异步调用</h3><ol><li><p><code>before mutation</code>阶段在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code>（对应的本文<code>beforeMutation</code>阶段的第三步）</p></li><li><p><code>layout</code> 阶段之后将 <code>effectList</code> 赋值给 <code>rootWithPendingPassiveEffects</code></p></li><li><p><code>scheduleCallback</code> 触发 <code>flushPassiveEffects</code>， <code>flushPassiveEffects</code> 内部遍历 <code>rootWithPendingPassiveEffects</code></p></li></ol><h4 id="为什么需要异步调用useEffect？"><a href="#为什么需要异步调用useEffect？" class="headerlink" title="为什么需要异步调用useEffect？"></a>为什么需要异步调用<code>useEffect</code>？</h4><blockquote><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p></blockquote><p>所以<code>useEffect</code>主要是防止同步执行时阻塞浏览器渲染。</p><h2 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h2><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/image-hosting-service@main/2021/12/05/20211205222940.png" alt="2021/12/05/20211205222940"></p><p>与 DOM 节点有关的概念：</p><ol><li><p>current Fiber。如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点</p></li><li><p>workInProgress Fiber。如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点。</p></li><li><p>DOM 节点本身。</p></li><li><p>JSX 对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息。</p></li></ol><p>diff 的本质就是比较 1 和 4，然后生产 2。</p><p>为了降低时间复杂度，React 的 diff 算法有三个限制</p><ol><li><p>只比较同级的元素。如果前后两次中某节点跨级了，那么 React 不会复用。</p></li><li><p>只比较相同类型的节点。如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。</p></li><li><p>开发者通过 key 来保持稳定。</p></li></ol><h3 id="diff-如何实现？"><a href="#diff-如何实现？" class="headerlink" title="diff 如何实现？"></a>diff 如何实现？</h3><p><code>reconcileChildFibers</code>函数会根据 newChild（即 JSX 对象）类型调用不同的处理函数。</p><ol><li><p>当 newChild 类型为 object、number、string，代表同级只有一个节点</p></li><li><p>当 newChild 类型为 Array，同级有多个节点</p></li></ol><h4 id="单节点时"><a href="#单节点时" class="headerlink" title="单节点时"></a>单节点时</h4><ul><li><p>如果 currentFiber 树中存在对应的节点并遍历。</p><ul><li><p>如果 key 相同，type 相同，标记它的兄弟节点为 Deletion。再复用老的 Fiber，然后 return 出去</p></li><li><p>如果 key 相同，type 不同，先标记它及其兄弟为 Deletion，跳出循环，再根据 JSX 对象创建一个新的 Fiber 节点</p></li></ul></li><li><p>如果 currentFiber 树中不存在对应的节点，直接根据 JSX 对象创建一个新 Fiber 节点。</p></li></ul><p>卡老师总结版：</p><p>上次更新时的 fiber 节点是否存在相应的 DOM 节点，如果不存在，则新生成一个 Fiber 节点，如果存在则判断该节点是否可以复用，如果不能复用则标记 DOM 需要被删除，然后生成一个新 Fiber 节点。如果可以复用，则将上次更新的 Fiber 节点的副本作为本次新生成的 Fiber 节点并返回。</p><ul><li>如何判断 DOM 节点是否可以复用？</li></ul><p>React 通过先判断 key 是否相同，如果 key 相同则判断 type 是否相同，只有都相同时一个 DOM 节点才能复用。key 相同且 type 不同时执行 deleteRemainingChildren 将 child 及其兄弟 fiber 都标记删除。key 不同时仅将 child 标记删除。</p><h4 id="多节点时"><a href="#多节点时" class="headerlink" title="多节点时"></a>多节点时</h4><p>有两种情况（一个 ul 下面有多个 li；一个 ul 下面多个 li 是使用 map 出来的），其实流程是一样的。</p><p>注意：提到的老 Fiber 树其实是本层中兄弟节点构成的链表。</p><p>注意： 因为层级比较深，可能markdown解析出来的不太方便看，请结合该章节头部的图来看。</p><ol><li><p>同时遍历新 jsx 对象数组，老 Fiber 树。</p><ol><li>复用判断<ul><li>如果key相同且type（就是标签相同）相同，复用之前的Fiber，并返回。</li><li>如果key相同且type不同，根据jsx对象创建新Fiber并返回。</li><li>如果key不同，返回null，并跳出循环。</li></ul></li><li>将老的 Fiber 标为 deletion</li><li>将新的 Fiber 节点标为 placement，并记录最后一个可复用的节点在老 Fiber 树中的位置索引。<ol><li>记录新 Fiber 的位置（即在 jsx 对象数组中的索引）</li><li>判断新Fiber是否为复用的<ul><li>是<ol><li>拿到老Fiber节点的位置</li><li>如果老位置小于新位置（表示新Fiber节点右移了），则新的Fiber节点被标记为placement，并返回最后一个可复用的节点在老Fiber树中的位置索引。</li><li>如果老位置大于等于新位置，则直接返回老位置（不会标记为placement）</li><li>注：老位置大于新位置表示要由老位置左移得到新位置，但是React中仅进行右移操作，前面的元素右移后，自己自然被顶到前面去了，实现了左移的效果，相当于变相实现了左移。（关于在React中仅进行右移操作请看<a href="https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/190.%E7%B2%BE%E8%AF%BB%E3%80%8ADOM%20diff%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E3%80%8B.md">精读《DOM diff 原理详解》</a>）</li></ol></li><li>否，直接标记为placement</li></ul></li></ol></li></ol></li><li><p>如果新 jsx 对象数组遍历完了（即删除节点了），标记没有遍历过的老 Fiber 节点为deletion，然后返回一棵新树（即 workInProgress Fiber 树）</p></li><li><p>如果老 Fiber 树遍历完了且新 jsx 对象数组没遍历完（即新增节点了），遍历剩下的 jsx 对象数组。</p><ol><li>创建新 Fiber 节点</li><li>将新的 Fiber 节点标为 placement，并记录最后一个可复用的节点在老 Fiber 树中的位置索引。</li><li>插入到新 Fiber 树中</li><li>返回 workInProgress Fiber 树。</li></ol></li><li><p>如果 jsx 对象数组没遍历完且老 Fiber 树也没遍历完（即没增没减）</p><ol><li>新建一个以老 Fiber 节点的 key 或者 index 为索引，老 Fiber 节点为 value 的 map</li><li> 遍历 jsx 对象数组，根据 jsx 对象的 key 或者 index 为索引，在 map 中找老 Fiber 节点</li><li>如果老 Fiber 节点和 jsx 对象的 type 相同，则复用并返回新 Fiber 节点，如果不相同，则返回 null</li><li>如果返回的新 Fiber 节点不为 null，则将新的 Fiber 节点标记为 placement 并记录位置，然后插入到新的 Fiber 树中</li><li>如果 map 中还有剩余，就将剩下的全都标记为Deletion</li></ol></li><li><p>返回 workInProgress Fiber 树。</p></li></ol><h5 id="卡老师总结版"><a href="#卡老师总结版" class="headerlink" title="卡老师总结版"></a>卡老师总结版</h5><p>会进行两轮遍历。第一轮遍历处理更新的元素。第二轮遍历处理不属于更新的节点。</p><ul><li>为什么不用双指针优化？</li></ul><p>因为同级的 Fiber 节点间是用 sibling 指针连接形成的单链表。</p><p>第一轮遍历的过程：</p><ol><li><p><code>let i = 0</code>，遍历<code>newChildren</code>，将<code>newChildren[i]</code>与<code>oldFiber</code>比较，判断 DOM 节点是否可复用。</p></li><li><p>如果可复用，i++，继续比较<code>newChildren[i]</code>与<code>oldFiber.sibling</code>，可以复用则继续遍历。</p></li><li><p>如果不可复用，分两种情况：</p><ul><li><p>key 不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</p></li><li><p>key 相同 type 不同导致不可复用，会将 oldFiber 标记为 DELETION，并继续遍历</p></li></ul></li><li><p>如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，第一轮遍历结束。</p></li></ol><p>第一轮遍历结束有两种结果：</p><p>第一种从 3 跳出来的：<code>newChildren</code>没遍历完<code>oldFiber</code>没遍历完</p><p>第二种从 4 跳出来的：<code>newChildren</code>没遍历完<code>oldFiber</code>遍历完（相当于有新增），<code>oldFiber</code>没遍历完<code>newChildren</code>遍历完（相当于有删减），<code>newChildren</code>和<code>oldFiber</code>都遍历完（相当于没增没减）</p><p>带着上面的结果进行第二轮遍历</p><p>如果<code>newChildren</code>和<code>oldFiber</code>都遍历完，最理想情况，只在第一轮遍历进行更新。Diff 结束。</p><p>如果<code>newChildren</code>没遍历完<code>oldFiber</code>遍历完，有新节点插入，遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。</p><p>如果<code>oldFiber</code>没遍历完<code>newChildren</code>遍历完，有节点被删了，遍历剩下的<code>oldFiber</code>，一次标记<code>Deletion</code></p><p>如果<code>newChildren</code>没遍历完<code>oldFiber</code>没遍历完，有节点变换了位置。将所有没处理的<code>oldFiber</code>存入以<code>key</code>为 key，<code>oldFiber</code>为 value 的 map 中。然后遍历剩余的<code>newChildren</code>，通过<code>newChildren[i].key</code>就能在<code>existingChildren</code>中找到 key 相同的 oldFiber。先标记最后一个可复用节点的位置，然后保存老节点的位置。两个位置信息比较。如果老位置&lt;最后一个可复用节点的位置，则 该节点 向右移动。如果老位置&gt;=最后一个可复用节点的位置，则该节点不动，然后可复用节点的位置变更为该老位置。</p><p>例子</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">abcd-&gt;adbc（key和value都为表示的这个）<br><br>在第一轮遍历的时候保存得到，a是最后可复用节点,用lastChangeIndex保存改位置:<span class="hljs-number">0</span>。剩余的<span class="hljs-attr">newChildren</span> = dbc , 剩余的<span class="hljs-attr">oldFiber=</span> bcd。<br>遍历剩余的newChildren，第一个为d，key也是d。在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">3</span>。 因为oldIndex(<span class="hljs-number">3</span>)&gt;=lastChangeIndex(<span class="hljs-number">0</span>)，则该点不动，将<span class="hljs-attr">lasChangeIndex</span> = <span class="hljs-number">3</span>。<br>剩余的<span class="hljs-attr">newChildren</span> = bc , 剩余的<span class="hljs-attr">oldFiber=</span> bc。第二个为b，在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">1</span>。因为oldIndex(<span class="hljs-number">1</span>)&lt;lastChangeIndex(<span class="hljs-number">3</span>)，所以将该点右移。<br>剩余的<span class="hljs-attr">newChildren</span> = c , 剩余的<span class="hljs-attr">oldFiber=</span> c。最后一个为c，在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">2</span>。oldIndex(<span class="hljs-number">2</span>)&lt;lastChangeIndex(<span class="hljs-number">3</span>)，所以将该点右移。<br></code></pre></div></td></tr></table></figure><h2 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h2><h3 id="触发更新的方法"><a href="#触发更新的方法" class="headerlink" title="触发更新的方法"></a>触发更新的方法</h3><ul><li><p>ReactDOM.render</p></li><li><p>this.setState</p></li><li><p>this.forceUpdate</p></li><li><p>useState</p></li><li><p>useReducer</p></li></ul><p>这么多方法如何接入同一种更新机制？</p><p>在各自的处理方法里处理出来一个通用的update对象，通过这个update对象进入统一的更新流程</p><h3 id="流程大纲"><a href="#流程大纲" class="headerlink" title="流程大纲"></a>流程大纲</h3><ol start="0"><li><p>触发状态更新（根据场景调用不同方法）</p></li><li><p>创建update对象</p></li><li><p>从触发状态更新的<code>fiber</code>一直向上遍历到<code>rootFiber</code>。</p></li><li><p>调度更新</p></li><li><p>render阶段</p></li><li><p>commit阶段</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>源码学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在React中因浅拷贝引发的BUG</title>
    <link href="/article/db2c0d0e/"/>
    <url>/article/db2c0d0e/</url>
    
    <content type="html"><![CDATA[<p>今天在开发过程中遇到一个 BUG：useEffect 没有按照想象中的执行。所以有了本篇文章。</p><p>需求如下：有个列表，列表项中的<code>content</code>字段如果内容大于 3 行，则仅显示三行，并有个展开的按钮。</p><p>现象：通过接口拉回来的数据，如果本来就大于三行，会显示展开的按钮。当点击列表内的项时，呼出原生 APP 的修改页面，修改内容后，调用我准备好的方法，来进行数据更新。如果原来的内容小于三行，修改到三行以上的时候不会被收起，也不会有展开按钮。</p><p>分析：模拟这种行为的<a href="https://codesandbox.io/s/admiring-bose-28noo">代码</a></p><p>当我们点击的时候发现，仅有初次渲染时 useEffect 的输出，并没有我点击更改后的输出，但是他的内容却变了。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210721/firstAfterClick.png" alt="第一次点击"></p><p>开始我胸有成竹的认为因为在更新的时候进行的是浅比较，所以没触发更新流程。（现在冷静下来想下，没触发更新流程数据怎么会更新呢 23333333）</p><p>然后我就非常潇洒的在<code>Card</code>这层包裹了<code>React.memo</code>,如代码中注释的那样，让他进行个自定义比较去，然后触发更新流程。</p><p>再次点击按钮后，发现视图居然没更新！！！，并且神奇的是<code>prevProps</code>和<code>nextProps</code>竟然都是最新的。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210721/secondClick.png" alt="第二次点击">。</p><p>百思不得其解，为什么会这样。</p><p>在经过搜索后发现<a href="https://github.com/facebook/react/issues/16643">github</a>这条 issues。</p><p>然后将在进行操作的地方对数据进行了深拷贝，就能顺利触发 useEffect 了。</p><p>问题解决了。但是这是为什么呢？为什么深拷贝再操作就能解决问题呢？</p><p>看图：</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210721/wrongProps.png" alt="有问题的情况"></p><p>因为在 newList 里存的还是老地址。当对老地址的数据进行修改的时候，<code>prevProps</code>取到的也就是最新的值了。</p><p>所以在对 newList 内的数组项进行复制的时候要进行深拷贝，让他们不再指向老地址，这样就不会互相影响了。</p><p>解决方案：</p><p>一：深拷贝</p><p>二：数据结构优化，使用扁平化处理。充分利用 React 中默认的浅比较。可以采用 Immutable 等库进行数据处理。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深拷贝/浅拷贝</tag>
      
      <tag>数据结构</tag>
      
      <tag>React.Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(随手记录)-GIT解决合并错分支</title>
    <link href="/article/afdedcbf/"/>
    <url>/article/afdedcbf/</url>
    
    <content type="html"><![CDATA[<p>今天在进行大版本升级完，将版本分支归档到 main 分支的时候，发现 commits 特别多，一共有 2000 多条。</p><p>感觉不太对劲，第一反应就是有人把 dev 分支合并进了某个功能分支，然后在从功能分支合并到版本分支的时候没有仔细看。（因为在上一家公司就遇到过一次。。。）</p><p>然后抓紧打开 Graph（VSCode 也有插件）看一下路径。</p><p>发现果然如我所料。</p><p>那其实是需要仅仅将这个 merge 的请求回滚的。方法很多。</p><ol><li><p>最简单粗暴的：先使用 <code>git reflog</code>看一下操作，找到 merge 时的 Head，直接把头重新定到 merge 前一个就可以。</p></li><li><p>还可以使用 rebase git rebase -i merge 操作前的 commitID.然后在信息里面把 merge 进来的信息前缀从 pick 改为 drop</p></li><li><p>revert 反作</p></li></ol><p>在合并错的分支我们本意是没有 dev 分支里的内容的。也就是没有 dev 这个文件,并且 main 文件内同时保留合并后的修改内容。</p><p>直接<code>git revert merge的commitId -m 1/2</code> 。</p><p>这个 1 和 2 代表主分支是谁。</p><p>可以通过<code>git show merge的commitId查看parent</code>。</p><p>如果要以 parent 的第一个为基准就输入 <code>-m 1</code> 如果是第二个就是<code>-m 2</code></p><p>然后处理一下冲突就可以了。</p><p>一句话总结： revert 就是将对应 commitId 的操作反向操作一遍。</p><p>更详细的可以查看<a href="https://www.cnblogs.com/bescheiden/articles/10563651.html">Git 之 revert</a> 和 <a href="https://www.dazhuanlan.com/2019/11/15/5dcdd42820309/">Git 撤销某次 merge 的正确实现方法</a></p>]]></content>
    
    
    <categories>
      
      <category>随手记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GIT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(随手记录)-一些关于BOM的零散知识</title>
    <link href="/article/668e3aae/"/>
    <url>/article/668e3aae/</url>
    
    <content type="html"><![CDATA[<h2 id="用-setTimeout-实现一个-setInterval"><a href="#用-setTimeout-实现一个-setInterval" class="headerlink" title="用 setTimeout 实现一个 setInterval"></a>用 setTimeout 实现一个 setInterval</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> run = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// DoSomethings</span><br>  run();<br>&#125;, <span class="hljs-number">3000</span>);<br></code></pre></div></td></tr></table></figure><p>这种实现的方式与 setInterval 的区别：setInterval 不关心方法是否还在运行；setTimeout 实现的一定是在有了结果之后才继续执行第二次的。</p><h2 id="封装个支持超时的-fetch-方法"><a href="#封装个支持超时的-fetch-方法" class="headerlink" title="封装个支持超时的 fetch 方法"></a>封装个支持超时的 fetch 方法</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchWithTimeout = <span class="hljs-function">(<span class="hljs-params">url, init, timeout = <span class="hljs-number">3000</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fetch(url, init).then(resolve).catch(reject);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      reject(<span class="hljs-string">&quot;超时了&quot;</span>);<br>    &#125;, timeout);<br>  &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>利用 Promise 的特性：只能从 Pending 到 Fulfilled 或只能从 Pending 到 Rejected。</p><p>同理可以封装个通用的异步函数超时逻辑;</p><h2 id="fetch-的中断"><a href="#fetch-的中断" class="headerlink" title="fetch 的中断"></a>fetch 的中断</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controller =  <span class="hljs-keyword">new</span> AbortController();<br><br><br>fetch(url,&#123;<br>  <span class="hljs-attr">signal</span>:controller.signal;<br>&#125;)<br><br><br>controller.abort();<br></code></pre></div></td></tr></table></figure><h2 id="为什么-cdn-域名与业务域名不相同？"><a href="#为什么-cdn-域名与业务域名不相同？" class="headerlink" title="为什么 cdn 域名与业务域名不相同？"></a>为什么 cdn 域名与业务域名不相同？</h2><ol><li><p>安全问题：cookie 中存着的多为用户身份信息，如果是同域名的话会携带着 cookie 一起去请求资源，会造成信息泄漏。</p></li><li><p>节省带宽：不会带 cookie</p></li><li><p>并发请求数：HTTP/1.1 会限制同域请求只能有 6 个，会阻塞业务的请求。</p></li></ol><h2 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ul><li><p>Expires：设置过期时间，弊端：可能存在客户端时间跟服务端时间不一致的问题。</p></li><li><p>max-age</p></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><ul><li><p>Last-Modified + If-Modified-Since ：弊端同 Expires</p></li><li><p>ETag + If-None-Match：弊端：因为需要针对文件生成唯一标识，会影响性能。</p></li></ul><h4 id="如果是-SPA-页面的-HTML-用什么缓存？"><a href="#如果是-SPA-页面的-HTML-用什么缓存？" class="headerlink" title="如果是 SPA 页面的 HTML 用什么缓存？"></a>如果是 SPA 页面的 HTML 用什么缓存？</h4><ul><li><p>最好不缓存。因为内容中引用的 js 和 css 都带 hash，html 内容会频繁变更，如果用强缓存会导致更新不及时。</p></li><li><p>可以采用协商缓存，每次打包出来的 html 内容都会变更。</p></li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第三个参数代表监听阶段，true为捕获阶段，false/默认为冒泡阶段。IE只有冒泡。</span><br>element.addEventListener(type, callBack, option);<br></code></pre></div></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>优点：节省内存，减少注册事件。<br>原理：利用事件冒泡.</p><p>完整代码见:<a href="https://github.com/AruSeito/daily-practice/blob/main/others/BomEvent/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/index.html">事件委托</a></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML结构如下 ul&gt;li*7</span><br><br><span class="hljs-keyword">const</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;ul&quot;</span>);<br><br>ul.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> target = e.target;<br>  <span class="hljs-keyword">const</span> liNodeList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;li&quot;</span>);<br>  <span class="hljs-keyword">if</span> (target.tagName.toLowerCase() === <span class="hljs-string">&quot;li&quot;</span>) &#123;<br>    <span class="hljs-keyword">const</span> liList = <span class="hljs-built_in">Array</span>.from(liNodeList);<br>    <span class="hljs-keyword">const</span> index = liList.indexOf(target);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`index=<span class="hljs-subst">$&#123;index&#125;</span>`</span>);<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="阻止事件传播"><a href="#阻止事件传播" class="headerlink" title="阻止事件传播"></a>阻止事件传播</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">e.stopPropagation();<br></code></pre></div></td></tr></table></figure><h3 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h3><p>一个页面有很多的元素，每个元素都有属于自己的 click 事件。如果一个用户进入页面，会有一个 banned 的属性。如果为 true 则用户无论点击页面的哪里都不会触发之前的点击事件，只能触发弹窗提醒被封禁了.如果为 false，则按照之前的执行就可以。</p><h4 id="方案一：建一个最高层的透明遮罩层。点击就弹。"><a href="#方案一：建一个最高层的透明遮罩层。点击就弹。" class="headerlink" title="方案一：建一个最高层的透明遮罩层。点击就弹。"></a>方案一：建一个最高层的透明遮罩层。点击就弹。</h4><h4 id="方案二：运用stopPropagation"><a href="#方案二：运用stopPropagation" class="headerlink" title="方案二：运用stopPropagation()"></a>方案二：运用<code>stopPropagation()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (banned) &#123;<br>    e.stopPropagation();<br>    alert(<span class="hljs-string">&quot;你被封禁了&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// OriganThings</span><br>&#125;);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随手记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手写一个Promise/A+</title>
    <link href="/article/ba852590/"/>
    <url>/article/ba852590/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>2021/07/04 更新日志： 手写一个符合 Promise/A+规范的 Promise<br>2021/07/05 更新日志： 完成 Promise.resolve(),Promise.reject(),Promise.race();</p>          </div><p>Promise 在日常开发中经常用到，使用频率相当的高了。为了能够更好的应用 Promise 需要对 Promise 进行一些更深的理解，所以尝试着按照 Promise/A+规范进行了一次手撕代码。</p><p>Promise/A+的内容就不细致展开描述一边了，直接开始手撕代码，将规范的内容分解开始进行实践。(具体原版描述请看 Promise/A+)</p><h2 id="手撕一个-Promise"><a href="#手撕一个-Promise" class="headerlink" title="手撕一个 Promise"></a>手撕一个 Promise</h2><p>Promise 有三个状态，两个过程，FULFILLED 有一个 value，REJECTED 有一个 reason</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 三个状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 两个过程来改变状态。并且状态只能从PENDING开始到FULFILLED/REJECTED结束。</span><br>  <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>      <span class="hljs-built_in">this</span>.status = FULFILLED;<br>      <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === PENDING) &#123;<br>      <span class="hljs-built_in">this</span>.status = REJECTED;<br>      <span class="hljs-built_in">this</span>.reason = reason;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在我们使用 Promise 的时，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// doSomethings</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>所以我们还需要在构造函数中传入一个函数,并且在初始化的时候传入的函数就已经执行了。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = PENDING;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 在初始化的时候执行传入的函数</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      fn(<span class="hljs-built_in">this</span>.resolve.bind(<span class="hljs-built_in">this</span>),<span class="hljs-built_in">this</span>.reject.bind(<span class="hljs-built_in">this</span>))<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>      <span class="hljs-built_in">this</span>.reject(e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>按照规范所说，then 方法接收两个参数 onFulfilled,onRejected.并且返回的是一个也是一个 Promise。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise();<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>onFulfilled/onRejected 必须是个函数，如果不是一个函数则要忽略它，但是我们在使用过程中可以</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// doSomethings</span><br>&#125;).then(<span class="hljs-number">11111</span>)<br></code></pre></div></td></tr></table></figure><p>这是因为传入非函数时，参数会被处理成函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ?onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise();<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后根据当前状态调用不同的函数</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          realOnFulfilled();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          realOnRejected();<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这时可能 status 还没变成终态，因此需要搞个监听，当 status 变成终态时在调用对应的回调。所以，如果这时是 pending 的时候，先将成功和失败的回掉分别存储。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  FULFILLED_CALLBACK_LIST = [];<br>  REJECTED_CALLBACK_LIST = [];<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          realOnFulfilled();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          realOnRejected();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>.FULFILLED_CALLBACK_LIST.push(realOnFulfilled);<br>          <span class="hljs-built_in">this</span>.REJECTED_CALLBACK_LIST.push(realOnRejected);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来在 status 变化的时候执行所有的回掉。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  FULFILLED_CALLBACK_LIST = [];<br>  REJECTED_CALLBACK_LIST = [];<br>  _status=PENDING;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">status</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._status;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">status</span>(<span class="hljs-params">newStatus</span>)&#123;<br>    <span class="hljs-built_in">this</span>._status = newStatus;<br>    <span class="hljs-keyword">switch</span>(newStatus)&#123;<br>      <span class="hljs-keyword">case</span> FULFILLED:<br>        <span class="hljs-built_in">this</span>.FULFILLED_CALLBACK_LIST.forEach(<span class="hljs-function"><span class="hljs-params">callback</span>=&gt;</span>&#123;<br>          callback(<span class="hljs-built_in">this</span>.value);<br>        &#125;)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> REJECTED:<br>        <span class="hljs-built_in">this</span>.REJECTED_CALLBACK_LIST.forEach(<span class="hljs-function"><span class="hljs-params">callback</span>=&gt;</span>&#123;<br>          callback(<span class="hljs-built_in">this</span>.reason);<br>        &#125;)<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          realOnFulfilled();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          realOnRejected();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>.FULFILLED_CALLBACK_LIST.push(realOnFulfilled);<br>          <span class="hljs-built_in">this</span>.REJECTED_CALLBACK_LIST.push(realOnRejected);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果 then 中的 onFulfilled/onRejected 抛出异常了，则 promise2 不能被执行并且返回 e</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> fulfilledMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          realOnFulfilled(<span class="hljs-built_in">this</span>.value);<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>          reject(e)<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> rejectedMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          realOnRejected(<span class="hljs-built_in">this</span>.reason);<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          fulfilledMicrotask();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          rejectedMicrotask();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>.FULFILLED_CALLBACK_LIST.push(fulfilledMicrotask);<br>          <span class="hljs-built_in">this</span>.REJECTED_CALLBACK_LIST.push(rejectedMicrotask);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果 onFulfilled/onRejected 返回值是 X，那么运行 resolvePromise</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">isFunction</span>(<span class="hljs-params">param</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> param === <span class="hljs-string">&quot;function&quot;</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> fulfilledMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> x = realOnFulfilled(<span class="hljs-built_in">this</span>.value);<br>          <span class="hljs-built_in">this</span>.resolvePromise(promise2,x,resolve,reject)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>          reject(e)<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> rejectedMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> x = realOnRejected(<span class="hljs-built_in">this</span>.reason);<br>          <span class="hljs-built_in">this</span>.resolvePromise(promise2,x,resolve,reject)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-built_in">this</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          fulfilledMicrotask();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          rejectedMicrotask();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>.FULFILLED_CALLBACK_LIST.push(fulfilledMicrotask);<br>          <span class="hljs-built_in">this</span>.REJECTED_CALLBACK_LIST.push(rejectedMicrotask);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>接下来完成 resolvePromise 方法。</p><p>根据规范，如果 resolvePromise 中 promise2 和 x 是全等，则用 TypeError 作为 reject 的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">//省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2,x,resolve,reject</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(promise2 === x)&#123;<br>      <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;promise2和x不能相同&quot;</span>))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果 x 是一个 promise，则采用它的状态。<br>如果 x 是一个对象或者函数，让 then=x.then，如果此时抛出异常 e，则使用 e 作为 reject 参数。<br>如果 then 是一个函数，用 x 调用(call)它，第一个参数是 resolvePromise，第二个参数是 rejectPromise。如果同时调用 resolvePromise 和 rejectPromise，或者多次调用同一个参数，保证第一个被调用的有效，后续的调用将被忽略。如果 then 不是一个函数，则用 resolve(x)。<br>如果 x 不是一个对象或函数，则用 resolve(x)。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">//省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2,x,resolve,reject</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(promise2 === x)&#123;<br>      <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;promise2和x不能相同&quot;</span>))<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 x 是一个 promise，则采用它的状态。</span><br>    <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> MyPromise)&#123;<br>      queueMicrotask(<span class="hljs-function">()=&gt;</span>&#123;<br>        x.then(<span class="hljs-function">(<span class="hljs-params">y</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.resolvePromise(promise2,y,resolve,reject);<br>        &#125;,reject)<br>      &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 如果 x 是一个对象或函数</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.isObject(x) || <span class="hljs-built_in">this</span>.isFunction(x))&#123;<br>      <span class="hljs-comment">// typeof null会认为null为object,则使用x直接resolve</span><br>      <span class="hljs-keyword">if</span>(x === <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> resolve(x);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果 x 是一个对象或者函数，让 then=x.then，如果此时抛出异常 e，则使用 e 作为 reject 参数。</span><br>      <span class="hljs-keyword">let</span> then = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span>&#123;<br>        then = x.then<br>      &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-keyword">return</span> reject(e);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果 then 是一个函数，用 x 调用它，第一个参数是 resolvePromise，第二个参数是 rejectPromise。</span><br>      <span class="hljs-keyword">if</span>(isFunction(then))&#123;<br>        <span class="hljs-comment">// 使用called标记，确保只调用一次。</span><br>        <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>          then.call(x,<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">this</span>.resolvePromise(promise2,value,resolve,reject);<br>          &#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            reject(reason)<br>          &#125;)<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>          <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;<br>          <span class="hljs-keyword">return</span> reject(e)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 如果 then 不是一个函数，则用resolve(x)</span><br>      <span class="hljs-keyword">else</span>&#123;<br>        resolve(x);<br>      &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// 如果 x 不是一个对象或函数，则用resolve(x)。</span><br>    <span class="hljs-keyword">else</span>&#123;<br>      resolve(x);<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个时候其实已经大概写完了。</p><p>但是呢，onFulfilled 和 onRejected 都是微任务，所以我们需要给他们再包装一层</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">//省略</span><br><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled,onRejected</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = <span class="hljs-built_in">this</span>.isFunction(onFulfilled) ? onFulfilled:<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> realOnRejected = <span class="hljs-built_in">this</span>.isFunction(onRejected) ? onRejected:<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">throw</span> reason;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> fulfilledMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        queueMicrotask(<span class="hljs-function">()=&gt;</span>&#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">const</span> x = realOnFulfilled(<span class="hljs-built_in">this</span>.value);<br>            <span class="hljs-built_in">this</span>.resolvePromise(promise2,x,resolve,reject);<br>          &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            reject(e)<br>          &#125;<br>        &#125;)<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> rejectedMicrotask = <span class="hljs-function">()=&gt;</span>&#123;<br>        queueMicrotask(<span class="hljs-function">()=&gt;</span>&#123;<br>          <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">const</span> x = realOnRejected(<span class="hljs-built_in">this</span>,reason);<br>            <span class="hljs-built_in">this</span>.resolvePromise(promise2,x,resolve,reject);<br>          &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            reject(e);<br>          &#125;<br>        &#125;)<br>      &#125;<br><br>      <span class="hljs-comment">// 省略</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>好了 这就已经写完了。完整代码可见<a href="https://github.com/AruSeito/daily-practice/blob/main/others/Promise/promise.js">github</a></p><p>使用 promises-aplus-tests 跑了一下测试，全部通过。</p><p>在来更新些手写的其他 API</p><p>我们在使用 Promise 的时候经常会用到 Promise.resolve()/Promise.reject()这种用法，但是以上写法并不支持直接使用 MyPromise.resolve/reject。这种无需实例即可调用的方法我们称之为静态方法。</p><p>Promise.resolve()方法会返回一个 Promise 且状态为 fulfilled。Promise.reject()返回一个 Promise 且状态为 rejected。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br>  <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> MyPromise)&#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>      resolve(value);<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      reject(reason);<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>race 方法：将多个 Promise 实例，包装成一个新的 Promise 实例。只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span></span>&#123;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promiseList</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> length = promiseList.length;<br><br>      <span class="hljs-keyword">if</span>(length === <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> resolve();<br>      &#125;<br><br>      promiseList.forEach(<span class="hljs-function">(<span class="hljs-params">promise</span>)=&gt;</span>&#123;<br>        MyPromise.resolve(promise).then(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>          <span class="hljs-keyword">return</span> resolve(value)<br>        &#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>          <span class="hljs-keyword">return</span> reject(reason)<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
      <category>手撕源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(随手记录)mock方案-jsonServer</title>
    <link href="/article/5adf6b08/"/>
    <url>/article/5adf6b08/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又过了好久没更新博客了，前段时间因为工作太忙再加上学习到的都是零散的知识点，没有更新博客的想法。仔细想想，学习的过程不就是无数个小的知识点堆叠起来的吗。</p><p>所以又重拾博客，将每天学到的一点点小东西都记录下来。</p><h2 id="JSON-SERVER"><a href="#JSON-SERVER" class="headerlink" title="JSON-SERVER"></a>JSON-SERVER</h2><p>之前在上一家公司工作的时候，mock 方案采用的是 Easy-mock 这种 API 托管平台，后端生成 swagger,然后前端开发再将 swagger 同步到托管平台上。本地使用 express 的 http-proxy 中间件进行指定 API 的拦截转发。</p><p>但是在这家公司并没有关于 MOCK 的方案，只能进行前端写死数据然后进行模拟，每次要测试时都需要再去手动清除数据，隔了好久的可能还会有漏掉的地方。</p><p>所以学习了一下 mock 的方案。</p><p>本打算实现一个跟上一家公司的方案，在仔细查看了现公司的代码结构，发现并不适合接入该种方案：</p><p>现公司没有 node 层，都是前端静态页面直接请求后端，跨域由后端来进行处理，如果单单为了一个接口转发接入 node 层，有点无意义，所以放弃了该种方案。</p><p>采用了 JSON-SERVER 的方案。</p><p>但是 JSON-SERVER 更多的是适合处理符合 REST API 的，总是能遇到一些不符合 REST API 的。</p><p>这个时候需要写中间件。看 Demo，很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Javascript"><span class="hljs-comment">// middleWare Demo</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(<span class="hljs-params">req,res,next</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(req.method === <span class="hljs-string">&quot;POST&quot;</span> &amp;&amp; req.path === <span class="hljs-string">&quot;/login&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(req.body.username===<span class="hljs-string">&quot;aruseito&quot;</span> &amp;&amp; req.body.password === <span class="hljs-string">&quot;123456&quot;</span>)&#123;<br>      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json(&#123;<br>        <span class="hljs-attr">user</span>:&#123;<br>          <span class="hljs-attr">token</span>:<span class="hljs-string">&quot;123456&quot;</span><br>        &#125;<br>      &#125;)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).json(&#123;<br>        <span class="hljs-attr">message</span>:<span class="hljs-string">&quot;账号或者密码错误&quot;</span><br>      &#125;)<br>    &#125;<br>  &#125;<br>  next();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后只需要在启动 json-server 的时候加上<code>--middlewraes middleware.js</code>即可。如：<code>json-server __json_server_mock__/db.json --watch --port 3001 --middlewares __json_server_mock__/middleware.js</code>。</p><p>但是这种方案还是避免不了在上线前要修改接口地址的问题。所以很快就被我放弃了。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>考虑到以上因素，最终选择在本地自己启一个 node，读取配置文件，用 http-proxy 将接口按需转发过去。跟上一家公司的方案一样，只是没有将这个一起耦合到项目中去。</p><p>又考虑到我司有多种客户端，各端都不一定有合适的 MOCK 工具，所以打算将这层 node 使用 Electron 包装起来，搞个图形化界面，让各端都方便使用。</p><p>目前还在研究 Electron 怎么搞。。。只是刚有初步想法。</p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开着飞机修引擎---热更新</title>
    <link href="/article/57ff1b88/"/>
    <url>/article/57ff1b88/</url>
    
    <content type="html"><![CDATA[<p>在自己刚开始学习前端的时候，每次修改个新样式都要手动刷新一下页面。随着自己对前端的了解，开始使用了 live reload 插件进行代替，每次更改文件后，浏览器都会代替人工来刷新页面。随着后面的学习 React，发现使用 CRA 创建的东西可以在开着服务的时候进行不刷新就替换内容。</p><h2 id="live-reload"><a href="#live-reload" class="headerlink" title="live reload"></a>live reload</h2><p>使用 webpack 的 dev-server 模拟当年的 nginx+live-reload 插件<br>webpack 配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Development&quot;</span>,<br>    &#125;),<br>  ],<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].bundle.js&quot;</span>,<br>    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&quot;./dist&quot;</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>打开页面后，打开控制台的 network 标签可以看到其中有一条是 websocket 的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/websocket.png" alt="websocket"></p><p>查看这条记录，发现内部写了要进行的操作，以及更新的文件 hash 值（可以与上图中文件的 hash 对比一下，是完全一致的）。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/websocket-content.png" alt="websocket内容"></p><p>通过这个 websocket 链接，就可以使打开的网页和本地服务间建立持久化的通信。当源代码发生变更时，就通过 Socket 通知到浏览器，浏览器在接到通知后会自动触发页面刷新。</p><p>虽然这样也很方便，但是会有一个问题。页面的刷新会导致状态丢失：比如我在标中填充好的东西需要再重新填。</p><h2 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h2><p>开启 webpack 的热更新模块功能，配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  ...<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&quot;./dist&quot;</span>,<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  ...<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>开启服务后，修改一个 CSS 文件看看。</p><p>可以看到，websocket 这条记录中先通知了浏览器有文件更新了，通过服务端可以看出来，更新的 hash 可以对上。</p><p>但是为什么更新了<code>css</code>文件，他这面却更新的是 JS 呢？因为在使用 webpack 的过程中，webpack 将 css 的内容合并到了 js 中。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/change-style.png" alt="修改style文件引起的network变化"></p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/websocket-hot.png" alt="websocket内容详细"></p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/server-log.png" alt="webpack-server内容"></p><p>随后他请求了原文件（入口文件？）的 hash.hot.update.json 获取要更新的模块，然后再根据 json 内返回的模块内容去请求更新后的模块。</p><p>这也可以解释为什么更新 CSS 是加载模块，但是更新 JS 文件却是 reload。因为原文件（入口文件？）的 hash 值变了。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/hot-updateJs-content.png" alt="hot-updatejs内容"></p><p>至此大致流程已经明白了，画个简单的流程图看看吧</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/HMR-flow-chart.png" alt="热更新流程图"></p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>热更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux的最佳实践</title>
    <link href="/article/9fd9559e/"/>
    <url>/article/9fd9559e/</url>
    
    <content type="html"><![CDATA[<p>本版本为个人机器翻译+渣渣翻译+个人理解写成<br>原版见<a href="https://redux.js.org/style-guide/style-guide#priority-a-rules-essential">Redux的最佳实践官方文档</a></p><h2 id="必须遵守的"><a href="#必须遵守的" class="headerlink" title="必须遵守的"></a>必须遵守的</h2><h3 id="不要变异State。"><a href="#不要变异State。" class="headerlink" title="不要变异State。"></a>不要变异State。</h3><p>不改变现有state，而是去修改state的副本。</p><p>因为state可变是导致Redux出现BUG的最常见原因，而且还会破坏Redux DevTools中的<code>time-travel debugging </code>功能</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 错误实践</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span>(<span class="hljs-params">state = [], action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>      <span class="hljs-comment">//state突变</span><br>      state.push(&#123;<br>        <span class="hljs-attr">text</span>: action.text,<br>        <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span><br>      &#125;)<br>      <span class="hljs-keyword">return</span> state<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;COMPLETE_TODO&#x27;</span>:<br>      <span class="hljs-comment">// state[action.index]突变</span><br>      state[action.index].completed = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">return</span> state<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 最佳实践</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">todos</span>(<span class="hljs-params">state = [], action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>      <span class="hljs-comment">//返回一个新的副本</span><br>      <span class="hljs-keyword">return</span> [<br>        ...state,<br>        &#123;<br>          <span class="hljs-attr">text</span>: action.text,<br>          <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      ]<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;COMPLETE_TODO&#x27;</span>:<br>      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (index === action.index) &#123;<br>          <span class="hljs-comment">//返回一个新的副本</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, todo, &#123;<br>            <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span><br>          &#125;)<br>        &#125;<br>        <span class="hljs-keyword">return</span> todo<br>      &#125;)<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Reducer内不能有副作用"><a href="#Reducer内不能有副作用" class="headerlink" title="Reducer内不能有副作用"></a>Reducer内不能有副作用</h3><p>Reducer 函数应该只依赖于它们的状态和操作参数，并且应该只计算和返回基于这些参数的新状态值</p><p>这个规则的目的是保证reducer在被调用时会表现出可预测的行为。（又出现了函数式编程实现）</p><h3 id="不要在State和Action内放不可序列化（Non-Serializable）的值"><a href="#不要在State和Action内放不可序列化（Non-Serializable）的值" class="headerlink" title="不要在State和Action内放不可序列化（Non-Serializable）的值"></a>不要在State和Action内放不可序列化（Non-Serializable）的值</h3><p>避免将不可<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a>的值(如 Promises、 Symbols、 Maps/set、函数或类实例)放入到 Redux store state或dispatched actions中。这确保通过 Redux DevTools 进行调试的功能能够按预期的方式工作。它还可以确保用户界面按预期更新。</p><p>我觉得这个主要是为了保证程序的可预见性，切合函数式编程的思想。如果不可序列化的东西放进去，进行一系列操作后，可能会出现数据丢失。</p><h3 id="每个应用程序只有一个-Redux-Store"><a href="#每个应用程序只有一个-Redux-Store" class="headerlink" title="每个应用程序只有一个 Redux Store"></a>每个应用程序只有一个 Redux Store</h3><p>主要为了状态管理、追踪方便。</p><h2 id="强烈建议"><a href="#强烈建议" class="headerlink" title="强烈建议"></a>强烈建议</h2><h3 id="使用-Redux-Toolkit-编写-Redux-逻辑"><a href="#使用-Redux-Toolkit-编写-Redux-逻辑" class="headerlink" title="使用 Redux Toolkit 编写 Redux 逻辑"></a>使用 Redux Toolkit 编写 Redux 逻辑</h3><p>它的功能建立在Redux建议的最佳实践中，包括建立存储来捕捉变异并启用 Redux DevTools 扩展，用 Immer 简化不可变更新逻辑等。使用 RTK 可以简化逻辑，并确保你的应用程序设置为良好的默认设置。</p><h3 id="使用-Immer-编写不可变更新"><a href="#使用-Immer-编写不可变更新" class="headerlink" title="使用 Immer 编写不可变更新"></a>使用 Immer 编写不可变更新</h3><p>手工编写不可变更新逻辑通常很困难，并且容易出错。Immer 允许使用“变化”逻辑编写更简单的不可变更新，甚至可以冻结开发中的状态，以捕捉应用程序中其他地方的变化。</p><p>面试中问的也只是回答出了该点，该点主要是为了方便组件在判断是否更新时，进行浅比较。</p><h3 id="将有相同特性的文件放到一个文件夹"><a href="#将有相同特性的文件放到一个文件夹" class="headerlink" title="将有相同特性的文件放到一个文件夹"></a>将有相同特性的文件放到一个文件夹</h3><p>主要是为了方便维护。</p><h3 id="把尽可能多的逻辑放在Reducer中"><a href="#把尽可能多的逻辑放在Reducer中" class="headerlink" title="把尽可能多的逻辑放在Reducer中"></a>把尽可能多的逻辑放在Reducer中</h3><p>量将计算新状态的逻辑放到适当的 reducer 中，而不是放在准备和分派操作的代码中(如 click handler)。这有助于确保更多实际的应用程序逻辑易于测试，能够更有效地使用time-travel调试，并帮助避免可能导致变异和错误的常见错误。</p><p>在一些有效的情况下，应该首先计算部分或全部新state(例如生成唯一 ID) ，但是应该将其保持在最低限度。</p><h3 id="Reducer-应该拥有State结构"><a href="#Reducer-应该拥有State结构" class="headerlink" title="Reducer 应该拥有State结构"></a>Reducer 应该拥有State结构</h3><p>Redux 根state由单根 reducer 函数拥有和计算。为了可维护性，这个 reducer 被按照键/值分割成”slices”，每个“slice reducer”负责提供一个初始值并计算对该状态片的更新。</p><p>此外，“slice reducer”应该对作为计算状态的一部分返回的其他值进行控制。尽量减少使用“乱分配/返回”，比如 return action. payload 或 return { …state，…action.payload } ，因为它们依赖于action是正确格式化的内容，而 reducer 实际上放弃了对该状态的所有权。如果操作内容不正确，就会导致错误。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> initialState = &#123;<br>    <span class="hljs-attr">firstName</span> : <span class="hljs-literal">null</span> ,<br>    <span class="hljs-attr">lastName</span> : <span class="hljs-literal">null</span> ,<br>    <span class="hljs-attr">age</span> : <span class="hljs-literal">null</span> ,<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> usersReducer = (state = initialState, action ) &#123;<br>    <span class="hljs-keyword">switch</span> ( action.type ) &#123;<br>      <span class="hljs-comment">// 完全假定 action.payload 将是一个正确格式化的对象。</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;users/userLoggedIn&quot;</span> : &#123;<br>           <span class="hljs-keyword">return</span> action.payload;<br>        &#125;<br>        <span class="hljs-attr">default</span> : <span class="hljs-keyword">return</span> state ;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//如果代码的某个部分在操作中分派一个“ todo”对象，而不是一个“ user”对象:</span><br><span class="hljs-comment">//这个 reducer 会盲目地返回 todo，现在当它试图从商店中读取用户信息时，应用程序的其余部分可能会崩溃。</span><br>dispatch (&#123;<br>  <span class="hljs-attr">type</span> : <span class="hljs-string">&#x27;users/userLoggedIn&#x27;</span>,<br>  <span class="hljs-attr">payload</span> : &#123;<br>    <span class="hljs-attr">id</span> : <span class="hljs-number">42</span>,<br>    <span class="hljs-attr">text</span> : <span class="hljs-string">&#x27;Buy milk&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>如果 reducer 进行了一些验证检查以确保 action.payload 实际上具有正确的字段，或者尝试按名称读出正确的字段，那么至少可以部分修复这个问题。不过，这的确增加了更多的代码，所以这是一个为了安全而牺牲更多代码的问题。</p><p>使用静态类型确实使这种代码更安全，也更容易被接受。如果<code>reducer</code> 知道<code>action</code> 是<code> PayloadAction&lt;user&gt;</code> ，那么执行<code>return action.payload</code>是安全的。</p><h3 id="根据存储的数据结构命名“State-Slices”"><a href="#根据存储的数据结构命名“State-Slices”" class="headerlink" title="根据存储的数据结构命名“State Slices”"></a>根据存储的数据结构命名“State Slices”</h3><p><code>combineReducers</code>是将这些<code>slice reducer</code>连接成一个更大的<code>reducer</code>的标准函数。</p><p>传递给<code>combineReducers</code>的对象中的键名将定义结果<code>state</code>对象中键的名称。确保按照保存在数据中的键名进行命名，并避免在键名中使用“reducer”，例如：<code>&#123; users: &#123;&#125; ，posts: &#123;&#125;</code> ，而不是<code>&#123; usersReducer: &#123;&#125; ，postsReducer: &#123;&#125;</code></p><h3 id="将“Reducers”视为“State”机器"><a href="#将“Reducers”视为“State”机器" class="headerlink" title="将“Reducers”视为“State”机器"></a>将“Reducers”视为“State”机器</h3><p>许多Redux reducer都是“无条件”（unconditionally）的。它们只查看已调度的action并计算新的state，而不将任何逻辑建立在当前state的基础上。这可能会导致错误，因为根据应用程序逻辑的其余部分，某些操作在某些时候可能在概念上不“有效”。例如，“request succeeded”（请求成功）action只应在state为“loading”（已加载）时计算新值，或者仅当有标记为“being Editing”（正在编辑）的项时才应调度“update this item” action。</p><p>为了解决这个问题，将“Reducers”视为“state机”，其中当前state和分派action的组合决定是否实际计算一个新的状态值，而不仅仅是无条件地计算操作本身。</p><h3 id="规范复杂的嵌套-关系state"><a href="#规范复杂的嵌套-关系state" class="headerlink" title="规范复杂的嵌套/关系state"></a>规范复杂的嵌套/关系<code>state</code></h3><p>其实就是将state的结构扁平化。</p><h3 id="把action当作事件，而不是设置者"><a href="#把action当作事件，而不是设置者" class="headerlink" title="把action当作事件，而不是设置者"></a>把action当作事件，而不是设置者</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//最佳实践，把action当作事件</span><br>&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;food/orderAdded&quot;</span>,  <span class="hljs-attr">payload</span>: &#123;<span class="hljs-attr">pizza</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">coke</span> : <span class="hljs-number">1</span>&#125; &#125;<br><span class="hljs-comment">//差，把action作为设置者（setter）</span><br>&#123;<br>    <span class="hljs-attr">type</span> : <span class="hljs-string">&quot;orders/setPizzasOrdered&quot;</span>,<br>    <span class="hljs-attr">payload</span> : &#123;<br>        <span class="hljs-attr">amount</span> : getState().orders.pizza + <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br>&#123;<br>    <span class="hljs-attr">type</span> : <span class="hljs-string">&quot;orders/setCokesOrdered&quot;</span>,<br>    <span class="hljs-attr">payload</span> : &#123;<br>        <span class="hljs-attr">amount</span> : getState().orders.coke + <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="action的名字有意义"><a href="#action的名字有意义" class="headerlink" title="action的名字有意义"></a>action的名字有意义</h3><p>Type 字段主要用于两个目的：</p><ul><li>Reducer检查action.type，以确定是否应该处理此操作来计算新state</li><li>action.type显示在 reduxDevTools 历史日志中，方便调试</li></ul><h3 id="允许多个reducer对响应一个action"><a href="#允许多个reducer对响应一个action" class="headerlink" title="允许多个reducer对响应一个action"></a>允许多个reducer对响应一个action</h3><p>将action作为“事件”并允许多个reducer响应这些action通常会允许程序的代码更好地伸缩，并最小化为完成一个有意义的更新而分派多个操作所需的次数。</p><h3 id="避免连续分派多个action"><a href="#避免连续分派多个action" class="headerlink" title="避免连续分派多个action"></a>避免连续分派多个action</h3><p>通常会导致多个相对昂贵的 UI 更新，造成新能损耗，并且一些中间State可能会被应用程序逻辑的其他部分无效。</p><p>最好分派一个单独的“事件”类型的action，这样可以同时产生所有适当的State更新，或者考虑使用action批处理插件来分派多个动作，最后只有一个 UI 更新。</p><h3 id="评估每个state应该存在哪里"><a href="#评估每个state应该存在哪里" class="headerlink" title="评估每个state应该存在哪里"></a>评估每个state应该存在哪里</h3><p>有的state存在store里不合适，更适合存放在组件内部。</p><h3 id="使用-redux-Hooks-API"><a href="#使用-redux-Hooks-API" class="headerlink" title="使用 redux Hooks API"></a>使用 redux Hooks API</h3><p>hooks 更容易以多种方式使用。hooks具有更少的间接性，更少的代码编写，并且比 connect 更容易与Typescript一起使用。<br>主要是使用方便，便于维护。</p><h3 id="连接更多组件以从store读取数据"><a href="#连接更多组件以从store读取数据" class="headerlink" title="连接更多组件以从store读取数据"></a>连接更多组件以从store读取数据</h3><p>有更多的 UI 组件订阅到 Redux Store，并以更细粒度的级别读取数据。这通常会带来更好的 UI 性能，因为在给定的state更改时，需要呈现的组件更少。</p><p>与其仅仅连接一个 <code>&lt;userlist&gt;</code> 组件并读取整个用户数组，不如让 <code>&lt;userlist&gt;</code> 检索所有用户id的列表，将列表项作为 <code>&lt;UserListItem userId=&#123;userId&#125;&gt;</code>呈现，并将 <code>&lt;UserListItem&gt;</code> 连接起来并从store中提取它自己的用户条目。</p><h3 id="将mapDispatch的对象速记形式与connect一起使用"><a href="#将mapDispatch的对象速记形式与connect一起使用" class="headerlink" title="将mapDispatch的对象速记形式与connect一起使用"></a>将mapDispatch的对象速记形式与connect一起使用</h3><p>要连接的 mapDispatch 参数可以定义为作为参数接收分派的函数，也可以定义为包含动作创建者的对象。建议使用 mapDispatch 的“ object 速记”形式，因为它可以大大简化代码。几乎从来没有真正需要将 mapDispatch 编写为一个函数。</p><h3 id="在函数组件中多次调用useSelector"><a href="#在函数组件中多次调用useSelector" class="headerlink" title="在函数组件中多次调用useSelector"></a>在函数组件中多次调用useSelector</h3><p>当使用 useSelector 钩子检索数据时，最好多次调用 useSelector 并检索较小数量的数据，而不是使用单个较大的 useSelector 调用返回一个对象中的多个结果。与 mapState 不同，useSelector 不需要返回对象，而且Selector读取较小的值意味着给定的State更改不太可能导致该组件呈现</p><h3 id="使用静态类型"><a href="#使用静态类型" class="headerlink" title="使用静态类型"></a>使用静态类型</h3><p>类型系统将捕获许多常见错误，改进文档，并具有更好的长期可维护性。</p><h3 id="使用-Redux-DevTools-扩展进行调试"><a href="#使用-Redux-DevTools-扩展进行调试" class="headerlink" title="使用 Redux DevTools 扩展进行调试"></a>使用 Redux DevTools 扩展进行调试</h3><p>可以查看到：</p><ul><li>发送Action的历史记录</li><li>每个action的内容</li><li>action发出后的最后state</li><li>action发出前后state中的差异</li><li>函数堆栈跟踪显示实际调度操作的代码</li></ul><h3 id="对Statse而言使用纯JS对象"><a href="#对Statse而言使用纯JS对象" class="headerlink" title="对Statse而言使用纯JS对象"></a>对Statse而言使用纯JS对象</h3><p>在状态树中使用纯 JavaScript 对象和数组，而不是使用类似 Immutable.js 这样的专门库。虽然使用 Immutable.js 有一些潜在的好处，但是大多数常见的目标，比如简单的引用比较，通常是不可变更新的属性，不需要特定的库。这还可以使 bundle 大小更小，并降低数据类型转换的复杂性。特别推荐使用 Immer</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="将action-type写成domain-eventName"><a href="#将action-type写成domain-eventName" class="headerlink" title="将action.type写成domain/eventName"></a>将action.type写成domain/eventName</h3><p>例如：<code>todos/addTodo</code></p><h3 id="按照“Flux-Standard-Actions”约定写action"><a href="#按照“Flux-Standard-Actions”约定写action" class="headerlink" title="按照“Flux Standard Actions”约定写action"></a>按照“Flux Standard Actions”约定写action</h3><ul><li><p>总是把他们的数据放入一个payload field 字段</p></li><li><p>可能有一个<code>meta</code>字段来获取更多信息</p></li><li><p>可能有一个<code>error</code>字段来表示某种失败</p></li></ul><h3 id="使用Action-Creators"><a href="#使用Action-Creators" class="headerlink" title="使用Action Creators"></a>使用Action Creators</h3><p>使用Action Creators可以提供一致性，特别是在需要某种准备或额外逻辑来填充action内容的情况下（例如生成唯一的 ID）。</p><p>最好使用Action Creators来分派任何动作。但是建议使用 Redux Toolkit 中的 createSlice 函数，而不是手动编写Action Creators，它将自动生成Action Creators和Action.type。</p><h3 id="使用Redux-thunk进行异步"><a href="#使用Redux-thunk进行异步" class="headerlink" title="使用Redux-thunk进行异步"></a>使用<a href="https://github.com/reduxjs/redux-thunk">Redux-thunk</a>进行异步</h3><p>建议默认使用 Redux Thunk 中间件，因为它对于大多数典型用例(例如基本的 AJAX 数据获取)已经足够了。此外，在 thunks 中使用 async/await 语法使它们更易于阅读。</p><p>如果有真正复杂的异步工作流，包括取消、清除、在给定操作发出后运行逻辑或者“后台线程”类型的行为，那么可以考虑添加更强大的异步中间件，如 Redux-Saga 或者 Redux-Observable。</p><h3 id="将复杂逻辑移出组件"><a href="#将复杂逻辑移出组件" class="headerlink" title="将复杂逻辑移出组件"></a>将复杂逻辑移出组件</h3><p>将复杂的同步或异步部件移到组件之外，使用“容器/展示”组件分离。展示组件是外观，容器组件内放业务逻辑，给展示组件提供数据</p><h3 id="使用-Selector函数从Store读取"><a href="#使用-Selector函数从Store读取" class="headerlink" title="使用 Selector函数从Store读取"></a>使用 Selector函数从Store读取</h3><h3 id="Selector函数的名字应该为selectThing格式"><a href="#Selector函数的名字应该为selectThing格式" class="headerlink" title="Selector函数的名字应该为selectThing格式"></a>Selector函数的名字应该为<code>selectThing</code>格式</h3><h3 id="避免在-Redux-中放置表单状态"><a href="#避免在-Redux-中放置表单状态" class="headerlink" title="避免在 Redux 中放置表单状态"></a>避免在 Redux 中放置表单状态</h3><p>数据不是真正的全局数据，不会被缓存，也不会被多个组件同时使用。将表单连接到 Redux 通常需要在每个变更事件上执行调度操作，这会导致性能开销，并且不会带来实际的好处</p>]]></content>
    
    
    <categories>
      
      <category>Redux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>翻译</tag>
      
      <tag>最佳实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社招-字节跳动前端面试</title>
    <link href="/article/b0eba624/"/>
    <url>/article/b0eba624/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>找了朋友帮忙内推了字节跳动-飞书。没想到响应非常迅速，本以为会过一段时间才会安排面试。没想到隔天就安排上了面试，本来还想在面字节之前先拿其他几家试水，然后再来面试，没想到字节效率太高了。</p><p>二面已结束，在字节面试就是享受，虽然个人非常紧张，但是一场面试下来真的收获非常多。全部问题都是基于个人简历来进行问答的，面试记录抽象了一下。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>现在回顾一下面试题，发现大佬好像问了好多关于函数式编程的问题，组内可能已经在进行函数式编程的实践了？</p><h3 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h3><p>栈和堆没有本质区别，使用栈内存时，是从地址高位开始分配内存空间。使用堆内存时，是从地址低位开始分配空间。栈中存放的主要是执行上下文，函数调用栈等。堆中存放的是对象这种复杂数据。需要按地址访问。</p><h3 id="递归会引发什么问题？为什么会爆栈？"><a href="#递归会引发什么问题？为什么会爆栈？" class="headerlink" title="递归会引发什么问题？为什么会爆栈？"></a>递归会引发什么问题？为什么会爆栈？</h3><p>过深的递归会引起爆栈。内存中特地用来存放函数调用的栈区内存是有限的，如果递归太深，就会出现只入栈不出栈的情况。</p><h3 id="进程和线程的区别。"><a href="#进程和线程的区别。" class="headerlink" title="进程和线程的区别。"></a>进程和线程的区别。</h3><p>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。</p><h3 id="Chrome-都有什么进程。"><a href="#Chrome-都有什么进程。" class="headerlink" title="Chrome 都有什么进程。"></a>Chrome 都有什么进程。</h3><p>1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><h3 id="HTTPs-怎么回事？"><a href="#HTTPs-怎么回事？" class="headerlink" title="HTTPs 怎么回事？"></a>HTTPs 怎么回事？</h3><h4 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h4><ol><li><p>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</p></li><li><p>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</p></li><li><p>最后浏览器和服务器分别返回确认消息。</p></li><li><p>然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p></li></ol><h4 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h4><ol><li><p>首先浏览器发送加密套件列表给服务器。</p></li><li><p>然后服务器会选择一个加密套件，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</p></li><li><p>最后就是浏览器和服务器返回确认消息。</p></li><li><p>在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据</p></li></ol><h4 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h4><ol><li><p>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</p></li><li><p>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</p></li><li><p>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</p></li><li><p>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</p></li><li><p>服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥。</p></li></ol><h4 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h4><ol><li><p>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</p></li><li><p>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和 证书</p></li><li><p>浏览器验证证书，生成随机数 pre-master，利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</p></li><li><p>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</p></li><li><p>服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥。</p></li></ol><h3 id="证书验证的流程。"><a href="#证书验证的流程。" class="headerlink" title="证书验证的流程。"></a>证书验证的流程。</h3><ol><li><p>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A</p></li><li><p>然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；</p></li><li><p>对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的。同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p></li></ol><h3 id="如何尽可能的多发包并且不丢包？"><a href="#如何尽可能的多发包并且不丢包？" class="headerlink" title="如何尽可能的多发包并且不丢包？"></a>如何尽可能的多发包并且不丢包？</h3><p>到目前为止不知道怎么答。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><a href="https://blog.csdn.net/yao5hed/article/details/81046945">滑动窗口详解</a></p><h3 id="HTTP2-的多路复用是怎么回事？"><a href="#HTTP2-的多路复用是怎么回事？" class="headerlink" title="HTTP2 的多路复用是怎么回事？"></a>HTTP2 的多路复用是怎么回事？</h3><p>在一个 TCP 连接中可以存在多条流。也就是可以发送多个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><h3 id="HTTP-中的响应头拥塞怎么回事？"><a href="#HTTP-中的响应头拥塞怎么回事？" class="headerlink" title="HTTP 中的响应头拥塞怎么回事？"></a>HTTP 中的响应头拥塞怎么回事？</h3><p>HTTP/1.1 通过管道技术实现一次性发送多个请求，以期提高吞吐和性能。然而，这种技术在接收响应时，要求必须按照发送请求的顺序返回。如果，第一个请求被堵塞了，则后面的请求即使处理完毕了，也需要等待。</p><h3 id="WEBPACK-构建如何优化？"><a href="#WEBPACK-构建如何优化？" class="headerlink" title="WEBPACK 构建如何优化？"></a>WEBPACK 构建如何优化？</h3><p>详见<a href="https://aruseito.github.io/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96/">构建优化</a></p><h3 id="React-的生命周期"><a href="#React-的生命周期" class="headerlink" title="React 的生命周期"></a>React 的生命周期</h3><p>react 15:<br>挂载时：</p><ul><li><p>constructor</p></li><li><p>componentWillMount</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>更新：</p><ul><li><p>componentWillRecieveProps（由父组件的更新触发）</p></li><li><p>shouldComponentUpdate</p></li><li><p>componentWillUpdate</p></li><li><p>render</p></li><li><p>componentDidUpdate</p></li></ul><p>卸载：</p><ul><li>componentWillUnmount</li></ul><p>react 16:</p><p>挂载时：</p><ul><li><p>constructor</p></li><li><p>getDerivedStatesFromProps</p></li><li><p>render</p></li><li><p>componentDidMount</p></li></ul><p>更新：</p><ul><li><p>getDerivedStatesFromProps （16.3 以前只有 New Props 会触发，16.4 以后 New Props、setState、forceUpdate 都可以触发）</p></li><li><p>shouldComponentUpdate</p></li><li><p>render</p></li><li><p>getSnapshotBeforeUpdate</p></li><li><p>componentDidUpdate</p></li></ul><p>卸载：</p><ul><li>componentWillUnmount</li></ul><h3 id="React-的组件类型"><a href="#React-的组件类型" class="headerlink" title="React 的组件类型"></a>React 的组件类型</h3><p>类组件和函数组件</p><p>函数组件：符合 React 设计理念，函数编程<br>类组件：面向对象编程思想</p><h3 id="pureComponet-与-Component"><a href="#pureComponet-与-Component" class="headerlink" title="pureComponet 与 Component"></a>pureComponet 与 Component</h3><ul><li><p>PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行浅比较，并根据浅比较的结果，决定是否需要继续更新流程。</p></li><li><p>Component 没有实现 shouldComponentUpdate。</p></li></ul><h3 id="useCallback-和-useMemo"><a href="#useCallback-和-useMemo" class="headerlink" title="useCallback 和 useMemo"></a>useCallback 和 useMemo</h3><ul><li><p>useCallback 返回一个 memoized 回调函数</p></li><li><p>useMemo 返回 memoized 值</p></li></ul><p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p><h3 id="forwardref"><a href="#forwardref" class="headerlink" title="forwardref"></a>forwardref</h3><p>forwardref：转发 refs 到 DOM 组件、在高阶组件中转发 refs</p><h3 id="Redux-的最佳实践"><a href="#Redux-的最佳实践" class="headerlink" title="Redux 的最佳实践"></a>Redux 的最佳实践</h3><p><a href="https://aruseito.github.io/2021/03/12/Redux%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">个人理解加官方文档翻译版</a><br><a href="https://redux.js.org/style-guide/style-guide#priority-a-rules-essential">Redux 的最佳实践官方文档</a></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法题就不放具体题了把。我看面试官那面标记了我的名字+题目。。。不知道直接放原题会不会有问题。</p><p>算法题一共两道，第一道考察：数据结构栈和链表 第二题考查函数式编程柯里化。</p><p>都不难，但是一紧张脑梗了。第一道题写了个蠢死了的算法，在面试官的引导下完成了优化。</p><p>第二题直接没了思路，面试结束后看了一下，发现还是很简单的，可以直接用扩展运算符。。。</p><h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span><br>  <span class="hljs-keyword">let</span> _args = [...arguments];<br><br>  <span class="hljs-comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br>  <span class="hljs-keyword">let</span> adder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> _adder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// [].push.apply(_args, [].slice.call(arguments));</span><br>      _args.push(...arguments);<br>      <span class="hljs-keyword">return</span> _adder;<br>    &#125;;<br><br>    <span class="hljs-comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br>    _adder.toString = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> _args.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>      &#125;);<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> _adder;<br>  &#125;;<br>  <span class="hljs-comment">// return adder.apply(null, _args);</span><br>  <span class="hljs-keyword">return</span> adder(..._args);<br>&#125;<br><br><span class="hljs-comment">// 新版Chrome不会自动调取toString了,safari还可以</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).toString();<br>add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>).toString(); <span class="hljs-comment">//10</span><br></code></pre></div></td></tr></table></figure><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="child-process-exec-怎么实现的提高效率？进程和-CPU-的关系？如果只有一个-CPU-还能提升效率吗？为什么？"><a href="#child-process-exec-怎么实现的提高效率？进程和-CPU-的关系？如果只有一个-CPU-还能提升效率吗？为什么？" class="headerlink" title="child_process.exec 怎么实现的提高效率？进程和 CPU 的关系？如果只有一个 CPU 还能提升效率吗？为什么？"></a>child_process.exec 怎么实现的提高效率？进程和 CPU 的关系？如果只有一个 CPU 还能提升效率吗？为什么？</h3><p>child_process.exec 主要是开启了多进程。多个进程可以并行在多个 cpu 中计算，对于单 cpu，多个进程在这个单 cpu 中是并发运行，根据时间片读取上下文+执行程序+保存上下文。。同一个进程同一时间段只能在一个 cpu 中运行，如果进程数小于 cpu 数，那么未使用的 cpu 将会空闲。</p><h3 id="首屏渲染时间优化方案？"><a href="#首屏渲染时间优化方案？" class="headerlink" title="首屏渲染时间优化方案？"></a>首屏渲染时间优化方案？</h3><ul><li><p>资源太大？资源压缩，传输压缩，代码拆分，Tree sharking，HTTP/2，缓存。</p></li><li><p>首页内容太多？懒加载,预渲染，SSR</p></li><li><p>时序问题？prefetch，preload</p></li></ul><h3 id="csp-是什么？会造成什么问题？"><a href="#csp-是什么？会造成什么问题？" class="headerlink" title="csp 是什么？会造成什么问题？"></a>csp 是什么？会造成什么问题？</h3><p>csp 是内容安全策略，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。乱修改可能引起 XSS，数据包嗅探攻击。</p><h3 id="typescript-中的-type-和-interface-的区别？"><a href="#typescript-中的-type-和-interface-的区别？" class="headerlink" title="typescript 中的 type 和 interface 的区别？"></a>typescript 中的 type 和 interface 的区别？</h3><ul><li><p>type 可以声明基本类型别名，联合类型，元组等类型</p></li><li><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p></li><li><p>interface 能够声明合并。</p></li><li><p>interface 使用 extends 扩展，type 使用交叉类型(&amp;)扩展</p></li></ul><h3 id="useCallback-和-useRef"><a href="#useCallback-和-useRef" class="headerlink" title="useCallback 和 useRef?"></a>useCallback 和 useRef?</h3><ul><li><p>userCallback 返回的是一个 memozied 函数</p></li><li><p>useRef 可以返回一个可变的 ref 对象，本质上，<code>useRef</code> 就像是可以在其 <code>.current</code> 属性中保存一个可变值的“盒子”。<code>useRef() </code>比 <code>ref</code> 属性更有用。它可以很方便地保存任何可变值。它创建的是一个普通 Javascript 对象。而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象。</p></li></ul><h3 id="hook-的使用注意事项？为什么？"><a href="#hook-的使用注意事项？为什么？" class="headerlink" title="hook 的使用注意事项？为什么？"></a>hook 的使用注意事项？为什么？</h3><p>不要在循环，条件或嵌套函数中调用 Hook。</p><p>在初始化阶段，会将 hook 的相关信息保存在一个 hook 对象内，然后 hook 对象之间以单向链表的形式串联。在更新阶段，按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的，这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是什么。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果就会出问题。</p><p>代码题：</p><h3 id="26-进制转换。"><a href="#26-进制转换。" class="headerlink" title="26 进制转换。"></a>26 进制转换。</h3><blockquote><p>0-&gt;A, 1-&gt;B … 24-&gt;Y,25-&gt;Z,26-&gt;AA,27-&gt;AB…52-&gt;BA</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> convert26 = <span class="hljs-function">(<span class="hljs-params">num</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">let</span> real = num + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span>(real &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">let</span> m = real % <span class="hljs-number">26</span>;<br>    <span class="hljs-keyword">if</span>(m === <span class="hljs-number">0</span>)&#123;<br>      m = <span class="hljs-number">26</span>;<br>    &#125;<br>    str = <span class="hljs-built_in">String</span>.fromCharCode ( m + <span class="hljs-number">64</span>) + str;<br>    real = (real - m) / <span class="hljs-number">26</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="叶子结点的公共祖先节点"><a href="#叶子结点的公共祖先节点" class="headerlink" title="叶子结点的公共祖先节点"></a>叶子结点的公共祖先节点</h3><blockquote><p>每个节点均含有指向其父节点的指针和 val，给两个叶子结点找到他们的公共祖先节点。要求空间复杂度为 O(1)</p></blockquote><p>最先给了一个空间复杂度 O(n)的思路。</p><p>选择一个节点为开始遍历一遍存入 MAP，第二个节点遍历的时候判断 MAP 内是否存在即可。</p><p>后面问面试官的时候问了这道题，面试官说，这个可以当作<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a>来做。恍然大悟。然后还给我详细解说了，空间换时间，时间换空间的事情，豁然开朗。</p><p>思路就是：遍历完自己的节点后 交换位置继续遍历 最后二者的总步数是一样 相遇时即为所求第一个祖先节点</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> firstH = headA, secondH = headB<br><br>    <span class="hljs-keyword">while</span> (firstH !== secondH) &#123;<br>        firstH = firstH ? firstH.next : headB<br>        secondH = secondH ? secondH.next : headA<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> firstH;<br><br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>字节跳动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之传输加载优化</title>
    <link href="/article/adf14e0a/"/>
    <url>/article/adf14e0a/</url>
    
    <content type="html"><![CDATA[<h2 id="传输压缩方案-GZip"><a href="#传输压缩方案-GZip" class="headerlink" title="传输压缩方案-GZip"></a>传输压缩方案-GZip</h2><p>对传输资源进行体积压缩，可以高达90%</p><p>以下为nginx配置</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">gzip</span> <span class="hljs-string">on;</span><br><span class="hljs-attr">gzip_min_length</span> <span class="hljs-string">1k; # 文件最小启用压缩大小</span><br><span class="hljs-attr">gzip_comp_level</span> <span class="hljs-string">6; # 压缩级别1-9 等级越高CPU消耗越高</span><br><span class="hljs-attr">gzip_types</span> <span class="hljs-string">text/plain application/javascript application/x-javascript text/css application/xml text/xml text/javascript application/json; # 文件压缩类型，一般重点压缩文本类型，图片压缩使用gzip消耗大，收益小。</span><br><span class="hljs-attr">gzip_static</span> <span class="hljs-string">on; # 已经压缩过的资源可以直接用</span><br><span class="hljs-attr">gzip_vary</span> <span class="hljs-string">on;# 响应头添加vary属性，告知客户端启用gzip压缩</span><br><span class="hljs-attr">gzip_buffers</span> <span class="hljs-string">4 16k; #使用buffer优化压缩过程</span><br><span class="hljs-attr">gzip_http_version</span> <span class="hljs-string">1.1; #使用gzip的http版本</span><br></code></pre></div></td></tr></table></figure><h2 id="复用TCP链接-Keep-Alive"><a href="#复用TCP链接-Keep-Alive" class="headerlink" title="复用TCP链接-Keep Alive"></a>复用TCP链接-Keep Alive</h2><p>不需要重复建立链接，节省了链接创建时间。</p><p>Chrome-DevTools-NetWork-waterfall-Initial connection只出现在第一个请求，后续没有这段消耗的时间。</p><p>可以通过response Headers-connection：keep-alive查看是否开启</p><p>以下为nginx配置：</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">keepalive_timeout</span> <span class="hljs-string">65; # 超时时间，超过该时间不使用就会关闭。0表示不启用</span><br><span class="hljs-attr">keepalive_requests</span> <span class="hljs-string">100; # 利用该TCP链接可以发起多少个请求。</span><br></code></pre></div></td></tr></table></figure><h2 id="HTTP资源缓存"><a href="#HTTP资源缓存" class="headerlink" title="HTTP资源缓存"></a>HTTP资源缓存</h2><p>提高重复访问时资源加载的速度。</p><ul><li><p>Cache-Control/Expires</p></li><li><p>Last-Modified + If-Modified-Since：等价于第三种，但没有第三种好用：跟时间有关的，如果本地和服务器时间不同步会有坑。</p></li><li><p>ETag + If-None-Match：服务端先对文件生成唯一标识ETag，在第一次请求的时候带回来，第二次请求的时候请求头会有If-None-Match：ETag值的形式，如果ETag不匹配就拿新资源，匹配就返回304。</p></li></ul><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">if($request_filename</span> <span class="hljs-string">~* .*\.(?:htm|html)$) # 匹配HTML，所有的资源都是通过html进行加载的，缓存可能导致用户拿不到最新内容。</span><br><span class="hljs-meta">&#123;</span> <span class="hljs-string"></span><br>    <span class="hljs-attr">add_header</span> <span class="hljs-string">Cache-Control &quot;no-cache, must-revalidate&quot;; # HTTP1.1 告知浏览器不需要缓存，需要的时候就去获取，获取完成后重新验证。</span><br>    <span class="hljs-attr">add_header</span> <span class="hljs-string">&quot;Pragma&quot; &quot;no-cache&quot;; # 考虑兼容性，告知HTTP1.0的浏览器不要缓存</span><br>    <span class="hljs-attr">add_header</span> <span class="hljs-string">&quot;Expires&quot; &quot;0&quot;; # 0或者负数代表告知浏览器立即过期。</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-meta">if($request_filename</span> <span class="hljs-string">~* .*\.(?:js|css)$) # 匹配js和css</span><br><span class="hljs-attr">&#123;</span><br>  <span class="hljs-attr">expires</span> <span class="hljs-string">7d; # 浏览器缓存7天</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-meta">if($request_filename</span> <span class="hljs-string">~* .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$) # 匹配图片资源等</span><br><span class="hljs-attr">&#123;</span><br>  <span class="hljs-attr">expires</span> <span class="hljs-string">7d; # 浏览器缓存7天</span><br><span class="hljs-attr">&#125;</span><br></code></pre></div></td></tr></table></figure><h2 id="Service-Workers"><a href="#Service-Workers" class="headerlink" title="Service Workers"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">Service Workers</a></h2><h3 id="Service-Workers作用"><a href="#Service-Workers作用" class="headerlink" title="Service Workers作用"></a>Service Workers作用</h3><ul><li><p>加速重复访问</p></li><li><p>离线支持</p></li></ul><h3 id="Service-Workers原理"><a href="#Service-Workers原理" class="headerlink" title="Service Workers原理"></a>Service Workers原理</h3><p>在服务端与客户端中间加一个中间层：Service Workers（在客户端），初次请求经过ServiceWorkers的时候，进行缓存，再次请求的时候直接请求ServiceWorkers。</p><h3 id="Service-Workers问题"><a href="#Service-Workers问题" class="headerlink" title="Service Workers问题"></a>Service Workers问题</h3><ul><li><p>延长了首屏时间，但页面总加载时间减少</p></li><li><p>兼容性（目前基本都是支持了）</p></li><li><p>只能在localhost或https下使用</p></li></ul><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>二进制传输</p></li><li><p>请求响应多路复用：异步请求响应资源</p></li><li><p>server push：可以省略TTFB时间</p></li></ul><h3 id="搭建HTTP-2服务"><a href="#搭建HTTP-2服务" class="headerlink" title="搭建HTTP/2服务"></a>搭建HTTP/2服务</h3><ul><li><p>HTTPS为基础</p></li><li><p>适合较高的请求量</p></li></ul><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li><p>加速首屏渲染</p></li><li><p>友好的SEO</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/SSR.png" alt="CSR与SSR"></p><h3 id="适合SSR的情况"><a href="#适合SSR的情况" class="headerlink" title="适合SSR的情况"></a>适合SSR的情况</h3><ul><li><p>架构-大型，动态页面，面向公众用户</p></li><li><p>搜索引擎排名很重要</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络传输</tag>
      
      <tag>nginx</tag>
      
      <tag>HTTP2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之构建优化</title>
    <link href="/article/1148eb19/"/>
    <url>/article/1148eb19/</url>
    
    <content type="html"><![CDATA[<h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a><a href="https://webpack.docschina.org/guides/tree-shaking/">Tree-shaking</a></h2><p>将上下文未用到的代码删掉，不会打包到最终文件中（基于ES6的模块化才可以），来达到减小JS文件大小的目的</p><p>有些代码可能会影响到全局作用域或没有用ES6的模块功能，可以通过设置<code>package.json</code>中的<code>sideEffects</code>来指定不希望被shaking掉的文件（在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。）</p><p>注意babel默认配置的影响：可能会将es6的模块化语法替换为兼容es5的其他模块化语法。</p><p>webpack 5：已经默认集成terser-webpack-plugin来压缩JS</p><h2 id="作用域提升"><a href="#作用域提升" class="headerlink" title="作用域提升"></a>作用域提升</h2><p>未启用：webpack将模块打包成单独的模块，有依赖关系部分会通过webpack_require进来，再调用。</p><p>启动：先分析，然后将依赖提升或合并为一个闭包，来达到压缩代码体积的目的，提高执行效率。（具体可见webpack插件<a href="https://webpack.docschina.org/plugins/module-concatenation-plugin/#root">ModuleConcatenationPlugin</a>）</p><h2 id="Babel7优化配置"><a href="#Babel7优化配置" class="headerlink" title="Babel7优化配置"></a>Babel7优化配置</h2><h3 id="在需要的地方引入polyfill"><a href="#在需要的地方引入polyfill" class="headerlink" title="在需要的地方引入polyfill"></a>在需要的地方引入polyfill</h3><p>将<code>useBuiltIns</code>设置为<code>usage</code>.</p><p>各个属性值的输入与输出差异可见：<a href="https://www.babeljs.cn/docs/babel-preset-env#usebuiltins">useBuiltIns详细说明</a></p><h3 id="辅助函数的按需引入-复用"><a href="#辅助函数的按需引入-复用" class="headerlink" title="辅助函数的按需引入/复用"></a>辅助函数的按需引入/复用</h3><p><a href="https://www.babeljs.cn/docs/babel-plugin-transform-runtime#docsNav">@babel/plugin-transform-runtime</a>：重用 Babel 注入的帮助器代码来减少代码体积</p><h3 id="根据目标浏览器按需转换代码"><a href="#根据目标浏览器按需转换代码" class="headerlink" title="根据目标浏览器按需转换代码"></a>根据目标浏览器按需转换代码</h3><p>需要支持的版本越少，代码体积越小。</p><p>通过<code>target:browsers</code>属性设置。<a href="https://github.com/browserslist/browserslist#full-list">browsers可填写的值</a></p><h2 id="webpack的依赖优化"><a href="#webpack的依赖优化" class="headerlink" title="webpack的依赖优化"></a>webpack的依赖优化</h2><p>提高构建速度，主要影响开发环境</p><h3 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h3><p>直接通知webpack忽略较大的库：被忽略的库不能有import，require，define的引入方式</p><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a><a href="https://webpack.docschina.org/plugins/dll-plugin/#root">DllPlugin</a></h3><p>避免开发环境打包时对不变的重复的库重复构建</p><p>eg.:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//webpack.dll.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span>,<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">react</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>],<br>    &#125;,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].dll.js&quot;</span>,<br>        <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&quot;dll&quot;</span>),<br>        <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;[name]&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> webpack.DllPlugin(&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;[name]&quot;</span>,<br>            <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&quot;dll/[name].manifest.json&quot;</span>)<br>        &#125;)<br>    ]<br>&#125;;<br><br><span class="hljs-comment">//webpack.config.js</span><br><span class="hljs-keyword">const</span> DllReferencePlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/DllReferencePlugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports =&#123;<br>  ...,<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> DllReferencePlugin(&#123;<br>            <span class="hljs-attr">manifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;__dirname&#125;</span>/dll/react.manifest.json`</span>)<br>        &#125;)<br>  ],<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h2><p>把单个bundle文件拆分成若干个小的bundles/chunks，以达到缩短首屏加载时间</p><h3 id="手工定义入口（蠢方法，不推荐）"><a href="#手工定义入口（蠢方法，不推荐）" class="headerlink" title="手工定义入口（蠢方法，不推荐）"></a>手工定义入口（蠢方法，不推荐）</h3><p>手动指定多个entry，用到的一些公共部分会重复打包</p><h3 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h3><ul><li><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">splitChunks</a>提取公有代码，拆分业务代码与第三方库.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports=&#123;<br>  ...,<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">cacheGroups</span>: &#123; <span class="hljs-comment">//设置缓存组</span><br>        <span class="hljs-attr">vendor</span>: &#123;<span class="hljs-comment">//第三方库</span><br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vendor&#x27;</span>,<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>            minSize: <span class="hljs-number">0</span>, <br>            <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">priority</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">common</span>: &#123;<span class="hljs-comment">//业务代码</span><br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span>,<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]src[\\/]/</span>,<br>            chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<span class="hljs-comment">//</span><br>            <span class="hljs-attr">minSize</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p><a href="https://react.docschina.org/docs/concurrent-mode-suspense.html">Suspense</a></p><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><h3 id="Minification"><a href="#Minification" class="headerlink" title="Minification"></a><a href="https://webpack.docschina.org/guides/production/#minification">Minification</a></h3><ul><li><p>Terser 压缩JS</p></li><li><p>mini-css-extract-plugin和optimize-css-assets-webpack-plugin/CssMinimizerWebpackPlugin  提取与压缩css</p></li><li><p>HtmlWebpackPlugin 生成HTMl并压缩</p></li></ul><h2 id="资源持久化缓存"><a href="#资源持久化缓存" class="headerlink" title="资源持久化缓存"></a>资源持久化缓存</h2><p>每个打包的资源文件有唯一的hash值，修改后只有受影响的文件hash变化，可以做增量式更新，充分利用浏览器缓存。</p><p>在webpack输出文件的时候，filename和chunkFilename用命名时使用变量<code>[contenthash]</code></p><h2 id="应用大小监测与分析"><a href="#应用大小监测与分析" class="headerlink" title="应用大小监测与分析"></a>应用大小监测与分析</h2><h3 id="Stats分析与可视化图表"><a href="#Stats分析与可视化图表" class="headerlink" title="Stats分析与可视化图表"></a>Stats分析与可视化图表</h3><p>在终端输入<code>webpack --profile --json &gt; stats.json</code></p><p><a href="https://alexkuz.github.io/webpack-chart/">Webpack Chart</a></p><h3 id="webpack-bundle-analyzer进行体积分析"><a href="#webpack-bundle-analyzer进行体积分析" class="headerlink" title="webpack-bundle-analyzer进行体积分析"></a>webpack-bundle-analyzer进行体积分析</h3><ul><li><p><code>webpack --analyze</code></p></li><li><p><code>yarn add source-map-explorer</code>：需要webpack中开启devtool生成source-map</p></li></ul><h3 id="speed-measure-webpack-plugin速度分析"><a href="#speed-measure-webpack-plugin速度分析" class="headerlink" title="speed-measure-webpack-plugin速度分析"></a>speed-measure-webpack-plugin速度分析</h3><p><a href="https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a></p><h2 id="React按需加载的实现"><a href="#React按需加载的实现" class="headerlink" title="React按需加载的实现"></a>React按需加载的实现</h2><h3 id="React-Router基于webpack按需加载，使用loadable-component包装成HOC"><a href="#React-Router基于webpack按需加载，使用loadable-component包装成HOC" class="headerlink" title="React Router基于webpack按需加载，使用loadable/component包装成HOC"></a>React Router基于webpack按需加载，使用loadable/component包装成HOC</h3><p>使用<a href="https://www.npmjs.com/package/@loadable/component">@loadable/component</a></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> LoadableComp = loadable(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Component.jsx&#x27;</span>), &#123;<br>    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;&lt;div&gt;loading...&lt;/div&gt;&#x27;</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><blockquote><p><a href="https://segmentfault.com/a/1190000022205477">webpack优化</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之资源优化</title>
    <link href="/article/c32e6a1d/"/>
    <url>/article/c32e6a1d/</url>
    
    <content type="html"><![CDATA[<h2 id="资源的压缩与合并"><a href="#资源的压缩与合并" class="headerlink" title="资源的压缩与合并"></a>资源的压缩与合并</h2><h3 id="为什么要压缩-amp-合并"><a href="#为什么要压缩-amp-合并" class="headerlink" title="为什么要压缩&amp;合并"></a>为什么要压缩&amp;合并</h3><ul><li><p>减少http请求数量</p></li><li><p>减少请求资源的大小</p></li></ul><h3 id="HTML-amp-CSS压缩"><a href="#HTML-amp-CSS压缩" class="headerlink" title="HTML&amp;CSS压缩"></a>HTML&amp;CSS压缩</h3><ul><li><p>使用在线工具进行压缩</p></li><li><p>使用第三方NPM包的工具</p></li><li><p>使用webpack的plugin</p></li></ul><h3 id="JS压缩与混淆"><a href="#JS压缩与混淆" class="headerlink" title="JS压缩与混淆"></a>JS压缩与混淆</h3><ul><li><p>使用在线工具进行压缩</p></li><li><p>使用webpack对js在构建时压缩与混淆</p></li></ul><h3 id="CSS-JS文件合并"><a href="#CSS-JS文件合并" class="headerlink" title="CSS/JS文件合并"></a>CSS/JS文件合并</h3><p>优点：只进行一次TCP/IP链接，减少三次握手，TTFB等时间消耗<br>缺点：文件过大的情况下，文件下载耗时长，解析时间长。如果合并成一个文件，有一个子文件改动，缓存就会失效，需要重新加载整个文件。</p><ul><li><p>若干小文件</p></li><li><p>无冲突，服务相同的模块</p></li><li><p>拒绝单纯为了优化网络加载而合并。</p></li></ul><p>主流方案：先拆分，将最主要的内容更早的加载，后续内容分批次加载。</p><h2 id="图片优化-图片格式优化"><a href="#图片优化-图片格式优化" class="headerlink" title="图片优化-图片格式优化"></a>图片优化-图片格式优化</h2><h3 id="图片优化的方案"><a href="#图片优化的方案" class="headerlink" title="图片优化的方案"></a>图片优化的方案</h3><ul><li><p>选择合适的格式</p></li><li><p>大小合适，自动适配</p></li><li><p>图片压缩（会造成质量下降）</p></li><li><p>按优先级加载。</p></li><li><p>懒加载</p></li></ul><h3 id="图片格式比较"><a href="#图片格式比较" class="headerlink" title="图片格式比较"></a>图片格式比较</h3><ul><li><p>jpeg/jpg：压缩比高，色彩保存好。纹理边缘模糊（可以用<a href="https://github.com/imagemin/imagemin">imagemin</a>）</p></li><li><p>png：色彩好，纹理边缘清晰，文件大。主要用来做比较小的图片（logo等）。压缩可以用<a href="https://github.com/imagemin/imagemin-pngquant">imagemin-pngquant</a></p></li><li><p>webP：质量高，压缩比高。</p></li></ul><h3 id="IconFont"><a href="#IconFont" class="headerlink" title="IconFont"></a>IconFont</h3><ul><li>比图片小，加载快</li><li>自由的变化大小，且不会模糊</li><li>可以任意改变颜色（只能被渲染成单色或者CSS3的渐变色）</li></ul><h3 id="移动端图标-SVG"><a href="#移动端图标-SVG" class="headerlink" title="移动端图标-SVG"></a>移动端图标-SVG</h3><p>webpack-loader使用：<code>@svgr/webpack</code>，</p><ul><li>需要手动设置尺寸大小</li><li>保持图片能力，支持多色彩</li><li>独立的矢量图形</li><li>XML语法，搜索引擎SEO和无障碍读屏软件读取</li></ul><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><ul><li><p>懒加载：原生方法：img标签的loading属性；第三方：verlok/lazyload,yall.js,Blazy</p></li><li><p>渐进式加载：逐步从低质量到高质量。优点：用户一直能看到内容。 解决方案：progressive-image、ImageMagick、libjpeg等</p></li><li><p>响应式加载：srcset属性，sizes属性，picture属性</p></li></ul><h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><p>字体未下载完成时，浏览器隐藏或自动降级，导致字体闪烁。</p><p>Flash Of Invisible Text(FOIT)：不可见文字闪烁指我们阻止或延迟加载字体直到字体可用。 因此，在加载字体之前，我们的页面可能看起来很空白。<br>Flash Of Unstyled Text (FOUT)：无样式文本闪烁是指当先加载系统默认字体，在准备好自定义字体加载完成后切换。</p><h3 id="拥抱FOUT：使用font-display"><a href="#拥抱FOUT：使用font-display" class="headerlink" title="拥抱FOUT：使用font-display"></a>拥抱FOUT：使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display">font-display</a></h3><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/font-display.png" alt="font-display各个属性效果"></p><p><a href="https://font-display.glitch.me/">font-display各个属性动态效果</a></p><h3 id="使用CSS-Font-Loading-API"><a href="#使用CSS-Font-Loading-API" class="headerlink" title="使用CSS Font Loading API"></a>使用CSS Font Loading API</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-keyword">@font-face</span>&#123;<br>  unicode-range：不一定字体中所有的文字都会用到，可以通过该属性定义的unicode字体范围<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用ajax-Base64加载字体（可以用，但不是最佳实践）"><a href="#使用ajax-Base64加载字体（可以用，但不是最佳实践）" class="headerlink" title="使用ajax+Base64加载字体（可以用，但不是最佳实践）"></a>使用ajax+Base64加载字体（可以用，但不是最佳实践）</h3><ul><li><p>解决兼容性问题</p></li><li><p>缺点：缓存问题</p></li></ul><h2 id="优化资源加载的顺序"><a href="#优化资源加载的顺序" class="headerlink" title="优化资源加载的顺序"></a>优化资源加载的顺序</h2><h3 id="资源优先级"><a href="#资源优先级" class="headerlink" title="资源优先级"></a>资源优先级</h3><p>浏览器默认安排资源加载优先级（始终优先加载HTML，根据HTML加载顺序进行加载，比如head内的资源优先级较高）</p><p>可以通过preload，prefetch调整优先级</p><ul><li><p>perload：提前加载较晚出现但对当前非常重要的资源。</p></li><li><p>perfetch：提前加载后继浏览器需要的资源，优先级低（因为是在有空闲的时候才会进行体前加载）</p></li></ul><p>在webpack中<a href="https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules">预获取/预加载模块</a>:使用<code>import(/* webpackPrefetch: true */ &#39;./component.js&#39;);</code></p>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源优化</tag>
      
      <tag>资源的压缩与合并</tag>
      
      <tag>图片优化</tag>
      
      <tag>字体优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之代码优化</title>
    <link href="/article/27abae9/"/>
    <url>/article/27abae9/</url>
    
    <content type="html"><![CDATA[<h2 id="JS开销和如何缩短解析时间"><a href="#JS开销和如何缩短解析时间" class="headerlink" title="JS开销和如何缩短解析时间"></a>JS开销和如何缩短解析时间</h2><h3 id="JS开销"><a href="#JS开销" class="headerlink" title="JS开销"></a>JS开销</h3><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/cost-of-javascript-2019.png" alt="js时间开销"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>网络加载方面：JS文件压缩 </p></li><li><p>编译和解析：代码拆分，按需加载</p></li><li><p>编译和解析：删除没必要的代码</p></li><li><p>执行：减少主线程工作量</p></li></ol><h3 id="减少主线程工作量"><a href="#减少主线程工作量" class="headerlink" title="减少主线程工作量"></a>减少主线程工作量</h3><ol><li><p>避免长任务（long task）</p></li><li><p>避免超过1kB的行间脚本</p></li><li><p>使用 rAF 和 rIC 进行时间调度</p></li></ol><h2 id="配合-V8-有效优化代码"><a href="#配合-V8-有效优化代码" class="headerlink" title="配合 V8 有效优化代码"></a>配合 V8 有效优化代码</h2><h3 id="V8编译原理"><a href="#V8编译原理" class="headerlink" title="V8编译原理"></a>V8编译原理</h3><ol><li><p>生成抽象语法树（AST）和执行上下文：先进行词法分析将源代码拆解成token。在进行语法分析，将token根据语法规则转化为AST。</p></li><li><p>生成字节码：会根据 AST 生成字节码，并解释执行字节码</p></li><li><p>执行代码：在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器就会把该段热点的字节码编译为机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。经过编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。</p></li></ol><p>eg.:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javaScript"><span class="hljs-keyword">const</span> &#123;performance,PerformanceObserver&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perf_hooks);</span><br><span class="hljs-string"></span><br><span class="hljs-string">const add = (a,b) =&gt; a + b;</span><br><span class="hljs-string"></span><br><span class="hljs-string">const num1 = 1;</span><br><span class="hljs-string">const numb = 2;</span><br><span class="hljs-string"></span><br><span class="hljs-string">performance.mark(&#x27;</span>start);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100000</span> ; i ++)&#123;<br>  add(num1,num2)<br>&#125;<br><span class="hljs-comment">//分别注释拼接字符串的代码进行时间比较，发现时间差距极大。</span><br>add(num1,<span class="hljs-string">&#x27;s&#x27;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100000</span> ; i ++)&#123;<br>  add(num1,num2)<br>&#125;<br><br>performance.mark(<span class="hljs-string">&#x27;end&#x27;</span>);<br><br><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function">(<span class="hljs-params">list</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(list.getEntries()[<span class="hljs-number">0</span>]);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>查看V8对哪些进行了优化，哪些进行了反优化可以执行<code>node --trace-opt --trace-deopt file.js</code></p><h3 id="V8优化机制"><a href="#V8优化机制" class="headerlink" title="V8优化机制"></a>V8优化机制</h3><ol><li><p>脚本流：下载的过程中对已经下载的足够大的js文件开辟新线程先解析，等都加载完后将全部解析结果合并。</p></li><li><p>字节码缓存</p></li><li><p>懒解析（lazy-parsing）：主要对于函数而言，先不解析函数内部逻辑，等用的时候在解析。</p></li></ol><h2 id="函数优化"><a href="#函数优化" class="headerlink" title="函数优化"></a>函数优化</h2><h3 id="函数的解析方式"><a href="#函数的解析方式" class="headerlink" title="函数的解析方式"></a>函数的解析方式</h3><ul><li><p>懒解析（lazy-parsing）：不会创建ast，会创建作用域，但不会在里面包含变量引用或者声明。</p></li><li><p>饥饿解析（eager-parsing）：会建立AST,创建完整的作用域，找出所有语法错误</p></li></ul><p>问题：一个马上要执行的函数在声明的时候会进行一个懒解析，发现是该函数要执行了，又会进行饥饿解析，效率降低。</p><p>eg.:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> main = <span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">//可通过将函数转为立即执行函数，告诉V8，add进行饥饿解析。</span><br>  <span class="hljs-comment">// const add =((a,b)=&gt;a+b);</span><br>  <span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b;<br>  <span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> num2 = <span class="hljs-number">2</span>;<br>  add(num1 + num2);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>问题：使用部分压缩工具（老版本的uglyfy 和 webpack等）时，可能会将上述括号取消掉。<br>解决：利用Optimize.js优化加载时间。（将括号再加回来）</p><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><h3 id="1-以相同顺序初始化对象成员，避免隐藏类的调整"><a href="#1-以相同顺序初始化对象成员，避免隐藏类的调整" class="headerlink" title="1. 以相同顺序初始化对象成员，避免隐藏类的调整"></a>1. 以相同顺序初始化对象成员，避免隐藏类的调整</h3><p>隐藏类可以理解为“按图索骥”中的图。提高对象属性的访问速度，快速存取对象属性，节省内存空间。</p><p>详细可看 <a href="https://www.cnblogs.com/chargeworld/p/12236848.html"> V8 中的对象表示 </a>。</p><p>文章 <a href="https://zhuanlan.zhihu.com/p/38202123"> JavaScript 引擎基础：Shapes 和 Inline Caches </a>中详细了隐藏类的相关内容。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectArea</span></span>&#123;<span class="hljs-comment">//HC0</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">l,w</span>)</span>&#123; <br>    <span class="hljs-built_in">this</span>.l = l;<span class="hljs-comment">//HC1</span><br>    <span class="hljs-built_in">this</span>.w = w;<span class="hljs-comment">//HC2</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//这种实例化时，rect2会复用rect1时产生的HC（hidden class）。</span><br><span class="hljs-keyword">const</span> rect1 = <span class="hljs-keyword">new</span> RectArea(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-keyword">const</span> rect2 = <span class="hljs-keyword">new</span> RectArea(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//反面例子</span><br><span class="hljs-keyword">const</span> car1 = &#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;; <span class="hljs-comment">//HC0</span><br>car1.seats = <span class="hljs-number">4</span>; <span class="hljs-comment">//HC1</span><br><br><span class="hljs-keyword">const</span> car2 = &#123;<span class="hljs-attr">seats</span>:<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//无法复用以上两种,创建新的HC2</span><br>cat2.color = <span class="hljs-string">&#x27;blue&#x27;</span>; <span class="hljs-comment">//HC3</span><br></code></pre></div></td></tr></table></figure><h3 id="2-实例化后避免添加新属性"><a href="#2-实例化后避免添加新属性" class="headerlink" title="2. 实例化后避免添加新属性"></a>2. 实例化后避免添加新属性</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> car1 = &#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>&#125;; <span class="hljs-comment">// In-object属性</span><br>car1.seats = <span class="hljs-number">4</span>; <span class="hljs-comment">//Normal/Fast属性，存储在property store里，需要通过描述数组简介查找</span><br></code></pre></div></td></tr></table></figure><h3 id="3-尽量使用Array代替array-like对象"><a href="#3-尽量使用Array代替array-like对象" class="headerlink" title="3. 尽量使用Array代替array-like对象"></a>3. 尽量使用Array代替array-like对象</h3><p>array-like对象：形如函数参数（arguments这种，有索引有length的对象）</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Array</span>.prototype.forEach.call(arrObj,<span class="hljs-function">(<span class="hljs-params">v,i</span>)=&gt;</span>&#123; <span class="hljs-comment">//不如在真实数组上效率高。</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;v&#125;</span>:<span class="hljs-subst">$&#123;i&#125;</span>`</span>)<br>&#125;)<br><br><span class="hljs-comment">//正确姿势</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrObj,<span class="hljs-number">0</span>);<span class="hljs-comment">//转换的代价比优化影响小</span><br>arr.forEach(<span class="hljs-function">(<span class="hljs-params">v,i</span>)=&gt;</span>&#123; <span class="hljs-comment">//不如在真实数组上效率高。</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;v&#125;</span>:<span class="hljs-subst">$&#123;i&#125;</span>`</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="4-避免读取超过数组的长度"><a href="#4-避免读取超过数组的长度" class="headerlink" title="4. 避免读取超过数组的长度"></a>4. 避免读取超过数组的长度</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt;= arr.length ; i++)&#123; <span class="hljs-comment">// 取值越界</span><br>    <span class="hljs-keyword">if</span>(array[i]&gt;<span class="hljs-number">1000</span>)&#123; <span class="hljs-comment">//1. undefined和1000 进行比较 2.沿原型链查找，造成额外的插销。</span><br>      <span class="hljs-built_in">console</span>.log(arr[i]);<span class="hljs-comment">// 业务上无效</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-避免元素类型转换"><a href="#5-避免元素类型转换" class="headerlink" title="5. 避免元素类型转换"></a>5. 避免元素类型转换</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]; <span class="hljs-comment">//类型：PACKED_SMI_ELEMENTS:满的_smallInt</span><br>array.push(<span class="hljs-number">4.4</span>); <span class="hljs-comment">//上述类型失效，类型变为：PACKED_DOUBLE_ELEMENTS</span><br></code></pre></div></td></tr></table></figure><p>避免 -0，除非你需要在代码中明确区分 -0 和 +0。</p><p>同样还有 NaN 和 Infinity。它们被表示为双精度，因此添加一个 NaN 或 Infinity 会将 SMI_ELEMENTS 转换为DOUBLE_ELEMENTS。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/lattice.png" alt="元素类型转换"></p><p>只能通过格子向下过渡。一旦将单精度浮点数添加到 Smi 数组中，即使稍后用 Smi 覆盖浮点数，它也会被标记为 DOUBLE。类似地，一旦在数组中创建了一个洞，它将被永久标记为有洞 HOLEY，即使稍后填充它也是如此。</p><p>越具体优化越多，越通用优化越小。</p><p>详细可见<a href="https://segmentfault.com/a/1190000023193375">你可能不知道的V8数组优化</a></p><h3 id="6-避免创建洞"><a href="#6-避免创建洞" class="headerlink" title="6. 避免创建洞"></a>6. 避免创建洞</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 此时，数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`</span><br>array[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 接着，这是一个字符串，而不是一个小整数...所以过渡到`HOLEY_ELEMENTS`。</span><br>array[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>array[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br><span class="hljs-comment">// 这时，数组中的所有三个位置都被填充，所以数组被打包（即不再稀疏）。</span><br><span class="hljs-comment">// 但是，我们无法转换为更具体的类型，例如 “PACKED_ELEMENTS”。</span><br><span class="hljs-comment">// 元素类保留为“HOLEY_ELEMENTS”。</span><br></code></pre></div></td></tr></table></figure><p>解决方案</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//方法1</span><br><span class="hljs-keyword">let</span> array = []<br>array.push(newElement) <span class="hljs-comment">//循环</span><br><span class="hljs-comment">// 方法2</span><br><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></div></td></tr></table></figure><h3 id="7-避免多态"><a href="#7-避免多态" class="headerlink" title="7. 避免多态"></a>7. 避免多态</h3><p>如果代码需要处理包含多种不同元素类型的数组，则可能会比单个元素类型数组要慢，因为代码要对不同类型的数组元素进行多态操作。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> each = <span class="hljs-function">(<span class="hljs-params">array, callback</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; array.length; ++index) &#123;<br>    <span class="hljs-keyword">const</span> item = array[index];<br>    callback(item);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> doSomething = <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(item);<br><br><br>each([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], doSomething);<br>each([<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>], doSomething);<br>each([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], doSomething);<br></code></pre></div></td></tr></table></figure><p>调用了<code>each</code>3次，并且每次都没有给它相同的元素类型，在V8中，它采用内联缓存（Inline Caches，简称 IC）来缓存调用的实现以优化这些操作的执行过程。<br>当第一次只传入类型为<code>packed_smi_element</code>的<code>[1,2,3]</code>，v8会使用IC来缓存这个方法的调用，记录元素类型以及其他信息，那么下一次传入<code>packed_smi_element</code>时，直接就可以从缓存里取到优化后的调用方法，然后进行调用。<br>但是第二次如果传入的不一样的元素类型，比如<code>packed_double_number</code>，那么v8又会重新缓存一个新的调用实现（适用于<code>packed_double_number</code>），那么传入元素的时候就需要进行2次判断了，先判断是不是smi，如果不是，就判断是不是packed_double_number，如果是其他，那么又会重新缓存一个新的调用实现.优化与反优化</p><h2 id="HTML优化"><a href="#HTML优化" class="headerlink" title="HTML优化"></a>HTML优化</h2><ul><li><p>减少iframes使用。必要使用时，先建立个空iframe，延迟或在合适的时机使用<code>setAttribute</code>赋值<code>src</code></p></li><li><p>压缩空白符</p></li><li><p>避免节点深层级嵌套</p></li><li><p>避免table布局</p></li><li><p>删除注释（和压缩空白符一个道理，压缩文件）</p></li><li><p>CSS&amp;JavaSCript尽量外链（避免HTML大文件）</p></li><li><p>标签语义化（1.方便人看懂代码 2.方便浏览器针对标签做的优化）</p></li><li><p>JS文件放到尾部（加载JS是阻塞的，会阻塞渲染）</p></li></ul><h2 id="CSS对性能的影响"><a href="#CSS对性能的影响" class="headerlink" title="CSS对性能的影响"></a>CSS对性能的影响</h2><h3 id="利用DevTools测量样式开销"><a href="#利用DevTools测量样式开销" class="headerlink" title="利用DevTools测量样式开销"></a>利用DevTools测量样式开销</h3><h3 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h3><ul><li><p>降低CSS对渲染的阻塞（1.尽量早的去下载CSS 2.降低CSS文件大小，仅加载首屏需要的CSS，不需要的延迟加载）</p></li><li><p>利用GPU进行完成动画（单独出一个层，不影响布局与绘制）</p></li><li><p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain">contain</a>属性（减少重绘与回流）</p></li><li><p>使用font-display属性（让文字更早的显示在页面上，减轻字体闪动）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之渲染优化</title>
    <link href="/article/41870d4/"/>
    <url>/article/41870d4/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染过程（对应面试题：从用户输入url到显示都发生了什么）"><a href="#浏览器渲染过程（对应面试题：从用户输入url到显示都发生了什么）" class="headerlink" title="浏览器渲染过程（对应面试题：从用户输入url到显示都发生了什么）"></a>浏览器渲染过程（对应面试题：从用户输入url到显示都发生了什么）</h2><ol start="0"><li><p>省略网络相关部分。</p></li><li><p>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</p></li><li><p>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</p></li><li><p>创建布局树，并计算元素的布局信息。</p></li><li><p>对布局树进行分层，并生成分层树。</p></li><li><p>为每个图层生成绘制列表，并将其提交到合成线程。</p></li><li><p>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</p></li><li><p>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</p></li><li><p>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</p></li></ol><p>主流程：DOM -》Style-》Layout-》Layer-》Paint</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="重排（回流）和重绘"><a href="#重排（回流）和重绘" class="headerlink" title="重排（回流）和重绘"></a>重排（回流）和重绘</h3><p>通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段（即从上文序号2开始），这个过程就叫重排。</p><p>通过 JavaScript 或者 CSS 修改元素没有引起几何位置的变换（即绘制属性（元素的颜色、背景色、边框等）），布局阶段将不会被执行，直接进入了绘制阶段，然后执行之后的一系列子阶段（即跳过序号3，4），这个过程就叫重绘。</p><h3 id="影响重排（回流）的操作"><a href="#影响重排（回流）的操作" class="headerlink" title="影响重排（回流）的操作"></a>影响重排（回流）的操作</h3><ul><li><p>添加/删除元素</p></li><li><p>操作styles</p></li><li><p>display:none</p></li><li><p>offsetLeft,scrollTop,clientWidth</p></li><li><p>移动元素位置</p></li><li><p>修改浏览器大小，字体大小。</p></li></ul><p>批量添加DOM时可以使用DocumentFragment</p><h3 id="避免Layout-thrashing"><a href="#避免Layout-thrashing" class="headerlink" title="避免Layout thrashing"></a>避免Layout thrashing</h3><ul><li><p>避免重排（回流）</p></li><li><p>读写分离：FastDom，原理：读写分离，批量操作，使用window.requestAnimationFrame。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/life-of-a-frame.png" alt="帧的生命周期"></p><h3 id="减少重绘的方案"><a href="#减少重绘的方案" class="headerlink" title="减少重绘的方案"></a>减少重绘的方案</h3><ul><li><p>利用DevTools识别paint的瓶颈</p></li><li><p>利用will-change创建新图层</p></li></ul><h3 id="触发合成过程的属性"><a href="#触发合成过程的属性" class="headerlink" title="触发合成过程的属性"></a>触发合成过程的属性</h3><p>渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。</p><ul><li><p>位置：transform：translate</p></li><li><p>缩放：transform：scale</p></li><li><p>旋转：transform：rotate</p></li><li><p>透明度：opacity</p></li></ul><h3 id="使用Flexbox优化布局"><a href="#使用Flexbox优化布局" class="headerlink" title="使用Flexbox优化布局"></a>使用Flexbox优化布局</h3><p>栅格方案性能对比（float vs flex）：分别用float 和 flex实现渲染10w个大小一样的div块，然后使用ChromDevTools-Performance进行查看</p><ul><li><p>float：rendering（Recalculate+Layout）：1804ms Painting：60ms</p></li><li><p>flex：rendering（Recalculate+Layout）：1267ms Painting：34ms</p></li></ul><p>flexbox优势：</p><ul><li><p>更高性能的实现方式</p></li><li><p>容器有能力决定子元素的大小，顺序，对齐，间隔等。</p></li><li><p>双向布局</p></li></ul><h2 id="高频事件处理"><a href="#高频事件处理" class="headerlink" title="高频事件处理"></a>高频事件处理</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</p><p>比如当监听鼠标移动等事件时：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//用来表示事件是否在执行中。</span><br><span class="hljs-keyword">let</span> enabled =<span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;pointermove&quot;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(enabled) <span class="hljs-keyword">return</span>;<br>  enabled = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画</span><br>  <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function">()=&gt;</span>&#123;<br>    changeWidth();<br>    enabled = <span class="hljs-literal">false</span>;<br>  &#125;)<br>&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//节流</span><br><span class="hljs-keyword">let</span> enabled = <span class="hljs-literal">true</span>;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;pointermove&quot;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(enabled)&#123;<br>    enabled = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">window</span>.requestAnimationFrame (<span class="hljs-function">()=&gt;</span>&#123;<br>        changeWidth();<br>    &#125;)<br>    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function">()=&gt;</span>enbled = <span class="hljs-literal">true</span>,<span class="hljs-number">50</span>)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="React时间调度实现"><a href="#React时间调度实现" class="headerlink" title="React时间调度实现"></a>React时间调度实现</h2><p>React Fiber：把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li><p>requestIdleCallback的问题：兼容性不好。在浏览器的空闲时段内调用的函数排队，能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件。</p></li><li><p>通过rAF模拟rIC：在requestAnimationFrame获取一桢的开始时间，触发一个postMessage，在空闲的时候调用idleTick来完成异步任务。</p></li></ul><h2 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h2><p>react可以使用<a href="https://www.npmjs.com/package/react-snap">react-snap</a></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> &#123; hydrate, render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br> <br><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-comment">//如果有子节点，表示经历过了ssr</span><br><span class="hljs-keyword">if</span> (rootElement.hasChildNodes()) &#123;<br>  <span class="hljs-comment">// 通过该方法进行补水</span><br>  hydrate(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>原理：使用 Headless Chrome爬取页面的内容（模拟搜索引擎的爬虫？），然后内容直接放到build的html中。</p><h3 id="预渲染的作用"><a href="#预渲染的作用" class="headerlink" title="预渲染的作用"></a>预渲染的作用</h3><ul><li><p>大型单页应用的性能瓶颈：JS下载+解析+执行</p></li><li><p>SSR的主要问题：牺牲TTFB来补救First Paint；实现复杂；</p></li><li><p>Pre-rendering打包时提前渲染页面，没有服务端参与。</p></li></ul><p>可能存在的问题：</p><ul><li>内联样式，不经过配置会出现明显的样式闪动。（可以针对首屏把CSS提取出来内嵌到HTML中，剩下的CSS用webpack提取到文件中，进行缓存）</li></ul><h2 id="可视化窗口（windowing）提高列表性能-虚拟列表"><a href="#可视化窗口（windowing）提高列表性能-虚拟列表" class="headerlink" title="可视化窗口（windowing）提高列表性能 - 虚拟列表"></a>可视化窗口（windowing）提高列表性能 - 虚拟列表</h2><p><a href="https://www.npmjs.com/package/react-window">react-window</a></p><ul><li><p>只渲染可见的行，渲染和滚动的性能都会提升</p></li><li><p>减少了呈现初始视图和处理更新所需的工作量和时间</p></li><li><p>避免了 DOM 节点的过度分配，从而减少了内存占用（Lazy loading时，dom会变得非常大）</p></li></ul><h2 id="使用骨架组件减少布局移动（Layout-shift）"><a href="#使用骨架组件减少布局移动（Layout-shift）" class="headerlink" title="使用骨架组件减少布局移动（Layout shift）"></a>使用骨架组件减少布局移动（Layout shift）</h2><p>主要作用就是占位，与要显示的组件大小一样大，等数据加载完成后再显示数据。可以提升用户感知性能</p><h2 id="首屏渲染优化方案"><a href="#首屏渲染优化方案" class="headerlink" title="首屏渲染优化方案"></a>首屏渲染优化方案</h2><p>首屏 - 用户加载的3个关键时刻</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/Loading-is-a-journey.png" alt="用户加载的3个关键时刻"></p><p>对应的测量指标：</p><ul><li><p>First Contentful Paint（FCP）—– is it happening？（网络请求是否发送出去了？）</p></li><li><p>Largest Contentful Paint（LCP）—– is it useful？（网页内容是否对我有用？）</p></li><li><p>Time To Interactive （TTI） —– is it usable？（是否可以交互了？）</p></li></ul><p>方案：</p><ul><li><p>资源体积太大？资源压缩，传输压缩，代码拆分，Tree shaking，HTTP/2，缓存</p></li><li><p>首页内容太多？路由/组件/内容懒加载，预渲染/SSR，Inline CSS</p></li><li><p>加载顺序不合适？ prefetch，preload</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器渲染原理</tag>
      
      <tag>重排和重绘</tag>
      
      <tag>预渲染</tag>
      
      <tag>首屏渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化之性能优化的指标与工具</title>
    <link href="/article/bc89d796/"/>
    <url>/article/bc89d796/</url>
    
    <content type="html"><![CDATA[<p>TODO: 更新ChromeDevTools使用说明，以及各项参数说明</p><h2 id="性能优化的意义"><a href="#性能优化的意义" class="headerlink" title="性能优化的意义"></a>性能优化的意义</h2><p>高性能意味着用户参与度提高，用户留存数提高，进而促进高转化率，seo排名也会提高。</p><h2 id="性能优化-加载指标"><a href="#性能优化-加载指标" class="headerlink" title="性能优化-加载指标"></a>性能优化-加载指标</h2><ul><li><p>Speed Index：测量页面加载过程中内容的可视化显示速度</p></li><li><p>TTFB：浏览器开始收到服务器响应数据的时间（后台处理时间+重定向时间），是反映服务端响应速度的重要指标。</p></li><li><p>Load（页面加载时间）：所有资源加载完毕需要的时间</p></li><li><p>First Contentful Paint（首次渲染耗时）：浏览器渲染第一段 DOM 内容所需要的时间</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/Loading-is-a-journey.png" alt="加载过程"></p><h2 id="性能优化-响应指标"><a href="#性能优化-响应指标" class="headerlink" title="性能优化-响应指标"></a>性能优化-响应指标</h2><ul><li><p>交互动作的反馈时间</p></li><li><p>帧率FPS</p></li><li><p>异步请求完成的时间</p></li></ul><h2 id="RAIL测量模型"><a href="#RAIL测量模型" class="headerlink" title="RAIL测量模型"></a>RAIL测量模型</h2><ul><li><p>R：Response 事件响应</p></li><li><p>A：Animation 动画过渡</p></li><li><p>I：Idle 空闲：主线程空闲</p></li><li><p>L：Load 加载：网络资源的加载</p></li></ul><h3 id="评估标准"><a href="#评估标准" class="headerlink" title="评估标准"></a>评估标准</h3><ul><li><p>R：处理事件应在50ms以内完成</p></li><li><p>A：每10ms产生一帧</p></li><li><p>I：尽可能增加空闲时间</p></li><li><p>L：在5s内完成内容加载并可以交互</p></li></ul><h2 id="性能测量工具"><a href="#性能测量工具" class="headerlink" title="性能测量工具"></a>性能测量工具</h2><ul><li><p>Chrome DevTools：开发调试，性能测试</p></li><li><p>Lighthouse：网站整体质量评估</p></li><li><p>WebPageTest.org：多测试地点，全面性能报告</p></li></ul><h2 id="常用的性能测试API"><a href="#常用的性能测试API" class="headerlink" title="常用的性能测试API"></a>常用的性能测试API</h2><p>可以埋点进行性能监测。</p><p>各项指标主要是<code>performance.getEntriesByType(&#39;navigation&#39;)</code>下数据的计算，用于度量当前页面加载速度<br><code>performance.getEntriesByType(&#39;resource&#39;)</code>用于计算页面加载时请求资源的速度。</p><ul><li><p>DNS 解析耗时: domainLookupEnd - domainLookupStart</p></li><li><p>TCP 连接耗时: connectEnd - connectStart</p></li><li><p>SSL 安全连接耗时: connectEnd - secureConnectionStart</p></li><li><p>网络请求耗时 (TTFB): responseStart - requestStart</p></li><li><p>数据传输耗时: responseEnd - responseStart</p></li><li><p>DOM 解析耗时: domInteractive - responseEnd</p></li><li><p>资源加载耗时: loadEventStart - domContentLoadedEventEnd</p></li><li><p>First Byte时间: responseStart - domainLookupStart</p></li><li><p>白屏时间: responseEnd - fetchStart</p></li><li><p>首次可交互时间: domInteractive - fetchStart</p></li><li><p>DOM Ready 时间: domContentLoadEventEnd - fetchStart</p></li><li><p>页面完全加载时间: loadEventStart - fetchStart</p></li><li><p>http 头部大小： transferSize - encodedBodySize</p></li><li><p>重定向次数：performance.navigation.redirectCount</p></li><li><p>重定向耗时: redirectEnd - redirectStart</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//通过关键API获取长任务（long Task）列表</span><br><span class="hljs-comment">//观察者模式</span><br><span class="hljs-keyword">let</span> ob = <span class="hljs-keyword">new</span> PerformanceObserver(<span class="hljs-function">(<span class="hljs-params">list</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> list.getEntries())&#123;<br>        <span class="hljs-built_in">console</span>.log(entry)<br>    &#125;<br>&#125;)<br>ob.observe(&#123;<span class="hljs-attr">entryTypes</span>:[<span class="hljs-string">&quot;longtask&quot;</span>]&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//判断用户是否在看当前页面，如果没看可以断掉网络传输，保存当前状态。</span><br><span class="hljs-comment">// chrome</span><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;webkitvisbilitychange&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">//获取用户网络环境，根据用户网络环境进行资源的调整，如果图片的压缩。</span><br><span class="hljs-keyword">let</span> connection =navigator.connection || navigator.mozConnection || navigator.webkitConnection;<br><span class="hljs-keyword">let</span> type = connection.effectiveType;<br><span class="hljs-keyword">const</span> updateConnectionStatus = <span class="hljs-function">()=&gt;</span>&#123;&#125;<br>connection.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>,updateConnectionStatus);<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChromeDevTools</tag>
      
      <tag>LightHouse</tag>
      
      <tag>性能测量API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript之事件循环</title>
    <link href="/article/b561c95f/"/>
    <url>/article/b561c95f/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文摘抄自<a href="https://mp.weixin.qq.com/s/a6aFweCiLF0Mx03fARP8qQ">淘宝技术</a></p></blockquote><h2 id="事件循环是什么？"><a href="#事件循环是什么？" class="headerlink" title="事件循环是什么？"></a>事件循环是什么？</h2><p>在EcmaScript的标准定义中没有提到事件循环（Event Loop）这个定义，反而是HTML的标准定义中定义了事件循环。</p><blockquote><p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.</p></blockquote><p>根据标准中对事件循环的定义描述，发现事件循环本质上是user agent用于协调用户交互（鼠标、键盘）、脚本（如 JavaScript）、渲染（如 HTML DOM、CSS 样式）、网络等行为的一个机制。</p><p>各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：</p><ul><li><p>一个是 JavaScript 外部的队列。外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。</p></li><li><p>另一个是 JavaScript 内部的队列。这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。</p></li></ul><p>值得注意的是，虽然为了好理解管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的，而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的（比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。</p><h2 id="外部队列"><a href="#外部队列" class="headerlink" title="外部队列"></a>外部队列</h2><p>外部队列就是 JavaScript 外部的事件的队列，事件源主要有：</p><ul><li><p>DOM 操作 (页面渲染)</p></li><li><p>用户交互 (鼠标、键盘)</p></li><li><p>网络请求 (Ajax 等)</p></li><li><p>History API 操作</p></li><li><p>定时器 (setTimeout 等) </p></li></ul><p>HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。不同事件源的队列可以有不同的优先级（例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。</p><h2 id="内部队列"><a href="#内部队列" class="headerlink" title="内部队列"></a>内部队列</h2><p>内部队列（Microtask Queue），即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：</p><ul><li><p>Promise 的成功 (.then) 与失败 (.catch)</p></li><li><p>MutationObserver</p></li><li><p>Object.observe (已废弃)</p></li></ul><h2 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h2><p>在标准定义中事件循环的步骤比较复杂，这里我们简单描述一下这个处理过程：</p><ol><li><p>从外部队列中取出一个可执行任务，如果有则执行，没有下一步。</p></li><li><p>挨个取出内部队列中的所有任务执行，执行完毕或没有，则下一步。</p></li><li><p>浏览器渲染。</p></li></ol><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222142647.png" alt="事件循环简化模型"></p><p>由上文标准中提到的标准可知：JavaScript 的执行也是一个浏览器发起的外部事件。</p><p>所以本质的执行顺序是：</p><ol><li><p>一次外部事件</p></li><li><p>所有内部事件</p></li><li><p>HTML 渲染</p></li><li><p>回到到 1</p></li></ol><p>eg.:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">const</span> main = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#main&#x27;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">const</span> callback = <span class="hljs-function">(<span class="hljs-params">i, fn</span>) =&gt;</span> <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(i)</span><br><span class="javascript">            main.innerText += fn(i);</span><br><span class="javascript">        &#125;;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;</span><br><span class="javascript">        <span class="hljs-keyword">while</span>(i++ &lt; <span class="hljs-number">5000</span>) &#123;</span><br><span class="javascript">            <span class="hljs-built_in">setTimeout</span>(callback(i, <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> <span class="hljs-string">&#x27;\n&#x27;</span> + i + <span class="hljs-string">&#x27;&lt;&#x27;</span>))</span><br><span class="javascript">        &#125;</span><br><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">while</span>(i++ &lt; <span class="hljs-number">10000</span>) &#123;</span><br><span class="javascript">            <span class="hljs-built_in">Promise</span>.resolve().then(callback(i, <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> i +<span class="hljs-string">&#x27;,&#x27;</span>))</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(i)</span><br><span class="javascript">        main.innerText += <span class="hljs-string">&#x27;[end &#x27;</span> + i + <span class="hljs-string">&#x27; ]\n&#x27;</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ol><li><p>JavaScript 执行完毕 innerText 首先加上 [end 10001]</p></li><li><p>内部队列：Promise 的 then 全部任务执行完毕，往 innerText 上追加了很长一段字符串</p></li><li><p>HTML 渲染：1 和 2 追加到 innerText 上的内容同时渲染</p></li><li><p>外部队列：挨个执行 setTimeout 中追加到 innerText 的内容</p></li><li><p>HTML 渲染：将 4 中的内容渲染。</p></li><li><p>回到第 4 步走外部队列的流程（内部队列已清空）</p></li></ol><h2 id="浏览器与-Node-js-的事件循环差异"><a href="#浏览器与-Node-js-的事件循环差异" class="headerlink" title="浏览器与 Node.js 的事件循环差异"></a>浏览器与 Node.js 的事件循环差异</h2><p>浏览端是将 JavaScript 集成到 HTML 的事件循环之中，Node.js 则是将 JavaScript 集成到 libuv 的 I/O 循环之中。</p><p>HTML (浏览器端) 与 libuv (服务端) 面对的场景有很大的差异。首先能直观感受到的区别是：</p><ul><li><p>事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。</p></li><li><p>外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。</p></li><li><p>内部队列的事件仅剩下 Promise 的 then 和 catch。</p></li></ul><p>Node.js （libuv）在最初设计的时候是允许执行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部事件。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timer1&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timer2&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>这个例子在浏览器端执行的结果是 timer1 -&gt; promise1 -&gt; timer2 -&gt; promise2，而在 Node.js 早期版本（11 之前）执行的结果却是 timer1 -&gt; timer2 -&gt; promise1 -&gt; promise2。</p><h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><ol><li><p>外部队列：代码执行，两个 timeout 加入外部队列</p></li><li><p>内部队列：空</p></li><li><p>外部队列：第一个 timeout 执行，promise 加入内部队列</p></li><li><p>内部队列：执行第一个 promise</p></li><li><p>外部队列：第二个 timeout 执行，promise 加入内部队列</p></li><li><p>内部队列：执行第二个 promise</p></li></ol><h3 id="Node-js-服务端"><a href="#Node-js-服务端" class="headerlink" title="Node.js 服务端"></a>Node.js 服务端</h3><ol><li><p>外部队列：代码执行，两个 timeout 加入外部队列</p></li><li><p>内部队列：空</p></li><li><p>外部队列：两个 timeout 都执行完</p></li><li><p>内部队列：两个 promise 都执行完</p></li></ol><p>setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout 指定的延迟时间是毫秒（ms）但实际一次时间循环的时间可能是纳秒级的，所以在一次事件循环的多个外部队列中，找到某一个队列直接执行其中的 callback 可以得到比 setTimeout 更早执行的效果。我们继续以开始的场景构造一个例子，并在 Node.js 10.x 的版本上执行</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout1&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>));<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout2&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>));<br>&#125;);<br><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate1&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise3&#x27;</span>));<br>&#125;);<br><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate2&#x27;</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise4&#x27;</span>));<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><ol><li>setImmediate1</li><li>setImmediate2</li><li>promise3</li><li>promise4</li><li>setTimeout1</li><li>setTimeout2</li><li>promise1</li><li>promise2</li></ol><p>这里 setTimeout 在 setImmediate 后面执行的原因是因为 ms 精度的问题，想要手动 fix 这个精度可以插入一段 const now = Date.now(); wihle (Date.now() &lt; now + 1) {} 即可看到 setTimeout 在 setImmediate 之前执行了。</p><p>根据这个执行结果，我们可以推测出 Node.js 中的事件循环与浏览器类似，也是外部队列与内部队列的循环，而 setImmediate 在另外一个外部队列中。</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222143802.png" alt="Node.js事件循环图"></p><p>接下来，我们再来看一下当 Node.js 在与浏览器端对齐了事件循环的事件之后，这个例子的执行结果为：</p><ol><li>setImmediate1</li><li>promise3</li><li>setImmediate2</li><li>promise4</li><li>setTimeout1</li><li>promise1</li><li>setTimeout2</li><li>promise2</li></ol><p>其中主要有两点需要关注，一是外部队列在每次事件循环只执行了一个，另一个是 Node.js 固定了多个外部队列的优先级。setImmediate 的外部队列没有执行完的时候，是不会执行 timeout 的外部队列的。了解了这个点之后，Node.js 的事件循环就变得很简单了，我们可以看下 Node.js 官方文档中对于事件循环顺序的展示：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222143917.png" alt="Node.js官方文档之事件循环"></p><p>其中 check 阶段是用于执行 setImmediate 事件的。结合本文上面的推论我们可以知道，Node.js 官方这个所谓事件循环过程，其实只是完整的事件循环中 Node.js 的多个外部队列相互之间的优先级顺序。</p><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setImmediate&#x27;</span>);<br>&#125;);<br><br>fs.readdir(__dirname, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fs.readdir&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>输出：</p><blockquote><ol><li>promise</li><li>setTimeout</li><li>fs.readdir</li><li>setImmediate</li></ol></blockquote><p>根据输出结果，我们可以梳理出来：</p><ol><li><p>外部队列：执行当前 script</p></li><li><p>内部队列：执行 promise</p></li><li><p>外部队列：执行 setTimeout</p></li><li><p>内部队列：空</p></li><li><p>外部队列：执行 fs.readdir</p></li><li><p>内部队列：空</p></li><li><p>外部队列：执行 check （setImmediate）</p></li></ol><p>这个顺序符合 Node.js 对其外部队列的优先级定义：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222145007.png" alt="第一部分"></p><p>timer（setTimeout）是第一阶段的原因在 libuv 的文档中有描述 —— 为了减少时间相关的系统调用（System Call）。setImmediate 出现在 check 阶段是蹭了 libuv 中 poll 阶段之后的检查过程（这个过程放在 poll 中也很奇怪，放在 poll 之后感觉比较合适）。</p><p>idle, prepare 对应的是 libuv 中的两个叫做 idle 和 prepare 的句柄。由于 I/O 的 poll 过程可能阻塞住事件循环，所以这两个句柄主要是用来触发 poll （阻塞）之前需要触发的回调：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222145015.png" alt="第二部分"></p><p>由于 poll 可能 block 住事件循环，所以应当有一个外部队列专门用于执行 I/O 的 callback ，并且优先级在 poll 以及 prepare to poll 之前。</p><p>另外我们知道网络 IO 可能有非常多的请求同时进来，如果该阶段如果无限制的执行这些 callback，可能导致 Node.js 的进程卡死该阶段，其他外部队列的代码都没发执行了。所以当前外部队列在执行一定数量的 callback 之后会截断。由于截断的这个特性，这个专门执行 I/O callbacks 的外部队列也叫 pengding callbacks：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2021/02/22/20210222145027.png" alt="完整"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>enzyme学习记录之Shallow,Mount,render的区别</title>
    <link href="/article/d1e3eefb/"/>
    <url>/article/d1e3eefb/</url>
    
    <content type="html"><![CDATA[<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Render react components to static HTML and analyze the resulting HTML structure.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>&lt;<span class="hljs-title">P</span>, <span class="hljs-title">S</span>&gt;(<span class="hljs-params">node: ReactElement&lt;P&gt;, options?: any</span>): <span class="hljs-title">cheerio</span>.<span class="hljs-title">Cheerio</span></span>;<br><br></code></pre></div></td></tr></table></figure><p>通过跟进方法可以看到注释表明：是将React组件渲染为HTML结构。<br>通过查阅资料又得出：该render方法仅调用组件内的render方法，但是会渲染全部的子组件</p><h2 id="shallow"><a href="#shallow" class="headerlink" title="shallow"></a>shallow</h2><p>浅渲染，一个真正的单元测试。子组件并不会渲染。渲染的结果为React树。<br>在调用该方法时，会调用组件内的生命周期：<code>constructor</code>和<code>render</code>。<br>在使用该方法渲染后会得到一个：<code>ShallowWrapper</code>,<code>ShallowWrapper</code>内部又包含又<code>setProps</code>方法，在调用<code>setProps</code>方法时，则会调用生命周期： </p><ul><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code><br>当<code>ShallowWrapper</code>调用<code>unmount</code>方法时，仅调用生命周期的<code>componentWillUnmount</code></li></ul><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>测试<code>componentDidMount</code>和<code>componentDidUpdate</code>的唯一方式，会渲染包括子组件在内的所有组件。渲染结果为React树<br>在调用该方法时，会调用组件内的生命周期</p><ul><li><code>constructor</code></li><li><code>render</code></li><li><code>componentDidMount</code><br>使用<code>mount</code>的返回值为<code>ReactWrapper</code>，也可以调用<code>setProps</code>方法，调用的生命周期为</li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code><br>在使用<code>unmount</code>时，</li><li><code>componentWillUnmount</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果需要测试<code>componentDidMount</code>和<code>componentDidUpdate</code>，就使用<code>mount</code></li><li>如果没必要渲染子组件，使用<code>shallow</code></li><li>如果不涉及到生命周期函数，使用<code>render</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化测试</tag>
      
      <tag>jest</tag>
      
      <tag>enzyme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>travis-ci学习记录</title>
    <link href="/article/1dae22d5/"/>
    <url>/article/1dae22d5/</url>
    
    <content type="html"><![CDATA[<p>名词解释大部分均为机器直翻，部分稍加个人理解</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>job：一个自动化的过程，克隆存储库到一个虚拟环境，然后执行一系列的<em>phases</em>，如编译代码，运行测试等。如果<code>script</code>阶段的返回代码非零，则作业失败。</li><li>phase：<em>job</em>的连续步骤。例如，<code>install</code>阶段在<code>script</code>阶段之前，<code>script</code>阶段在可选的<code>deploy</code>阶段之前。</li><li>build：按顺序运行的一组<em>job</em>。例如，一个<em>build</em>可能有两个<em>job</em>，每个<em>job</em>用不同版本的编程语言测试一个项目。当所有的<em>job</em>都完成时，<em>build</em>就结束了。</li><li>stage：<em>build stages</em>是对<em>job</em>进行分组的一种方法，并且在每个<em>stage</em>中并行运行<em>job</em>，但是要按顺序运行<em>stage</em>。</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><code>apt addons</code> - 可选，用来添加apt源、apt包等</li><li><code>cache component</code> - 可选，用来设置缓存不经常更改的东西，加快构建速度</li><li><code>before_install</code> - 在<code>install</code>之前</li><li><code>install</code> - 安装需要的依赖，可以指定自己的脚本来安装依赖，否则取决于语言</li><li><code>before_script</code> - 在<code>script</code>之前</li><li><code>script</code> - 运行构建脚本</li><li><code>before_cache</code> - 可选，当切仅当缓存生效时</li><li><code>after_success</code> 或<code>after_failure</code> - 当构建成功/失败后，结果保存在<code>TRAVIS_TEST_RESULT</code>环境变量中。</li><li><code>before_deploy</code> - 可选，当且仅当部署处于活动状态</li><li><code>deploy</code> - 可选，部署</li><li><code>after_deploy</code> - 可选，当且仅当部署处于活动状态</li><li><code>after_script</code> - 在<code>script</code>之后</li></ol><h3 id="中断构建"><a href="#中断构建" class="headerlink" title="中断构建"></a>中断构建</h3><ul><li>如果<code>befor_install</code>、<code>install</code>和<code>before_script</code>返回一个非0的退出码，则构建出错并且立即退出。</li><li>如果<code>script</code>返回非零退出码，则构建失败，但在被标记为失败之前继续运行。</li><li><code>after _ success</code>、<code>after _ failure</code>、<code>after _ script</code>、<code>after _ deploy</code> 和后续阶段的退出代码不影响构建结果。但是，如果其中一个阶段超时，构建将被标记为失败。</li></ul><h2 id="实践遇到的问题记录"><a href="#实践遇到的问题记录" class="headerlink" title="实践遇到的问题记录"></a>实践遇到的问题记录</h2><p>按照<a href="https://docs.travis-ci.com/user/deployment/npm/">发布npm</a>配置一个最简单的npm发布。</p><p>在配置中并未配置test阶段，但是travisCI会默认在执行完 <code>npm install</code>即 <code>install</code>阶段后执行 <code>npm run test</code>。一开始我在 <code>package.json</code>配置的 <code>&quot;test&quot;: &quot;npm run test is running!&quot;,</code>。看travis中的日志发现一直死循环在执行 <code>npm run test</code> ，原来这个在里面会转换成相应的命令，想输出配置信息应该 <code>&quot;test&quot;: &quot;echo \&quot; ci run success \&quot;&quot;</code></p>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>持续化集成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚手架开发记录</title>
    <link href="/article/ffeb6d55/"/>
    <url>/article/ffeb6d55/</url>
    
    <content type="html"><![CDATA[<h1 id="脚手架开发记录"><a href="#脚手架开发记录" class="headerlink" title="脚手架开发记录"></a>脚手架开发记录</h1><ul><li><input checked="" disabled="" type="checkbox"> 输入模块</li><li><input checked="" disabled="" type="checkbox"> 输出模块</li><li><input checked="" disabled="" type="checkbox"> git操作模块</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先初始化项目 <code>npm init</code></p><p>在 <code>package.json</code>中添加脚本的入口文件，</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;bin&quot;</span>:&#123;<br>    <span class="hljs-attr">&quot;acbg&quot;</span>:&#x27;bin/init.js&#x27; <span class="hljs-comment">//格式为“命令名”：“入口文件相对package.json的路径”</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>建立入口文件 <code>mkdir bin &amp;&amp; touch bin/init.js</code></p><p>在init.js文件中输入：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">#!/usr/bin/env node</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello,Cli&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p><strong>入口文件的第一行一定要添加 <code>#!/usr/bin/env node</code> ，这行代码的意思是指定脚本使用node运行，即当我们输入 <code>acbg</code>时实际上运行的是 <code>node acbg</code></strong></p><p><em>env中包含了许多系统环境变量，<code>/usr/bin/env node</code>使用这个是为了防止用户没有将node安装在默认的/usr/bin下，当系统看到这一行的时候，首先会找到env里面的node安装路径，在调取node。</em></p><p>通过 <code>package.json</code>配置我们需要的文件（或者是去除不需要的），<strong>一定要去除node_modules,不然link的时候会巨慢</strong></p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;files&quot;</span>:[<span class="hljs-string">&quot;./bin&quot;</span>,<span class="hljs-string">&quot;./src&quot;</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p><em>也可以通过 <code>.gitignore</code>或 <code>.npmrc</code>等配置文件忽略。</em></p><p>为了方便在本地测试，在当前项目根目录下执行 <code>npm link</code></p><p><em><code>npm link</code>在全局node包内建立了当前项目的替身，当访问到全局node包中的当前项目时会转到当前项目实际所在路径,可以简单的理解为相当于执行了 <code>npm install -g 当前项目</code></em></p><p>在终端运行 <code>acbg</code>测试命令是否成功。</p><h2 id="分析工具逻辑"><a href="#分析工具逻辑" class="headerlink" title="分析工具逻辑"></a>分析工具逻辑</h2><p>目标：用户在运行cli后输入一些值，可以批量在gitlab上对应项目建立新的分支。</p><p>首先将工具分为两部分，工具内部与工具外部（即需要人工干预操作输入的）。</p><p>在分析工具外部时，可以将工具内部当成黑盒，只关心输入与输出。</p><p>外部流程：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2020/11/24/%E5%A4%96%E9%83%A8%E6%B5%81%E7%A8%8B.png" alt="外部流程"></p><p>内部流程：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2020/11/24/%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B.png" alt="内部流程"></p><p>通过流程图推算出需要做的模块：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2020/11/24/%E6%A8%A1%E5%9D%97.png" alt="模块"></p><p>由模块图可以得出需要做的功能，按照这些模块分别实现对应的函数就可以了。</p><h2 id="命令行交互"><a href="#命令行交互" class="headerlink" title="命令行交互"></a>命令行交互</h2><p>命令行交互使用<a href="https://www.npmjs.com/package/inquirer">inquirer</a>。</p><p>具体例子可以看链接内官方提供的示例。</p><p>输入gitlab地址模块：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;inquirer&#x27;</span>);<br><span class="hljs-keyword">const</span> CONFIG = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config&#x27;</span>).CONFIG;<br><br><span class="hljs-keyword">const</span> getAddress = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> inquirer.prompt(&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;address&#x27;</span>,<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入gitlab地址&#x27;</span><br>  &#125;).then(<span class="hljs-function">(<span class="hljs-params">ans</span>) =&gt;</span> &#123;<br>    CONFIG.address = ans.address;<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其他输入模块也按照这样子做出来。</p><h2 id="工具处理过程"><a href="#工具处理过程" class="headerlink" title="工具处理过程"></a>工具处理过程</h2><h3 id="获取与token对应地址下的项目信息"><a href="#获取与token对应地址下的项目信息" class="headerlink" title="获取与token对应地址下的项目信息"></a>获取与token对应地址下的项目信息</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getProjectInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">`https://gitlab.<span class="hljs-subst">$&#123;CONFIG.address&#125;</span>.com/api/v4/projects?private_token=<span class="hljs-subst">$&#123;CONFIG.token&#125;</span>`</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="将获取到的信息格式化输出"><a href="#将获取到的信息格式化输出" class="headerlink" title="将获取到的信息格式化输出"></a>将获取到的信息格式化输出</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//展示project信息</span><br><span class="hljs-keyword">const</span> showProjectInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; projectInfo &#125; = CONFIG;<br>  projectInfo.forEach(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`project ID:<span class="hljs-subst">$&#123;value.id&#125;</span>   project Name:<span class="hljs-subst">$&#123;value.name&#125;</span>    project repo:<span class="hljs-subst">$&#123;value.repo&#125;</span>`</span>);<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>tips:可以使用<a href="https://www.npmjs.com/package/chalk">chalk</a>来为控制台添加一点颜色更加美观。</p><h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><p>使用<a href="https://www.npmjs.com/package/download-git-repo">download-git-repo</a>来clone项目，具体使用方法可以查看说明页。基于该packages中的方法封装clone的方法</p><p>20201126更新：download-git-repo在使用过程中有一些问题，再加上这个工具仅需要使用clone功能，因此改成<a href="https://www.npmjs.com/package/git-clone">git-clone</a>这个库。</p><p>download-git-repo遇到的问题：</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2020/11/26/1606398697.png" alt="image.png"></p><p>在设置第三个参数为 <code>clone:true</code>后，在没有报错的情况下会引起 <code>.git</code>信息被删除，致使后续操作无法进行。</p><p>原代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> downloadRepo = <span class="hljs-function">(<span class="hljs-params">repo, name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    download(<span class="hljs-string">`direct:<span class="hljs-subst">$&#123;repo&#125;</span>`</span>, name, &#123; <span class="hljs-attr">clone</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) reject(err);<br>      resolve(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>新代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cloneRepo = <span class="hljs-function">(<span class="hljs-params">repo, name</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    gitClone(repo, name, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!!err) reject(err);<br>      resolve(<span class="hljs-string">&#x27;download success&#x27;</span>);<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="封装执行shell命令方法"><a href="#封装执行shell命令方法" class="headerlink" title="封装执行shell命令方法"></a>封装执行shell命令方法</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> runCMD = <span class="hljs-function">(<span class="hljs-params">cmd</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    childProcess.exec(cmd, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!!err) reject(err);<br>      resolve(<span class="hljs-string">&#x27;run CMD success&#x27;</span>)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>后续的打开项目目录，切换到源分支，拉取新分支，推送到远端都可以调用这个方法来做到，因为这些指令之间是有先后顺序依赖关系的，所以封装成一个promise。</del></p><p>20201126更新：本想再将runCMD封装成多个方法，然后将他们链式调用，结果因为childProcess每个命令不在一个进程里，所以失败。</p><h2 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h2><p>以上步骤已经将所需要的积木准备好，现在只需要将积木拼在一起就可以形成完成的cli了。</p><p>完成品可见：<a href="https://github.com/AruSeito/all-checkout-gitlab">all-checkout-branch</a></p><h2 id="持续优化项"><a href="#持续优化项" class="headerlink" title="持续优化项"></a>持续优化项</h2><ul><li><input checked="" disabled="" type="checkbox"> CI/CD。（20201130完成简单的CI，记录可见<a href="https://aruseito.github.io/2021/02/15/travis-ci-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">CI</a>）</li></ul>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>nodejs</tag>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入浅出 React 和 Redux》 读书笔记</title>
    <link href="/article/d130c1af/"/>
    <url>/article/d130c1af/</url>
    
    <content type="html"><![CDATA[<h1 id="《深入浅出-React-和-Redux》-读书笔记"><a href="#《深入浅出-React-和-Redux》-读书笔记" class="headerlink" title="《深入浅出 React 和 Redux》 读书笔记"></a>《深入浅出 React 和 Redux》 读书笔记</h1><p>React 与 Redux 的核心：UI=render(state)</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="关于-prop-与-state"><a href="#关于-prop-与-state" class="headerlink" title="关于 prop 与 state"></a>关于 prop 与 state</h3><ul><li>prop 用于定义外部接口，state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时，state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>React 生命周期可能会经历如下三个阶段：</p><ul><li>装载过程（Mount）：把组件第一次在 DOM 树中渲染的过程</li><li>更新过程（Update）：当组件被重新渲染的过程</li><li>卸载过程（Unmount）：组件从 DOM 中删除的过程</li></ul><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><p>装在过程中会依次调用以下函数：</p><ul><li>constructor</li><li>getInitialState</li><li>getDefaultProps</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>创造一个组件类的实例，会调用对应的构造函数。无状态的 React 组件不需要定义构造函数。目的：</p><ul><li>初始化 state</li><li>绑定成员函数的 this 环境</li></ul><h5 id="getInitialState-和-getDefaultProps"><a href="#getInitialState-和-getDefaultProps" class="headerlink" title="getInitialState 和 getDefaultProps"></a>getInitialState 和 getDefaultProps</h5><p>getInitialState 这个函数的返回值会用来初始化组件的 this.state。getDefaultProps 函数的返回值可以作为 props 的初始值。这两个函数只有用 React.createClass 方法创造的组件类才会发生作用。getInitialState 只出现在装载过程中，在一个组件的整个生命周期过程中，这个函数只被调用一次。使用 Es6 的话，在构造函数中通过给 this.state 赋值完成状态的初始化，通过给类属性 defaultProps 赋值指定 props 初始值。</p><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>render 函数并不做实际的渲染动作，它只是返回一个 jsx 描述的结构，最终由 React 来操作渲染过程。render 函数应该是一个纯函数。</p><h5 id="componentWillMount-和-componentDidMount"><a href="#componentWillMount-和-componentDidMount" class="headerlink" title="componentWillMount 和 componentDidMount"></a>componentWillMount 和 componentDidMount</h5><p>componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染结果。<br>当 render 函数被调用完之后，componentDidMount 函数并不会被立刻调用，componentDidMount 被调用的时候，render 函数返回的东西已经引发了渲染，组件已经被“装载”到了 DOM 树上。<br>componentWillMount 可以再服务器端被调用，也可以在浏览器端被调用；而 componentDidMount 只能在浏览器端被调用。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>更新过程中会依次调用以下函数（并不是所有更新都会执行全部函数）：</p><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul><h5 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h5><p>当父组件的 render 函数被调用就会调用该函数。这个函数适合根据新的 props 值（也就是参数 nextProps）来计算出是不是要更新内部状态 state。</p><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h5><p>这个函数返回一个布尔值，告诉 react库这个组件在这次更新过程中是否要继续。可以作为优化点。</p><h5 id="componentWillUpdate-和-componentDidUpdate"><a href="#componentWillUpdate-和-componentDidUpdate" class="headerlink" title="componentWillUpdate 和 componentDidUpdate"></a>componentWillUpdate 和 componentDidUpdate</h5><p>当在服务器端使用 React 渲染时，componentDidUpdate 函数，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端都会被调用。使用 React 做服务器渲染时，基本不会经历更新过程，正常情况下服务器端不会调用 componentDidUpdate</p><h4 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h4><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h5><p>componentWillUnmount中的工作往往和 componentDidMount 有关</p><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>redux 强调的三个基本原则：</p><ul><li>唯一数据源</li><li>保持状态可读</li><li>数据改变只能通过纯函数完成</li></ul><h3 id="使用-Redux-过程"><a href="#使用-Redux-过程" class="headerlink" title="使用 Redux 过程"></a>使用 Redux 过程</h3><ol><li>定义 ActionType 和 Action 构造函数。</li><li>创建 reducer，根据 actionType分发动作，reducer 只负责计算状态，不负责存储状态</li><li>确定 Store 状态，创建 Store</li><li>在 view 中，保持 sotre 上状态和 this.state 同步。</li><li>派发 action                </li></ol><h3 id="容器组件和傻瓜组件"><a href="#容器组件和傻瓜组件" class="headerlink" title="容器组件和傻瓜组件"></a>容器组件和傻瓜组件</h3><p>承担第一个任务的组件，负责和 Redux Store 打交道的组件，处于外层，叫做容器组件。承担第二个任务的组件，专心负责渲染页面的组件，处于内层，叫做展示组件。</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/09/29/rong-qi-zu-jian-he-sha-gua-zu-jian-de-fen-gong.png" alt="容器组件和傻瓜组件的分工"></p><p>傻瓜组件就是一个纯函数，根据 props 产生结果，不需要 state<br>容器组件，承担所有和 Store 关联的工作，它的 render 函数是渲染傻瓜组件，负责传递必要的 prop。</p><h3 id="组件-Context"><a href="#组件-Context" class="headerlink" title="组件 Context"></a>组件 Context</h3><p>目的：入口文件引入 Store，其余组件避免直接导入 Store</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/09/30/react-de-context.png" alt="React 的 Context"></p><p>使用：创建一个特殊的 React 组件，实现一个实例<code>getChildContext</code>方法，让其仅返回<code>store</code>，让 render 函数把子组件渲染出来。再定义 childContextTypes。子组件中也要定义相同的 childContextTypes，子组件中定义的构造函数参数要加上 context，store 的访问方式变为<code>this.context.store.xxx</code></p><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p>React-Redux 中的 connect：连接容器组件和傻瓜组件，Provider: 提供包含 Store 的 context</p><h2 id="模块化-React-和-Redux-应用"><a href="#模块化-React-和-Redux-应用" class="headerlink" title="模块化 React 和 Redux 应用"></a>模块化 React 和 Redux 应用</h2><h3 id="代码文件的组织方式"><a href="#代码文件的组织方式" class="headerlink" title="代码文件的组织方式"></a>代码文件的组织方式</h3><p>每个基本功能对应一个功能模块，每个模块对应一个目录</p><h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>明确这个模块的对外的接口，这个接口应实现把内部封装起来。</p><h3 id="状态树的设计"><a href="#状态树的设计" class="headerlink" title="状态树的设计"></a>状态树的设计</h3><ul><li>一个模块控制一个状态节点：如果 A 模块的 reducer 负责修改状态树上 a 字段下的数据，name 另一个模块 B 的 reducer 就不能修改 a 字段下的数据。</li><li>避免冗余数据</li><li>树形结构扁平</li></ul><h2 id="React-组件的性能优化"><a href="#React-组件的性能优化" class="headerlink" title="React 组件的性能优化"></a>React 组件的性能优化</h2><h3 id="性能分析（React-16-与-Chrome-开发者工具）"><a href="#性能分析（React-16-与-Chrome-开发者工具）" class="headerlink" title="性能分析（React 16 与 Chrome 开发者工具）"></a>性能分析（<a href="https://calibreapp.com/blog/react-performance-profiling-optimization/">React 16 与 Chrome 开发者工具</a>）</h3><h3 id="单个-React-组件的性能优化"><a href="#单个-React-组件的性能优化" class="headerlink" title="单个 React 组件的性能优化"></a>单个 React 组件的性能优化</h3><h4 id="React-Redux-的-shouldComponentUpdate-实现"><a href="#React-Redux-的-shouldComponentUpdate-实现" class="headerlink" title="React-Redux 的 shouldComponentUpdate 实现"></a>React-Redux 的 shouldComponentUpdate 实现</h4><p>React 组件类的父类 Component 提供了 shouldComponentUpdate 的默认实现方式，只简单返回 true。当需要达到更高性能时需要自定义 shouldComponentUpdate。</p><p>react-redux 用的是尽量简单的方法，做的是“浅层比较”（和 js 中的===类似），如果 prop 的类型是字符串或者数字，只要值相同，那么“浅层比较”的方法会认为二者相同，如果 prop 的类型是复杂对象，那么“浅层比较”的方式只看这两个 prop 是不是同一对象的引用。</p><h3 id="多个-React-组件的性能优化"><a href="#多个-React-组件的性能优化" class="headerlink" title="多个 React 组件的性能优化"></a>多个 React 组件的性能优化</h3><h4 id="React-的调和过程"><a href="#React-的调和过程" class="headerlink" title="React 的调和过程"></a>React 的调和过程</h4><p>当 React 要对比两个 Virtual DOM 的树形结构的时候，从根节点开始递归往下比对，在树形结构上，每个节点都可以看作一个这个节点以下部分子树的根节点。所以其实这个对比算法可以从 Virtual DOm 上任何一个节点开始。</p><p>React 首先检查两个树形的根节点的类型是否相同，根据相同或者不同有不同处理方式。</p><h5 id="节点类型不同的情况"><a href="#节点类型不同的情况" class="headerlink" title="节点类型不同的情况"></a><strong>节点类型不同的情况</strong></h5><p>如果树形结构根节点类型不相同，直接认为原来那个树形结构已经没用，可以扔掉，需要重新构建新的 DOM 树，原有的树形上的 React 组件会经历“卸载”的生命周期。这时候componentWillUnmount 方法会被调用，取而代之的组件则会经历装载过程的生命周期，组件的 componentWillMount、render 和 componentDidMount 方法依次被调用。也就是说，对于 Virtual DOM 树这是一个“更新”过程，但是却可能引发这个树结构上某些组件的“装载”和“卸载”过程。</p><p>作为开发者，一定要避免作为包裹功能的节点类型被随意改变。</p><p>如果 React 对比两个树形结构的根节点发现类型相同，那么就觉得可以重用原来的节点，进入更新阶段，按照下一步骤来处理。</p><h5 id="节点类型相同的情况"><a href="#节点类型相同的情况" class="headerlink" title="节点类型相同的情况"></a><strong>节点类型相同的情况</strong></h5><p>两个树形结构的根节点类型相同，React 就认为原来的根节点只需要更新过程，不会将其卸载，也不会引发根节点的重新装载。</p><p>对于 DOM 类型元素，React 会保留节点对应的 DOM 元素，只对树形结构根节点上的树形和内容做一下比对，然后只更新修改的部分。</p><p>对于 React 组件类型，React能做的只是根据新节点的 props 去更新原来根节点的组件实例，引发这个组件实例的更新过程。在这个过程中，如果 shouldComponentUpdate 函数返回 false，更新过程就此打住，不再继续。</p><p>在处理完根节点的对比后，React 的算法会对根节点的每个子节点重复一样的动作，这时候每个子节点就成为它所覆盖部分的根节点，处理方式和它的父节点完全一样。</p><h5 id="多个子组件的情况"><a href="#多个子组件的情况" class="headerlink" title="多个子组件的情况"></a><strong>多个子组件的情况</strong></h5><p>在序列后增加一个新的组件，React 会发现多出了一个组件，会创建一个新的组件实例，这个组件实例需要经历装载过程，对于之前的实例，React 会引发他们的更新过程，只要shouldComponentUpdate 函数实现恰当，检查 props 之后就返回 false 的话，可以避免实质的更新操作。</p><p>在序列前增加一个新的组件，React 会挨个比较，认为新增的组件是之前第一个组件属性的变更，并增加了最后一个组件。</p><p>使用 key 可以克服这种浪费</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>key 在代码中可以明确的告诉 react 每个组件的唯一标识。</p><p>当遇到在序列前添加一个新的组件时，React 根据 key 值，可以知道之前的组件，所以 React 会把新创建的组件插在前面，对于原有组件实例只用原有的 props 来启动更新过程。</p><h3 id="用-reselect-提高数据获取性能"><a href="#用-reselect-提高数据获取性能" class="headerlink" title="用 reselect 提高数据获取性能"></a>用 reselect 提高数据获取性能</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>只要相关状态没有改变，那就直接使用上一次的缓存结果。</p><h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><ol><li>从输入参数 state 抽取第一层结果，将这第一层结果和之前抽取的第一层结果做比较，如果发现完全相同，就没有必要进行第二部分运算了，选择器直接把之前第二部分的运算结果返回就可以了。这里的比较就是 js 中的<code>===</code>操作符比较，如果第一层结果是对象的话，只有是同一对象才会被认为是相同。</li><li>根据第一层结果计算出选择器需要返回的最终结果</li></ol><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>步骤一运算因为每次选择器都要使用，所以一定要快，运算要非常简单，最好是一个映射运算，通常就只是从 state 参数中得到某个字段的引用就足够，把剩下来的重活累活都交给步骤二去做。 </p><h2 id="React-高级组件（大概略读了一下，以后再细看，待更新）"><a href="#React-高级组件（大概略读了一下，以后再细看，待更新）" class="headerlink" title="React 高级组件（大概略读了一下，以后再细看，待更新）"></a>React 高级组件（大概略读了一下，以后再细看，待更新）</h2><h2 id="Redux-和-服务器通信"><a href="#Redux-和-服务器通信" class="headerlink" title="Redux 和 服务器通信"></a>Redux 和 服务器通信</h2><h3 id="React-组件访问服务器"><a href="#React-组件访问服务器" class="headerlink" title="React 组件访问服务器"></a>React 组件访问服务器</h3><p>通常在组件的 ComponentDidMount 函数中做请求服务器的事情，因为当该函数被调用时，装载过程已完成，组件需要渲染的内容已经出现在 DOM 树上。</p><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/12/15708622641712.jpg" alt="-w615"></p><p>fetch 函数返回的结果是一个 Promise 对象。fetch 认为只要服务器返回一个合法的 HTTP 响应就算成功，就会调用 then 提供的回调函数。也就是说 当 HTTP 响应的状态码为 400 或者 500 的时候也会调用 then。</p><h3 id="Redux-访问服务器"><a href="#Redux-访问服务器" class="headerlink" title="Redux 访问服务器"></a>Redux 访问服务器</h3><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><p>Redux-thunk 的思路：在 Redux 的单向数据流中，在 action 对象被 reducer 函数处理之前，是插入异步功能的时机。</p><p>在 Redux 架构下，一个 action 对象在通过 store.dispatch 派发，在调用 reducer 函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上 redux-thunk 提供的就是一个 Redux 中间件，需要在创建 Store 时用上这个中间件。</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/12/redux-de-action-chu-li-liu-cheng.png" alt="Redux 的 action 处理流程"></p><h3 id="异步-action-对象"><a href="#异步-action-对象" class="headerlink" title="异步 action 对象"></a>异步 action 对象</h3><p>redux-thunk 的工作是检查 action 对象是否为函数，如果不是函数就放行，完成普通 action 对象的生命周期，如果发现 action 对象是函数，那就执行这个函数，并把 Store 的 dispatch 的函数和 getState 函数作为参数传递到函数中去，处理过程到此为止，会让这个异步 action 对象继续往前派发到 reducer 函数。</p><p>异步 action 构造函数的代码基本上都是如下套路：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sampleAsyncAction = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch,getState</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//在这个函数里可以调用一步函数，</span><br>        <span class="hljs-comment">//自行决定在合适的实际通过 dispatch 参数</span><br>        <span class="hljs-comment">//派发出新的 action 对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS学习记录</title>
    <link href="/article/aa58022d/"/>
    <url>/article/aa58022d/</url>
    
    <content type="html"><![CDATA[<h1 id="TS-常用点整理"><a href="#TS-常用点整理" class="headerlink" title="TS 常用点整理"></a>TS 常用点整理</h1><p>[scode type=”green”]具体实践可以看<br>github：<a href="https://github.com/chenxiumiao/component-with-ts">component-with-ts</a><br>本来想详细介绍组件的开发过程的，但是奈何语言组织能力比较差，脑子知道如何去做，但是不知道转换成文字怎么描述，所以就先暂时隐藏了实现过程<br>[/scode]</p><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><ol><li>boolean <code>let isOk：boolean = false</code></li><li>number <code>let age: number = 20</code></li><li>string <code>let message: string = &#39;isOk&#39;</code></li><li>undefined <code>let u: undefined = undefined</code></li><li>null <code>let n : null = null</code></li></ol><h2 id="any-类型和-联合类型"><a href="#any-类型和-联合类型" class="headerlink" title="any 类型和 联合类型"></a>any 类型和 联合类型</h2><ol><li>any 类型 <code>let notSure:any = 4</code> <code>notSure = &#39;maybe&#39;</code></li><li>联合类型 <code>let numberOrString: number|string = 234</code> <code>numberOrString = &#39;abc&#39;</code></li></ol><h2 id="Array-和元祖"><a href="#Array-和元祖" class="headerlink" title="Array 和元祖"></a>Array 和元祖</h2><ol><li>Array <code>let arrOfNumbers: number[] = [1,2,3,4]</code></li><li>元祖 <code>let user:[string, number] = [&#39;isOk&#39;,&#39;234&#39;]</code></li></ol><p>元祖实际上就是规定了不同类型的已知长度数组<br>typescript</p><h2 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h2><p>接口的主要功能：</p><ol><li>对对象的形状进行描述</li><li>对类进行抽象</li><li>Duck Typing（对象的一种推断策略）</li></ol><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IPerson &#123;<br>    <span class="hljs-keyword">readonly</span> id: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//只读属性</span><br>    name: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// ?代表可选属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> chenxiumiao: IPreson = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span><br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;chenxiumiao&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">23</span><br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><p>readonly 与 const 区别：readonly 是用在属性上的，const 是用在变量上的。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>描述函数时描述的为参数与返回值</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//函数声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-comment">//可选参数要放在最后</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y + z;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//函数表达式</span><br><br><span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> z === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y + z;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> add2: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, z?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = add; <span class="hljs-comment">//=&gt;不是箭头函数，而是函数表达式返回值的表达方式。</span><br></code></pre></div></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">static</span> categoies: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;mammal&quot;</span>, <span class="hljs-string">&quot;bird&quot;</span>]; <span class="hljs-comment">//静态属性，与实例关系不大</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">isAnimal</span>(<span class="hljs-params">a</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a <span class="hljs-keyword">instanceof</span> Animal;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is running`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;lily&quot;</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">bark</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is barking`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> xiaobao = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;xiaobao&quot;</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Meow,&quot;</span> + <span class="hljs-built_in">super</span>.run();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> maomao = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;maomao&quot;</span>);<br></code></pre></div></td></tr></table></figure><table><thead><tr><th></th><th>自身权限</th><th>子类权限</th></tr></thead><tbody><tr><td>public</td><td>可以</td><td>可以</td></tr><tr><td>private</td><td>可以</td><td>不可以</td></tr><tr><td>protected</td><td>可以</td><td>可以</td></tr><tr><td>readonly</td><td>只读</td><td>只读</td></tr></tbody></table><h2 id="interface-接口与类"><a href="#interface-接口与类" class="headerlink" title="interface 接口与类"></a>interface 接口与类</h2><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//找不出Car 与 Cellphone共性，所以提取为 interface</span><br><span class="hljs-keyword">interface</span> Radio &#123;<br>  switchRadio(triggerL: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Battery &#123;<br>  checkBatteryStatus();<br>&#125;<br><br><span class="hljs-keyword">interface</span> RadioWithBattery <span class="hljs-keyword">extends</span> Radio &#123;<br>  checkBatteryStatus();<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Radio</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">switchRadio</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cellphone</span> <span class="hljs-title">implements</span> /*<span class="hljs-title">Radio</span>,<span class="hljs-title">Battery</span>*/ <span class="hljs-title">RadioWithBattery</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">switchRadio</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-title">checkBatteryStatus</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="枚举-enums"><a href="#枚举-enums" class="headerlink" title="枚举 enums"></a>枚举 enums</h2><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//使用 const 可以提升性能，具体看 ts 编译后的 js 文件对比</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Direction &#123;<br>  Up, <span class="hljs-comment">//进行数字赋值后，后续会按照自增方式进行赋值。字符串赋值时必须将每项都赋值</span><br>  Down,<br>  Left,<br>  Right,<br>&#125;<br><span class="hljs-built_in">console</span>.log(Direction.Up);<br><span class="hljs-built_in">console</span>.log(Direction[<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure><h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><p>泛型：定义函数接口或类时，不预先指定具体类型，在使用时指定类型。</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-comment">//&lt;&gt;是泛型名称，相当于创建了一个占位符</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-keyword">const</span> str: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;str&quot;</span>;<br><br><span class="hljs-keyword">const</span> result = echo(str);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">U</span>, <span class="hljs-title">T</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];<br>&#125;<br><br><span class="hljs-keyword">const</span> result = swap([<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-number">1234</span>]);<br></code></pre></div></td></tr></table></figure><p>约束泛型</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoWitchArr</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T[]</span>): <span class="hljs-title">T</span>[] </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg.length);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">const</span> arrs = echoWitch([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br><span class="hljs-keyword">interface</span> IWitchLength &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoWitchLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">IWithLength</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(arg.length);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-keyword">const</span> str = echoWithLength(<span class="hljs-string">&quot;str&quot;</span>);<br><span class="hljs-keyword">const</span> obj = echoWithLength(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">12</span> &#125;); <span class="hljs-comment">//只要包含 length 属性就可以</span><br><span class="hljs-keyword">const</span> arr2 = echoWithLength([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queuq</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> data = [];<br><br>  <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">item: T</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data.push(item);<br>  &#125;<br><br>  pop(): T &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data.shift();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">number</span>&gt;();<br></code></pre></div></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//interface</span><br><span class="hljs-keyword">interface</span> KeyPair&lt;T, U&gt; &#123;<br>  <span class="hljs-attr">key</span>: T;<br>  value: U;<br>&#125;<br><span class="hljs-keyword">let</span> kp1: KeyPair&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; = &#123; <span class="hljs-attr">key</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;str&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> arr: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> arrTwo: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">interface</span> IPlus&lt;T&gt; &#123;<br>  (a: T, <span class="hljs-attr">b</span>: T): T;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-keyword">const</span> a: IPlus&lt;<span class="hljs-built_in">number</span>&gt; = plus;<br><span class="hljs-keyword">const</span> b: IPlus&lt;<span class="hljs-built_in">string</span>&gt; = connect;<br></code></pre></div></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//type aliases</span><br><span class="hljs-keyword">type</span> PlusType = <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">const</span> sum2: PlusType = sum;<br><br><span class="hljs-keyword">type</span> NameResolver = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">type</span> NameOrResolver = <span class="hljs-built_in">string</span> | NameResolver;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> n();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//type assertion 类型断言</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-comment">// const str = input as String</span><br>  <span class="hljs-comment">// if(str.length)&#123;</span><br>  <span class="hljs-comment">//     return str.length</span><br>  <span class="hljs-comment">// &#125;else&#123;</span><br>  <span class="hljs-comment">//    const number = input as Number</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// return number.toString().length</span><br><br>  <span class="hljs-keyword">if</span> ((&lt;<span class="hljs-built_in">string</span>&gt;input).length) &#123;<br>    <span class="hljs-keyword">return</span> (&lt;<span class="hljs-built_in">string</span>&gt;input).length;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> input.toString().length;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">//声明文件以.d.ts 为后缀</span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> jQuery: <span class="hljs-function">(<span class="hljs-params">selector: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服前端面试-校招-2019</title>
    <link href="/article/61660c91/"/>
    <url>/article/61660c91/</url>
    
    <content type="html"><![CDATA[<h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ul><li>GET 和 POST 本质没有区别。GET 和 POST 是 HTTP 协议中的两种发送请求的方法。HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。也可以给 GET 加上 request body，给 POST 带上 url 参数</li><li>GET 长度受浏览器长度限制。POST 没有</li><li>GET 请求只能进行 url 编码 ASCII 字符，而 POST 支持多种编码方式。</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li><li>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。（对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。）</li></ul><h2 id="从输入-url-到显示经历了什么？"><a href="#从输入-url-到显示经历了什么？" class="headerlink" title="从输入 url 到显示经历了什么？"></a>从输入 url 到显示经历了什么？</h2><ol><li><p>浏览器有五大线程：定时器线程，事件线程，网络线程，渲染线程，js 线程</p></li><li><p>当输入 url 后，浏览器会开辟一条网络线程，经历 DNS 查询，三次握手，四次挥手。</p><ul><li>DNS 查询：先检查浏览器本身有没有缓存，如果没有则查找本地，如果本地也没用查找 host，如果也没用就去找根服务器</li><li>三次握手</li><li>四次挥手</li></ul></li><li><p>后端接收到请求后，经过一系列统一性验证后，执行后端代码，然后 HTTP 响应包发送给前端，完成交互</p></li><li><p>前端接受到报文后先解析 HTML，构建 DOM 树</p></li><li><p>解析 CSS，构建 CSSOM 树</p></li><li><p>合并 DOM 树和 CSSOM 树，构建 render 树</p></li><li><p>布局 render 树</p></li><li><p>绘制 render 树</p></li><li><p>浏览器会将各层的信息发送给 GPU,GPU 将各层合成显示在屏幕上。</p></li><li><p>遇到 script 标签时，会执行并阻塞渲染:因为浏览器渲染和 js 执行公用一个线程,而且这里必须是单线程操作,多线程会产生渲染 DOM 冲突.等 script 标签完成后,浏览器会继续渲染.这也可以解释为什么 js 放在 html 底部,JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p></li></ol><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制.同源是指域名协议端口均相同.同源策略主要用来防止 CSRF 攻击<br>解决方案:</p><ol><li>JSONP:JSONP = json + padding 填充式 json 利用的是动态创建 script 标签，向服务器请求 json 数据，服务器收到请求后，服务器将传回来的数据放在指定名字的回调函数中传回来，这样就可以实现跨域访问。简单实用，老旧浏览器都适用</li><li>配置 nginx 代理</li><li>CORS:服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</li></ol><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC（Block Formatting Context）直译为“块级格式化上下文”，是用于布局块级盒子的一块渲染区域。它规定了内部的块级如何布局，并且与这个区域外部毫不相干。简单的概括为：所谓的 BFC 就是 CSS 布局的一个概念，是一块区域，一个环境。<br>通俗的来讲 BFC 就是创建了一个独立黑盒子，这个黑盒子与外部没有关系，内外不能互相影响。</p><blockquote><p>创建一个 BFC 有以下几种方式</p></blockquote><ul><li>根元素</li><li>overflow 值非 visible</li><li>使用绝对定位和固定定位 absolute，fixed</li><li>使用 float</li><li>display 为 inline-block，table-cell，flex，inline-flex</li><li><strong>现在可以使用 display 的 flow-root 属性来创建 BFC</strong></li></ul><blockquote><p>BFC 布局的规则</p></blockquote><ul><li>创建 BFC 元素的内部的 box 会垂直排列</li><li>计算 BFC 高度的时候，浮动元素也会算在内</li><li>BFC 内部相邻的 box 的垂直外边距会合并</li><li>BFC 就是页面上一个独立的容器，内部是不会影响外部的元素，反之亦然</li></ul><blockquote><p>BFC 的使用</p></blockquote><ul><li>首先它可以用在避免外边距合并上，应为 BFC 是独立的容器，所以可以给某个元素外面包裹一个 BFC，这样就可以避免外边距合并</li><li>清除浮动，因为使用 overflow 的 hidden，auto 时，可以创建一个 BFC，而 BFC 计算本身容器高度的时候是将浮动元素也是计算在内的，所以，这个时候就可以避免浮动引起的高度塌陷，从而清除浮动</li><li>避免文字环绕。可以为元素显示的利用 overflow 将其变为 bfc，这样就变为一个独立的容器，这样就不会出现文字环绕</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><h4 id="第一种-父元素指定固定高度"><a href="#第一种-父元素指定固定高度" class="headerlink" title="第一种 父元素指定固定高度"></a>第一种 父元素指定固定高度</h4><blockquote><p>高度已知，手动撑开浮动元素的包含框</p></blockquote><h4 id="第二种-结尾增加空的-div，然后对其使用-clear：both"><a href="#第二种-结尾增加空的-div，然后对其使用-clear：both" class="headerlink" title="第二种 结尾增加空的 div，然后对其使用 clear：both"></a>第二种 结尾增加空的 div，然后对其使用 clear：both</h4><blockquote><p>让父级 div 自动获取高度</p></blockquote><h4 id="第三种-父级-div-使用伪类-after，zoom（IE）"><a href="#第三种-父级-div-使用伪类-after，zoom（IE）" class="headerlink" title="第三种 父级 div 使用伪类 after，zoom（IE）"></a>第三种 父级 div 使用伪类 after，zoom（IE）</h4><blockquote><p>使用 clear：both<br>和第二种效果一样，但是 IE8 以下不支持 after 伪类，代替他的是，zoom=1</p></blockquote><h4 id="第四种-父级使用-overflow：hidden"><a href="#第四种-父级使用-overflow：hidden" class="headerlink" title="第四种 父级使用 overflow：hidden"></a>第四种 父级使用 overflow：hidden</h4><blockquote><p>原理是超出元素区域将进行裁剪，虽然浮动元素脱离文档流，但是他和普通流组成了一个立体流，所以使用 overflow 时，要确定内容区域高度，就会将浮动元素也算进来</p></blockquote><h4 id="第五种-父级定义-overflow：auto"><a href="#第五种-父级定义-overflow：auto" class="headerlink" title="第五种 父级定义 overflow：auto"></a>第五种 父级定义 overflow：auto</h4><blockquote><p>原理和使用 hidden 一样，但是这个会出现滚动条</p></blockquote><h4 id="第六种-父级-div-跟着一起浮动"><a href="#第六种-父级-div-跟着一起浮动" class="headerlink" title="第六种 父级 div 跟着一起浮动"></a>第六种 父级 div 跟着一起浮动</h4><blockquote><p>这样浮动元素就自成一派，称为一个整体</p></blockquote><h4 id="第七种-将父级元素-display-为-table，变成表格"><a href="#第七种-将父级元素-display-为-table，变成表格" class="headerlink" title="第七种 将父级元素 display 为 table，变成表格"></a>第七种 将父级元素 display 为 table，变成表格</h4><h4 id="第八种-结尾使用-br。让其-clear：both"><a href="#第八种-结尾使用-br。让其-clear：both" class="headerlink" title="第八种 结尾使用 br。让其 clear：both"></a>第八种 结尾使用 br。让其 clear：both</h4>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯前端面试-校招-2019</title>
    <link href="/article/6dcc487f/"/>
    <url>/article/6dcc487f/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在准备笔试面试，所以又搁置了博文更新计划。强迫自己更新文章，所以来一个腾讯的面经。将之前翻车的答案都更正为正确答案。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>一面的机会纯属偶然获得，和笔试相隔了很久，早已经忘记了腾讯的事，都已经愉快的放飞自我了，各种吃喝玩乐，突然之间就收到了腾讯的一面，一天都很亢奋。</p><h3 id="输入-url-到显示的过程"><a href="#输入-url-到显示的过程" class="headerlink" title="输入 url 到显示的过程"></a>输入 url 到显示的过程</h3><blockquote><ol><li>首先浏览器有五大线程:渲染线程，JS 线程，事件线程，网络线程，定时器线程</li><li>输入 URl 后会进行解析.然后开辟一个网络线程,请求资源。从应用层发送的 http 请求,到传输层通过三次握手建立 tcp/ip 链接,再到网络层的 ip 寻址,然后再到数据链路层的封装成帧,最后到物理层的利用物理介质传输。</li></ol><ul><li>DNS 查询：如果浏览器有缓存,则直接使用浏览器缓存否则使用本机缓存,再没有就是用 host.如果没有缓存就向 dns 域名服务器查询,查询到对应 ip</li><li>三次握手 seq-&gt;ack seq ack</li><li>四次挥手</li></ul><ol start="3"><li>从服务器接受到的请求到对应后台收到请求,后台进行处理.一般有的后台有统一性验证,安全拦截,跨域验证之类的.如果这一步不符合规则,就直接返回了相应的 http 报文,如果通过,才会进行实际的后台代码,此时是程序接收到请求,然后执行.等程序执行完毕后,就会返回一个 http 响应包.然后将这个包从后端发送到前端,完成交互。前端后端交互时 http 报文作为信息的载体.</li><li>然后开始前端渲染</li><li>浏览器解析 html,构建 dom 树 过程:字节数据 字符串 tokens nodes dom</li><li>解析 css 生成 css 规则树 过程:字节数据 字符串 tokens nodes cssom 在这过程中浏览器会确定下每一个节点的样式.</li><li>合并 dom 树和 css 规则,生成 render 树 计算 css 样式,渲染树只会包括需要现实的节点和这些节点的样式信息</li><li>布局 render 树</li><li>绘制 render 树</li><li>浏览器会将各层的信息发送给 GPU,GPU 将各层合成显示在屏幕上</li><li>遇到 script 标签时，会执行并阻塞渲染:因为浏览器渲染和 js 执行公用一个线程,而且这里必须是单线程操作,多线程会产生渲染 DOM 冲突.等 script 标签完成后,浏览器会继续渲染.这也可以解释为什么 js 放在 html 底部,JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</li></ol></blockquote><h3 id="linux-指令"><a href="#linux-指令" class="headerlink" title="linux 指令"></a>linux 指令</h3><p>指令有点多，问我的我也记不太清了 2333，多看看<a href="http://linux.vbird.org/linux_basic/">鸟哥的私房菜</a>吧</p><h3 id="同源策略怎么回事？以及如何实现跨域请求"><a href="#同源策略怎么回事？以及如何实现跨域请求" class="headerlink" title="同源策略怎么回事？以及如何实现跨域请求"></a>同源策略怎么回事？以及如何实现跨域请求</h3><blockquote><p>同源策略目的是为了保护用户的信息安全，防止恶意的网站窃取数据，比如 A 网站的 cookie，B 网站就不能使用，同源指的是协议，url，端口全部一致。实现跨域的方法有多种。<br>同源策略限制了以下三种行为:</p><ul><li>Ajax 请求不能发送，所以就出现了跨域</li><li>DOM 无法获得</li><li>cookie，localstroge，indexDB 无法读取<br>解决 cookie 不能共享，可以设置相同的 document.domain 就可以.<br>跨域解决方案:</li></ul><ol><li>JSONP:JSONP = json + padding 填充式 json 利用的是动态创建 script 标签，向服务器请求 json 数据，服务器收到请求后，服务器将传回来的数据放在指定名字的回调函数中传回来，这样就可以实现跨域访问。简单实用，老旧浏览器都适用,但是只支持 GET 请求。</li><li>配置 nginx 代理</li><li>CORS:服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</li></ol></blockquote><h3 id="用什么版本控制器"><a href="#用什么版本控制器" class="headerlink" title="用什么版本控制器"></a>用什么版本控制器</h3><p>git。git 指令推荐看看：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 Git 教程</a></p><h3 id="闭包是什么？闭包会带来什么问题？"><a href="#闭包是什么？闭包会带来什么问题？" class="headerlink" title="闭包是什么？闭包会带来什么问题？"></a>闭包是什么？闭包会带来什么问题？</h3><blockquote><p>当执行上下文中创建的函数执行时,如果访问了执行上下文中变量对象中的值,闭包就会产生<br>JavaScript 拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。<br>闭包副作用会造成内存泄露，正面作用利用闭包可以实现块级作用域，IIFE，模块化</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><blockquote><p>性能优化可以分为两种：减少页面体积,提升网络加载 和 优化页面渲染</p><ul><li>减少页面体积,提升网络加载<ul><li>静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）</li><li>静态资源缓存（资源名称加 MD5 戳）</li><li>使用 CDN 让资源加载更快</li></ul></li><li>优化页面渲染<ul><li>CSS 放前面，JS 放后面</li><li>懒加载（图片懒加载、下拉加载更多）</li><li>减少 DOM 查询，对 DOM 查询做缓存</li><li>减少 DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）</li><li>事件节流</li><li>尽早执行操作（DOMContentLoaded）</li><li>使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间</li></ul></li></ul></blockquote><h4 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h4><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，然后会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p><h3 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h3><blockquote><p>dom 标准事件流的触发的先后顺序为：先捕获再冒泡.事件捕获：通俗的理解就是，当鼠标点击或者触发 dom 事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。使用 stopPropagation()阻止事件冒泡.使用 preventDefault()阻止默认行为</p></blockquote><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>二面和一面相隔了三天，不过一面面完的下午就变成了复试状态，截止写此文为止还没消息，一直是复试状态。感觉要加面。</p><h3 id="React-有哪些优点"><a href="#React-有哪些优点" class="headerlink" title="React 有哪些优点"></a>React 有哪些优点</h3><ol><li>使用了虚拟节点，性能好</li><li>因为强调只从 this.props 和 this.state 生成 HTML，对函数式编程友好</li><li>生态好，应对各种场景的包都有。</li></ol><h3 id="怎么实现的虚拟节点？"><a href="#怎么实现的虚拟节点？" class="headerlink" title="怎么实现的虚拟节点？"></a>怎么实现的虚拟节点？</h3><blockquote><p>虚拟节点的本质：虚拟节点的本质就是在 JS 和 DOM 之间做一个缓存，可以类比 CPU 和硬盘，既然硬盘这么慢，我们就也在他们之间添加一个缓存； 既然 DOM 这么慢，我们就可以在 JS 和 DOM 之间添加一个缓存。 CPU（JS）只操作内存（虚拟 DOM），最后的时候在把变更写入硬盘（DOM）。</p><p>diff 算法：</p><ol><li>用 Js 对象来表示 DOM 树的结构，需要记录他的节点类型（tagName）、属性（props）、子节点（children）； 然后用这个树构建一个真正的 DOM 树，插入到文档中。</li><li>当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。</li><li>深度遍历优先，记录差异</li><li>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。差异包括：替换原来的节点； 移动、删除、新增子节点；修改了节点的属性。 ；对于文本节点，文本内容可能会改变。</li><li>把 2 所记录的差异应用在步骤一所构建的真正的 DOM 树上，视图就更新了。</li></ol></blockquote><h3 id="解释一下-304"><a href="#解释一下-304" class="headerlink" title="解释一下 304"></a>解释一下 304</h3><p>304 not modified，表示服务器允许访问资源，但因为发生请求未满足条件的情况。用于协商缓存，缓存分为强缓存和协商缓存，协商缓存的机制是如果缓存过期了，就需要发起请求验证资源是否有更新。当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态，并且更新服务器缓存有效期。</p><h3 id="如何判断服务器资源是否更新"><a href="#如何判断服务器资源是否更新" class="headerlink" title="如何判断服务器资源是否更新"></a>如何判断服务器资源是否更新</h3><blockquote><p>last-modified:last-modified 和 if-modified-since 是成对出现的</p><ul><li>last-modified 在响应头里，服务器告诉浏览器，这个资源的最后修改时间是什么</li><li>if-modified-since 在请求头里，告诉服务器我所请求的这个资源最后修改时间是什么。服务器根据这个值来判断，如果这个值和服务端这个资源现有的值一致，直接返回 304 和空的 body，如果和服务端现有的值不一致（资源已经更新），则返回 200 和最新资源。<br>etag:etag 和 if-none-match 是成对出现的</li><li>etag 是服务器根据一定规则生成的资源‘指纹’，传递给客户端，客户端将其与缓存一起保存</li><li>if-none-match 是客户端在向服务端请求指定资源时，将本地的 etag 值通过信息头传递给服务端，服务端与其当前版本的资源的 ETag 进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的 304 未修改状态，告诉客户端缓存版本可用。如果 etag 值匹配不成功，返回 200 code 和资源内容。</li></ul></blockquote><h3 id="对-http-了解多少？http-header-中都有哪些东西？"><a href="#对-http-了解多少？http-header-中都有哪些东西？" class="headerlink" title="对 http 了解多少？http header 中都有哪些东西？"></a>对 http 了解多少？http header 中都有哪些东西？</h3><blockquote><p>HTTP 协议最大的特点是「无状态」。客户端向服务器端发起一个请求。然后服务器端返回一个响应。HTTP 协议传输的内容是 HTTP message。<br>报文分成两种，一种是 Request 请求，通常用于浏览器告诉服务器它想要什么；一种是 Response 响应，通常用于服务器给浏览器返回它要的内容。<br>报文的基本格式：开始行，消息头，空行，消息体。<br>Request:请求行，请求头，空行，消息体（可空）</p><ul><li>请求行：请求方法 URI 协议版本号 。</li><li>请求头：Referrer 请求发起页面的地址 User-Agent 客户端信息 Host 主机域名 Max-forwards 请求最大转发次数<br>Response：状态行，响应头，空行，消息体。</li><li>状态行：协议版本号 状态码</li><li>响应头：ETage：Entity 的唯一编码，修改后更新；Retry-after：N 秒后重试；Location：转向到 Server Web Server 相关信息<br>消息体：可空。<br>实体头字段：Allow：支持的 HTTP 方法；Expires：过期时间； Content-Encoding：编码格式；Content-Language：编码格式； Content-Length：内容长度（字节）；Content-Type：媒体类型。</li></ul></blockquote><h3 id="页面出现空白，怎么排查定位问题？"><a href="#页面出现空白，怎么排查定位问题？" class="headerlink" title="页面出现空白，怎么排查定位问题？"></a>页面出现空白，怎么排查定位问题？</h3><ol><li>先确保网络连接通畅。</li><li>查看网络 url 地址是否输入有误。</li><li>打开控制台查看报错信息。</li><li>查看接口访问是否有请求。</li><li>查看路由是否有 path 或者 name 的错误，导致加载了不存在的页面。</li></ol><h3 id="一个父元素-div-里面有-n-个-a-标签，对-a-有一些事件需要处理，怎么处理？"><a href="#一个父元素-div-里面有-n-个-a-标签，对-a-有一些事件需要处理，怎么处理？" class="headerlink" title="一个父元素 div 里面有 n 个 a 标签，对 a 有一些事件需要处理，怎么处理？"></a>一个父元素 div 里面有 n 个 a 标签，对 a 有一些事件需要处理，怎么处理？</h3><p>使用事件代理，绑定在父元素上，看事件的出发点是不是 a 标签。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#div&quot;</span>).addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-comment">// e.target 可以监听到触发点击事件的元素是哪一个</span><br>  <span class="hljs-keyword">var</span> target = e.target;<br>  <span class="hljs-keyword">if</span> (e.nodeName === <span class="hljs-string">&quot;A&quot;</span>) &#123;<br>    <span class="hljs-comment">// 点击的是 &lt;a&gt; 元素</span><br>    <span class="hljs-comment">// 进行要处理的内容</span><br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="利用了什么性质？"><a href="#利用了什么性质？" class="headerlink" title="利用了什么性质？"></a>利用了什么性质？</h3><blockquote><p>事件冒泡。dom 标准事件流的触发的先后顺序为：先捕获再冒泡<br>事件捕获：通俗的理解就是，当鼠标点击或者触发 dom 事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。<br>事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。使用 stopPropagation()阻止事件冒泡.使用 preventDefault()阻止默认行为</p></blockquote><h3 id="垂直水平居中怎么做？"><a href="#垂直水平居中怎么做？" class="headerlink" title="垂直水平居中怎么做？"></a>垂直水平居中怎么做？</h3><ol><li>利用 css3 的 translate 属性，设置子元素为绝对定位，top，left 为 50%，translate（-50%。-50%）</li><li>利用 flex 布局，对父元素使用，align-items：center 让其在侧轴垂直，就是说垂直居中,如果要水平居中的话，可以使用 justify-centent：center</li></ol><h3 id="对于性能优化你有什么看法"><a href="#对于性能优化你有什么看法" class="headerlink" title="对于性能优化你有什么看法"></a>对于性能优化你有什么看法</h3><p>参看一面</p><h3 id="为什么说-dom-操作耗时？"><a href="#为什么说-dom-操作耗时？" class="headerlink" title="为什么说 dom 操作耗时？"></a>为什么说 dom 操作耗时？</h3><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当通过 JS 操作 DOM 的时候，这个操作涉及到了两个线程之间的通信，然后会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信。操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p><h3 id="什么是重绘？什么是回流？"><a href="#什么是重绘？什么是回流？" class="headerlink" title="什么是重绘？什么是回流？"></a>什么是重绘？什么是回流？</h3><blockquote><p>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘<br>回流是布局或者几何属性需要改变就称为回流。<br>回流一定会触发重绘，而重绘不一定会回流<br>原因:</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>如何避免:</p><ul><li>使用 transform 替代 top,left,right,bottom</li><li>使用 visibility 替换 display:none,前者只会重绘,后者会引发回流</li><li>不把界面的属性值放在一个循环里当循环的变量</li><li>不用 table 布局</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>猎豹移动大前端面试-校招-2020届</title>
    <link href="/article/2e796c8e/"/>
    <url>/article/2e796c8e/</url>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><p>盒模型有两种标准，一个是标准模型，一个是 IE 模型。<br>在标准模型中，盒模型的宽高只是内容（content）的宽高，<br>而在 IE 模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。<br><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/11/15707306022767.jpg" alt="-w435"></p><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是指一个作用域中的函数可以访问该作用域中的函数，变量等。当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。函数的执行上下文在执行完毕之后，生命周期结束，该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。闭包的存在，会阻止这一过程。</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>1.全局对象中的 this 指向它本身 2.函数中的 this</p><blockquote><p>在一个函数的执行上下文中，this 由该函数的调用者提供，由调用函数的方式决定其指向。<br>如果调用者被某一个对象所拥有，那么在调用该函数时，内部的 this 指向该对象。如果调用者函数独立调用，那么该函数内部的 this 则指向 undefined。在非严格模式中，当 this 指向 undefined 时，它会自动指向全局对象。<br>call/apply/bind 显式指定 this。</p></blockquote><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><h5 id="新增内容"><a href="#新增内容" class="headerlink" title="新增内容"></a>新增内容</h5><ul><li>新的变量声明方式 let/const</li><li>箭头函数</li><li>模板字符串</li><li>解析结构</li><li>函数默认参数</li><li>展开运算符</li><li>class,construction,extends</li><li>promise</li><li>Module</li></ul><h5 id="foreach-用法"><a href="#foreach-用法" class="headerlink" title="foreach 用法"></a>foreach 用法</h5><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/11/15707313633613.jpg" alt="-w536"></p><h3 id="框架相关"><a href="#框架相关" class="headerlink" title="框架相关"></a>框架相关</h3><h4 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h4><p>React 生命周期分为三个阶段：装载，更新，卸载</p><p>装载阶段中会依次执行以下函数：</p><ol><li>constructor</li><li>getInitialState</li><li>getDefaultProps</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ol><p>更新阶段会依次执行以下函数</p><ol><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ol><p>卸载阶段会执行：componentWillUnmount</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><ul><li><p>父子通信<br>父组件通过 props 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。<br>这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过调用父组件函数的方式告知父组件修改数据。</p></li><li><p>兄弟组件通信<br>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件。</p></li><li><p>跨多层次组件通信<br>Context API。</p></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><h5 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h5><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><h5 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h5><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><h5 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h5>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MWeb发布服务配置与图床配置教程</title>
    <link href="/article/a6acd6f/"/>
    <url>/article/a6acd6f/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 MWeb 完全是因为写博客，反复打开博客进行编辑不太方便。就去找了一下是否有本地的东西能跟博客接口连接的东西。</p><h2 id="发布服务的配置"><a href="#发布服务的配置" class="headerlink" title="发布服务的配置"></a>发布服务的配置</h2><ol><li>首先进入 typecho 的后台，打开<code>设置-基本</code>找到<code>XMLRPC 接口</code>将其设置为打开</li><li>打开<code>控制台-个人设置</code>，打开<code>在 XMLRPC 接口中使用 Markdown 语法</code>（不打开的话会被解析为 html，当时被这个纠结过。）</li><li>打开 MWeb 的<code>偏好设置-发布服务</code>，点击<code>Metawebblog API</code>。按照要求填写即可。然后点击测试即可。</li></ol><blockquote><p>注：API 地址为：博客网址/action/xmlrpc 账号密码为发布人的账号密码。</p></blockquote><h2 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h2><p>我们需要两个插件，<code>coscmd</code>和<code>qcloud-cos-mweb</code>。他们的 github 连接如下。</p><p>[button color=”info” icon=”glyphicon glyphicon-download-alt” url=”<a href="https://github.com/tencentyun/coscmd&quot;">https://github.com/tencentyun/coscmd&quot;</a> type=””]Coscmd[/button]</p><p>[button color=”info” icon=”glyphicon glyphicon-download-alt” url=”<a href="https://github.com/scue/qcloud-cos-mweb&quot;">https://github.com/scue/qcloud-cos-mweb&quot;</a> type=””]qcloud-cos-mweb[/button]</p><ol><li>安装<code>coscmd</code>，打开控制台。输入<code>pip3 install coscmd == 1.8.5.5</code>（需要安装过 python3,为什么选择 coscmd 的 1.8.5.5 版本？因为最新版有 BUG。查过 issue 后得知只有 1.8.5.5 可以使用。）</li><li>找个自己能找到的地方输入<code>git clone https://github.com/scue/qcloud-cos-mweb.git</code>将其下载到本地。</li><li>输入<code>coscmd config -a &lt;secret_id&gt; -s &lt;secret_key&gt; -b &lt;bucket&gt; -r &lt;region&gt;</code>，或者直接<code>vim ~/.cos.conf</code>来设置相关信息<ul><li><code>&lt;secret_id&gt;</code> 与 <code>&lt;secret_key&gt;</code>可以在腾讯云的<code>控制台-访问管理-API密钥管理</code>中查看</li><li><code>&lt;bucket&gt;</code>对应<code>对象存储-相应的存储桶-基础配置</code>中的空间名称</li><li><code>&lt;region&gt;</code>对应<code>所属地域</code>后的<code>ap-xxxx</code></li><li>如果是通过 vim 修改的配置需要以下信息：<img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/blog/15562976545322.jpg" alt="-w453"></li></ul></li><li>用控制台进入到<code>qcloud-cos-mweb</code>，输入<code>./qcloud-cos-upload -help</code>查看监听地址。然后输入<code>./qcloud-cos-upload</code>运行该服务。</li><li>在图床自定义 API 地址输入：<code>http://监听地址/upload</code>，其余按照喜好填写即可。</li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>以后使用 Mweb 发布文章时，如果文章内有图片的话需要先点把图片上传至图床，然后在点击博客名称就可以发布文章了。在发布文章时一定要选择发布为 MarkDown。</p>]]></content>
    
    
    <categories>
      
      <category>旧博客文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MWEB</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
