<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/favicon.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="AruSeito"><meta name="keywords" content="React;前端;浏览器;JavaScript;ES6"><meta name="description" content="《深入浅出 React 和 Redux》 读书笔记React 与 Redux 的核心：UI&amp;#x3D;render(state) React关于 prop 与 state prop 用于定义外部接口，state 用于记录内部状态； prop 的赋值在外部世界使用组件时，state 的赋值在组件内部； 组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。  组件的生命周期React"><title>《深入浅出 React 和 Redux》 读书笔记 - AruSeito</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"aruseito.github.io",root:"/",version:"1.8.13",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"QXvDHP6t1WgrEQoS1UsGsjY6-gzGzoHsz",app_key:"DLqqm9fLeIp1t1CTt6A5hzxs",server_url:"https://qxvdhp6t.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="AruSeito" type="application/rss+xml">
</head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AruSeito</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg2.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="《深入浅出 React 和 Redux》 读书笔记"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> AruSeito </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-02-14 22:18" pubdate>2021/02/14 , 星期日 , 22:18</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 16 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">《深入浅出 React 和 Redux》 读书笔记</h1><p class="note note-info">本文最后更新于：2021/02/14 , 星期日 , 22:18</p><div class="markdown-body"><h1 id="《深入浅出-React-和-Redux》-读书笔记"><a href="#《深入浅出-React-和-Redux》-读书笔记" class="headerlink" title="《深入浅出 React 和 Redux》 读书笔记"></a>《深入浅出 React 和 Redux》 读书笔记</h1><p>React 与 Redux 的核心：UI=render(state)</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="关于-prop-与-state"><a href="#关于-prop-与-state" class="headerlink" title="关于 prop 与 state"></a>关于 prop 与 state</h3><ul><li>prop 用于定义外部接口，state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时，state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>React 生命周期可能会经历如下三个阶段：</p><ul><li>装载过程（Mount）：把组件第一次在 DOM 树中渲染的过程</li><li>更新过程（Update）：当组件被重新渲染的过程</li><li>卸载过程（Unmount）：组件从 DOM 中删除的过程</li></ul><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><p>装在过程中会依次调用以下函数：</p><ul><li>constructor</li><li>getInitialState</li><li>getDefaultProps</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>创造一个组件类的实例，会调用对应的构造函数。无状态的 React 组件不需要定义构造函数。目的：</p><ul><li>初始化 state</li><li>绑定成员函数的 this 环境</li></ul><h5 id="getInitialState-和-getDefaultProps"><a href="#getInitialState-和-getDefaultProps" class="headerlink" title="getInitialState 和 getDefaultProps"></a>getInitialState 和 getDefaultProps</h5><p>getInitialState 这个函数的返回值会用来初始化组件的 this.state。getDefaultProps 函数的返回值可以作为 props 的初始值。这两个函数只有用 React.createClass 方法创造的组件类才会发生作用。getInitialState 只出现在装载过程中，在一个组件的整个生命周期过程中，这个函数只被调用一次。使用 Es6 的话，在构造函数中通过给 this.state 赋值完成状态的初始化，通过给类属性 defaultProps 赋值指定 props 初始值。</p><h5 id="render"><a href="#render" class="headerlink" title="render"></a>render</h5><p>render 函数并不做实际的渲染动作，它只是返回一个 jsx 描述的结构，最终由 React 来操作渲染过程。render 函数应该是一个纯函数。</p><h5 id="componentWillMount-和-componentDidMount"><a href="#componentWillMount-和-componentDidMount" class="headerlink" title="componentWillMount 和 componentDidMount"></a>componentWillMount 和 componentDidMount</h5><p>componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染结果。<br>当 render 函数被调用完之后，componentDidMount 函数并不会被立刻调用，componentDidMount 被调用的时候，render 函数返回的东西已经引发了渲染，组件已经被“装载”到了 DOM 树上。<br>componentWillMount 可以再服务器端被调用，也可以在浏览器端被调用；而 componentDidMount 只能在浏览器端被调用。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><p>更新过程中会依次调用以下函数（并不是所有更新都会执行全部函数）：</p><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul><h5 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h5><p>当父组件的 render 函数被调用就会调用该函数。这个函数适合根据新的 props 值（也就是参数 nextProps）来计算出是不是要更新内部状态 state。</p><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h5><p>这个函数返回一个布尔值，告诉 react库这个组件在这次更新过程中是否要继续。可以作为优化点。</p><h5 id="componentWillUpdate-和-componentDidUpdate"><a href="#componentWillUpdate-和-componentDidUpdate" class="headerlink" title="componentWillUpdate 和 componentDidUpdate"></a>componentWillUpdate 和 componentDidUpdate</h5><p>当在服务器端使用 React 渲染时，componentDidUpdate 函数，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端都会被调用。使用 React 做服务器渲染时，基本不会经历更新过程，正常情况下服务器端不会调用 componentDidUpdate</p><h4 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h4><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h5><p>componentWillUnmount中的工作往往和 componentDidMount 有关</p><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>redux 强调的三个基本原则：</p><ul><li>唯一数据源</li><li>保持状态可读</li><li>数据改变只能通过纯函数完成</li></ul><h3 id="使用-Redux-过程"><a href="#使用-Redux-过程" class="headerlink" title="使用 Redux 过程"></a>使用 Redux 过程</h3><ol><li>定义 ActionType 和 Action 构造函数。</li><li>创建 reducer，根据 actionType分发动作，reducer 只负责计算状态，不负责存储状态</li><li>确定 Store 状态，创建 Store</li><li>在 view 中，保持 sotre 上状态和 this.state 同步。</li><li>派发 action</li></ol><h3 id="容器组件和傻瓜组件"><a href="#容器组件和傻瓜组件" class="headerlink" title="容器组件和傻瓜组件"></a>容器组件和傻瓜组件</h3><p>承担第一个任务的组件，负责和 Redux Store 打交道的组件，处于外层，叫做容器组件。承担第二个任务的组件，专心负责渲染页面的组件，处于内层，叫做展示组件。</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/09/29/rong-qi-zu-jian-he-sha-gua-zu-jian-de-fen-gong.png" srcset="/img/loading.gif" lazyload alt="容器组件和傻瓜组件的分工"></p><p>傻瓜组件就是一个纯函数，根据 props 产生结果，不需要 state<br>容器组件，承担所有和 Store 关联的工作，它的 render 函数是渲染傻瓜组件，负责传递必要的 prop。</p><h3 id="组件-Context"><a href="#组件-Context" class="headerlink" title="组件 Context"></a>组件 Context</h3><p>目的：入口文件引入 Store，其余组件避免直接导入 Store</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/09/30/react-de-context.png" srcset="/img/loading.gif" lazyload alt="React 的 Context"></p><p>使用：创建一个特殊的 React 组件，实现一个实例<code>getChildContext</code>方法，让其仅返回<code>store</code>，让 render 函数把子组件渲染出来。再定义 childContextTypes。子组件中也要定义相同的 childContextTypes，子组件中定义的构造函数参数要加上 context，store 的访问方式变为<code>this.context.store.xxx</code></p><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><p>React-Redux 中的 connect：连接容器组件和傻瓜组件，Provider: 提供包含 Store 的 context</p><h2 id="模块化-React-和-Redux-应用"><a href="#模块化-React-和-Redux-应用" class="headerlink" title="模块化 React 和 Redux 应用"></a>模块化 React 和 Redux 应用</h2><h3 id="代码文件的组织方式"><a href="#代码文件的组织方式" class="headerlink" title="代码文件的组织方式"></a>代码文件的组织方式</h3><p>每个基本功能对应一个功能模块，每个模块对应一个目录</p><h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>明确这个模块的对外的接口，这个接口应实现把内部封装起来。</p><h3 id="状态树的设计"><a href="#状态树的设计" class="headerlink" title="状态树的设计"></a>状态树的设计</h3><ul><li>一个模块控制一个状态节点：如果 A 模块的 reducer 负责修改状态树上 a 字段下的数据，name 另一个模块 B 的 reducer 就不能修改 a 字段下的数据。</li><li>避免冗余数据</li><li>树形结构扁平</li></ul><h2 id="React-组件的性能优化"><a href="#React-组件的性能优化" class="headerlink" title="React 组件的性能优化"></a>React 组件的性能优化</h2><h3 id="性能分析（React-16-与-Chrome-开发者工具）"><a href="#性能分析（React-16-与-Chrome-开发者工具）" class="headerlink" title="性能分析（React 16 与 Chrome 开发者工具）"></a>性能分析（<a target="_blank" rel="noopener" href="https://calibreapp.com/blog/react-performance-profiling-optimization/">React 16 与 Chrome 开发者工具</a>）</h3><h3 id="单个-React-组件的性能优化"><a href="#单个-React-组件的性能优化" class="headerlink" title="单个 React 组件的性能优化"></a>单个 React 组件的性能优化</h3><h4 id="React-Redux-的-shouldComponentUpdate-实现"><a href="#React-Redux-的-shouldComponentUpdate-实现" class="headerlink" title="React-Redux 的 shouldComponentUpdate 实现"></a>React-Redux 的 shouldComponentUpdate 实现</h4><p>React 组件类的父类 Component 提供了 shouldComponentUpdate 的默认实现方式，只简单返回 true。当需要达到更高性能时需要自定义 shouldComponentUpdate。</p><p>react-redux 用的是尽量简单的方法，做的是“浅层比较”（和 js 中的===类似），如果 prop 的类型是字符串或者数字，只要值相同，那么“浅层比较”的方法会认为二者相同，如果 prop 的类型是复杂对象，那么“浅层比较”的方式只看这两个 prop 是不是同一对象的引用。</p><h3 id="多个-React-组件的性能优化"><a href="#多个-React-组件的性能优化" class="headerlink" title="多个 React 组件的性能优化"></a>多个 React 组件的性能优化</h3><h4 id="React-的调和过程"><a href="#React-的调和过程" class="headerlink" title="React 的调和过程"></a>React 的调和过程</h4><p>当 React 要对比两个 Virtual DOM 的树形结构的时候，从根节点开始递归往下比对，在树形结构上，每个节点都可以看作一个这个节点以下部分子树的根节点。所以其实这个对比算法可以从 Virtual DOm 上任何一个节点开始。</p><p>React 首先检查两个树形的根节点的类型是否相同，根据相同或者不同有不同处理方式。</p><h5 id="节点类型不同的情况"><a href="#节点类型不同的情况" class="headerlink" title="节点类型不同的情况"></a><strong>节点类型不同的情况</strong></h5><p>如果树形结构根节点类型不相同，直接认为原来那个树形结构已经没用，可以扔掉，需要重新构建新的 DOM 树，原有的树形上的 React 组件会经历“卸载”的生命周期。这时候componentWillUnmount 方法会被调用，取而代之的组件则会经历装载过程的生命周期，组件的 componentWillMount、render 和 componentDidMount 方法依次被调用。也就是说，对于 Virtual DOM 树这是一个“更新”过程，但是却可能引发这个树结构上某些组件的“装载”和“卸载”过程。</p><p>作为开发者，一定要避免作为包裹功能的节点类型被随意改变。</p><p>如果 React 对比两个树形结构的根节点发现类型相同，那么就觉得可以重用原来的节点，进入更新阶段，按照下一步骤来处理。</p><h5 id="节点类型相同的情况"><a href="#节点类型相同的情况" class="headerlink" title="节点类型相同的情况"></a><strong>节点类型相同的情况</strong></h5><p>两个树形结构的根节点类型相同，React 就认为原来的根节点只需要更新过程，不会将其卸载，也不会引发根节点的重新装载。</p><p>对于 DOM 类型元素，React 会保留节点对应的 DOM 元素，只对树形结构根节点上的树形和内容做一下比对，然后只更新修改的部分。</p><p>对于 React 组件类型，React能做的只是根据新节点的 props 去更新原来根节点的组件实例，引发这个组件实例的更新过程。在这个过程中，如果 shouldComponentUpdate 函数返回 false，更新过程就此打住，不再继续。</p><p>在处理完根节点的对比后，React 的算法会对根节点的每个子节点重复一样的动作，这时候每个子节点就成为它所覆盖部分的根节点，处理方式和它的父节点完全一样。</p><h5 id="多个子组件的情况"><a href="#多个子组件的情况" class="headerlink" title="多个子组件的情况"></a><strong>多个子组件的情况</strong></h5><p>在序列后增加一个新的组件，React 会发现多出了一个组件，会创建一个新的组件实例，这个组件实例需要经历装载过程，对于之前的实例，React 会引发他们的更新过程，只要shouldComponentUpdate 函数实现恰当，检查 props 之后就返回 false 的话，可以避免实质的更新操作。</p><p>在序列前增加一个新的组件，React 会挨个比较，认为新增的组件是之前第一个组件属性的变更，并增加了最后一个组件。</p><p>使用 key 可以克服这种浪费</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>key 在代码中可以明确的告诉 react 每个组件的唯一标识。</p><p>当遇到在序列前添加一个新的组件时，React 根据 key 值，可以知道之前的组件，所以 React 会把新创建的组件插在前面，对于原有组件实例只用原有的 props 来启动更新过程。</p><h3 id="用-reselect-提高数据获取性能"><a href="#用-reselect-提高数据获取性能" class="headerlink" title="用 reselect 提高数据获取性能"></a>用 reselect 提高数据获取性能</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>只要相关状态没有改变，那就直接使用上一次的缓存结果。</p><h4 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h4><ol><li>从输入参数 state 抽取第一层结果，将这第一层结果和之前抽取的第一层结果做比较，如果发现完全相同，就没有必要进行第二部分运算了，选择器直接把之前第二部分的运算结果返回就可以了。这里的比较就是 js 中的<code>===</code>操作符比较，如果第一层结果是对象的话，只有是同一对象才会被认为是相同。</li><li>根据第一层结果计算出选择器需要返回的最终结果</li></ol><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>步骤一运算因为每次选择器都要使用，所以一定要快，运算要非常简单，最好是一个映射运算，通常就只是从 state 参数中得到某个字段的引用就足够，把剩下来的重活累活都交给步骤二去做。</p><h2 id="React-高级组件（大概略读了一下，以后再细看，待更新）"><a href="#React-高级组件（大概略读了一下，以后再细看，待更新）" class="headerlink" title="React 高级组件（大概略读了一下，以后再细看，待更新）"></a>React 高级组件（大概略读了一下，以后再细看，待更新）</h2><h2 id="Redux-和-服务器通信"><a href="#Redux-和-服务器通信" class="headerlink" title="Redux 和 服务器通信"></a>Redux 和 服务器通信</h2><h3 id="React-组件访问服务器"><a href="#React-组件访问服务器" class="headerlink" title="React 组件访问服务器"></a>React 组件访问服务器</h3><p>通常在组件的 ComponentDidMount 函数中做请求服务器的事情，因为当该函数被调用时，装载过程已完成，组件需要渲染的内容已经出现在 DOM 树上。</p><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/12/15708622641712.jpg" srcset="/img/loading.gif" lazyload alt="-w615"></p><p>fetch 函数返回的结果是一个 Promise 对象。fetch 认为只要服务器返回一个合法的 HTTP 响应就算成功，就会调用 then 提供的回调函数。也就是说 当 HTTP 响应的状态码为 400 或者 500 的时候也会调用 then。</p><h3 id="Redux-访问服务器"><a href="#Redux-访问服务器" class="headerlink" title="Redux 访问服务器"></a>Redux 访问服务器</h3><h4 id="redux-thunk-中间件"><a href="#redux-thunk-中间件" class="headerlink" title="redux-thunk 中间件"></a>redux-thunk 中间件</h4><p>Redux-thunk 的思路：在 Redux 的单向数据流中，在 action 对象被 reducer 函数处理之前，是插入异步功能的时机。</p><p>在 Redux 架构下，一个 action 对象在通过 store.dispatch 派发，在调用 reducer 函数之前，会先经过一个中间件的环节，这就是产生异步操作的机会，实际上 redux-thunk 提供的就是一个 Redux 中间件，需要在创建 Store 时用上这个中间件。</p><p><img src="https://chenxiumiao-1252816278.cos.ap-beijing.myqcloud.com/2019/10/12/redux-de-action-chu-li-liu-cheng.png" srcset="/img/loading.gif" lazyload alt="Redux 的 action 处理流程"></p><h3 id="异步-action-对象"><a href="#异步-action-对象" class="headerlink" title="异步 action 对象"></a>异步 action 对象</h3><p>redux-thunk 的工作是检查 action 对象是否为函数，如果不是函数就放行，完成普通 action 对象的生命周期，如果发现 action 对象是函数，那就执行这个函数，并把 Store 的 dispatch 的函数和 getState 函数作为参数传递到函数中去，处理过程到此为止，会让这个异步 action 对象继续往前派发到 reducer 函数。</p><p>异步 action 构造函数的代码基本上都是如下套路：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> sampleAsyncAction = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch,getState</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//在这个函数里可以调用一步函数，</span><br>        <span class="hljs-comment">//自行决定在合适的实际通过 dispatch 参数</span><br>        <span class="hljs-comment">//派发出新的 action 对象</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%97%A7%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">旧博客文章</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a> <a class="hover-with-bg" href="/tags/React/">React</a> <a class="hover-with-bg" href="/tags/Redux/">Redux</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/article/ffeb6d55/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">脚手架开发记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/article/aa58022d/"><span class="hidden-mobile">TS学习记录</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/custom.js"></script><script src="/js/boot.js"></script></body></html>