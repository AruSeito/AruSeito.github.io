<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/favicon.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="AruSeito"><meta name="keywords" content="React,源码"><meta name="description" content="理念篇如何学？将 React 完整的运行过程可以分为三个部分：产生更新、决定更新什么组件、将更新的组件渲染到页面。即：调度、协调、渲染。 设计理念React 哲学:React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式 目前 web 端快速响应的两大瓶颈：计算能力和网络延迟。对应的也就分别是 CPU 和 IO。 1000ms&amp;#x2F;60Hz &amp;#x3D; 16.6ms 浏览器刷新一"><title>《自顶向下学 React 源码》学习笔记 - AruSeito</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"aruseito.github.io",root:"/",version:"1.8.13",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"QXvDHP6t1WgrEQoS1UsGsjY6-gzGzoHsz",app_key:"DLqqm9fLeIp1t1CTt6A5hzxs",server_url:"https://qxvdhp6t.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="AruSeito" type="application/rss+xml"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>AruSeito</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg26.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="《自顶向下学 React 源码》学习笔记"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> AruSeito </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-07 17:47" pubdate>2021/08/07 , 星期六 , 17:47</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 20k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 64 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">《自顶向下学 React 源码》学习笔记</h1><p class="note note-info">本文最后更新于：2021/12/12 , 星期日 , 19:24</p><div class="markdown-body"><h2 id="理念篇"><a href="#理念篇" class="headerlink" title="理念篇"></a>理念篇</h2><h3 id="如何学？"><a href="#如何学？" class="headerlink" title="如何学？"></a>如何学？</h3><p>将 React 完整的运行过程可以分为三个部分：产生更新、决定更新什么组件、将更新的组件渲染到页面。即：调度、协调、渲染。</p><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/thinking-in-react.html">React 哲学</a>:React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式</p><p>目前 web 端快速响应的两大瓶颈：计算能力和网络延迟。对应的也就分别是 CPU 和 IO。</p><p>1000ms/60Hz = 16.6ms 浏览器刷新一次。</p><p>在这 16.6ms 之间，会依次 JS 脚本执行-&gt;样式布局-&gt;样式绘制</p><p>如果 JS 的脚本执行时间超过 16.6ms，就会掉帧。</p><p>以前的方案主要有：防抖和节流。但是治标不治本。</p><p>防抖：指定时间内不继续操作后执行。</p><p>节流：指定时间内只执行一次。</p><p>React 的做法是实现一种异步可中断的更新机制。</p><p>浏览器预留时间给 React，React 用这部分时间来干自己的事，如果这段时间内没干完，那么 React 就将控制权交回给浏览器，等下一次的预留时间。所以浏览器就有充足的时间进行样式布局+样式绘制。</p><h3 id="架构的演化"><a href="#架构的演化" class="headerlink" title="架构的演化"></a>架构的演化</h3><h4 id="老-React-的架构（15-及以前）"><a href="#老-React-的架构（15-及以前）" class="headerlink" title="老 React 的架构（15 及以前）"></a>老 React 的架构（15 及以前）</h4><p>老 React 中可以分为两部分：决定渲染组件（协调器）-》将组件渲染到视图中（渲染器）。</p><p>协调器（Reconciler）中会进行 Diff 算法，算出哪些需要更新，然后将要更新的内容交给渲染器（Render）中。</p><p>问题：</p><p>协调器与渲染器是依次执行工作。如果同时更新多个节点，第一个 DOM 会先发生变化，但是因为更新过程是同步的，所以会同时渲染出来。如果在这种老的架构上实现异步可中断许安然的话，在渲染过程中发生中断，协调器和渲染工作还在继续，但是第一个组件会先渲染完，其他组件没变化，所以推出了 16 这种架构。</p><h4 id="新-React-的架构（16-及以后）"><a href="#新-React-的架构（16-及以后）" class="headerlink" title="新 React 的架构（16 及以后）"></a>新 React 的架构（16 及以后）</h4><p>新 React 中分为三部分：调度更新（调度器）-&gt;决定更新什么（协调器）-&gt;将组件更新到视图中（渲染器）。</p><p>调度器会对更新项分配优先级，将高优先级的先交给协调器，接着创建虚拟 DOM，然后协调器进行 Diff 算法，给变化的 DOM 打上标记，再将更新的内容交给渲染器，由渲染器来执行视图操作，。如果在进行 Diff 的过程中来了新的更高优先级的更新项，则将正在 Diff 的更新项中断，先进行高优先级的 Diff。循环以上操作。因为这些操作都在内存中操作，用户并不会感知。（跟离线操作 DOM 一个意思）</p><h3 id="React-的新架构-—-Fiber"><a href="#React-的新架构-—-Fiber" class="headerlink" title="React 的新架构 —- Fiber"></a>React 的新架构 —- Fiber</h3><p>Fiber 是协程的一种实现方式，另一种协程的实现方式为 Generator。不采用 Generator 的原因：Generator 和 async 一样都具有传染性。更新可以中断并继续，更新具有优先级，高优先级可以打断低优先级。</p><h3 id="Fiber-的含义"><a href="#Fiber-的含义" class="headerlink" title="Fiber 的含义"></a>Fiber 的含义</h3><h4 id="从架构的角度来说"><a href="#从架构的角度来说" class="headerlink" title="从架构的角度来说"></a>从架构的角度来说</h4><ul><li><p>老 React 的架构：Reconciler 采用递归的方式执行，数据保存在递归的调用栈中，所以被称为 Stack Reconciler。</p></li><li><p>新 React 的架构：Reconciler 基于 Fiber 的节点实现，所以成为 Fiber Reconciler</p></li></ul><h4 id="从静态数据结构来说"><a href="#从静态数据结构来说" class="headerlink" title="从静态数据结构来说"></a>从静态数据结构来说</h4><p>每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的 DOM 节点等信息。</p><p>一个 React 应用中只能有一个 FiberRootNode，一个 FiberRootNode 最多有两个 RootFiber。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210807/%E4%BD%9C%E4%B8%BA%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="静态数据结构"></p><p>为什么父节点连接子节点用 child，子节点使用 Return 连接父节点？因为 React 15 中 Stack Reconciler 采用递归的方式，先从根递到子节点，在从子节点归到根，所以归阶段函数处理完会用 Return。在 Fiber Reconciler 采用遍历的方式，实现可中断的递归，所以复用了这种方式。</p><h4 id="作为动态工作单元"><a href="#作为动态工作单元" class="headerlink" title="作为动态工作单元"></a>作为动态工作单元</h4><p>每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。</p><h3 id="Fiber-的工作原理"><a href="#Fiber-的工作原理" class="headerlink" title="Fiber 的工作原理"></a>Fiber 的工作原理</h3><h4 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h4><p>正常动画播放：先删除前一帧，然后计算当前帧，显示当前帧。如果当前帧计算量特别大就会有特别长的白屏时间。</p><p>在内存中绘制当前帧，绘制完后替换前一帧。（这不还是离线操作 DOM 的操作）</p><h4 id="Fiber-树双缓存"><a href="#Fiber-树双缓存" class="headerlink" title="Fiber 树双缓存"></a>Fiber 树双缓存</h4><h5 id="挂载时"><a href="#挂载时" class="headerlink" title="挂载时"></a>挂载时</h5><ol><li><p>运行<code>ReactDom.render</code>会创建一个 <code>FiberRoot</code> 和 <code>rootFiber</code>。<code>FiberRoot</code> 是整个应用的根结点，有且仅有一个。然后 <code>FiberRoot</code> 的 <code>current</code> 指针会指向页面上已经渲染好了的 Fiber 树上（<code>FiberRoot.current = rootFiber</code>）。<code>fiberRoot</code> 的 <code>current</code> 会指向当前页面上已渲染内容对应 Fiber 树，即 <code>current Fiber 树</code>。因为是首屏渲染，所以 rootFiber 下并没有任何东西。</p></li><li><p>进入<code>Render</code>阶段，根据组件的 JSX 创建 Fiber 树（<code>workInProgress Fiber</code>）。在创建的过程中会尝试复用<code>current fiber</code>上已有节点的属性。</p></li><li><p>进入<code>Commit</code>阶段 ，将 current 指针指向 <code>workInProgress 树</code>，成为 <code>current Fiber 树</code>。</p></li></ol><h5 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h5><ol><li><p>进入<code>Render</code>阶段，根据组件的 JSX 一棵新的 <code>workInProgress Fiber</code>。在创建的过程中会尝试复用<code>current fiber</code>上已有节点的属性。</p></li><li><p><code>workInProgress Fiber 树</code>在<code>Render阶段</code>完成构建后进入<code>Commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为<code>current Fiber 树</code>。</p></li></ol><h2 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h2><p>Render 阶段指 调和器工作的阶段，主要是打标记（effectTag）是 Update 还是 Replace 等操作，并非指 Render 运行的阶段。Render 方法运行的阶段成为 Commit 阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/20210808/%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="三个阶段"></p><h3 id="挂载时-1"><a href="#挂载时-1" class="headerlink" title="挂载时"></a>挂载时</h3><p>用<code>CRA</code>创建一个最基础的 React 应用，用 devTool 录制一个从 0 到 1 的火炬图。</p><p>在 Render 阶段经历了如下：（可以在 beginWork 和 completeWork 打个断点看一下，看笔记想不起来记得再手动调试一次,记得对着 CRA 创建的 DEMO 代码看）</p><p>废话连篇:首先进入 BeginWork 的三个参数分别为 <code>current, workInProgress, renderLanes</code>。因为是首次运行，所以 current 的 Tag 为<code>3</code>，代表<code>HostRoot</code>，然后恢复脚本执行。又到了 BeginWork 的断点处，这时<code>current</code>为空,<code>workInProgress</code>的 ElementType 为<code>f APP()</code>。再放开<code>workInProgress</code>又变成<code>div</code>。再放开是<code>header</code>,然后再放开是<code>img</code>，这时候因为 img 没有任何子节点，所以再放开后到了 completeWork，执行完后，会再寻找 img 的兄弟节点，然后找到了 P 标签，进入<code>beginWork</code>，再找 P 的子节点，先<code>Edit</code>begin 再 completed，接着是<code>Code</code>，因为 Code 内的子节点是纯文本，所以直接采用优化方案，不会找子节点，直接进入<code>completeWork</code>,然后再是最后的文本<code>and save to reload.</code>，执行完后进入父节点的<code>completeWork</code>。</p><p>总结：根 beginWork-&gt;子节点 beginWork-如果有子节点-&gt;一直直行到最后一个子节点时，执行父节点的 completeWork; -如果子节点没有子节点-&gt;执行自己的 completeWork-&gt;然后找到兄弟元素。(深度优先遍历，遇到有唯一文本节点的，不会创建他的 Fiber 节点)</p><p>专业总结:首先从<code>rootFiber</code>开始向下深度优先遍历,为遍历到的每个 Fiber 节点调用<code>beginWork</code>方法。当遍历到没有子组件的组件时就会进入“归”阶段。在归阶段调用<code>completeWork</code>,当某个 Fiber 节点执行完<code>completeWork</code>，如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。</p><p><a target="_blank" rel="noopener" href="https://react.iamkasong.com/process/reconciler.html#%E4%BE%8B%E5%AD%90">卡颂老师的 DEMO</a></p><p>为什么 EffectTag 是用二进制？ 因为如果要插入一个元素到页面中，然后还要替换他的属性，那就要标记成 Update 和 Placement。用二进制可以很快的进行标记。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> NoFlags = <span class="hljs-comment">/*                      */</span> <span class="hljs-number">0b00000000000000000000000</span>;<br><br><span class="hljs-keyword">const</span> Placement = <span class="hljs-comment">/*                    */</span> <span class="hljs-number">0b00000000000000000000010</span>;<br><br><span class="hljs-keyword">const</span> Update = <span class="hljs-comment">/*                       */</span> <span class="hljs-number">0b00000000000000000000100</span>;<br><br><span class="hljs-keyword">const</span> PlacementAndUpdate = <span class="hljs-comment">/*           */</span> Placement | Update;<br><br><span class="hljs-comment">// 首先有个元素,初始状态为没变化</span><br><span class="hljs-keyword">let</span> effectTag = NoFlags;<br><br><span class="hljs-comment">// 先插入，按位或</span><br>effectTag |= Placement; <span class="hljs-comment">//2 === 0b00000000000000000000010</span><br><span class="hljs-comment">// 然后更新</span><br>effectTag |= Update; <span class="hljs-comment">// 6 === 0b00000000000000000000110</span><br><br>(effectTag &amp; PlacementAndUpdate) !== NoFlags; <span class="hljs-comment">//True</span><br></code></pre></div></td></tr></table></figure><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>beginWork：当一个节点进入 beginWork 时，目的是为了创建当前 Fiber 节点的第一个子 Fiber 节点，判断当前 Fiber 节点的类型，进入不同的 Update 逻辑。在进入 Update 逻辑后，会先判断 WorkInProgress Fiber 中是否有对应的 Current Fiber，来决定是否标记 EffectTag（在 17.0.3 中更名为 ReactFiberFlags），接着判断当前 Fiber 节点的 child 的类型，来执行不同的创建操作，创建不同的子 Fiber 节点。</p><p>completeWork：根据 WorkInProgress 的 tag，进入不同操作。首先为 Fiber 节点创建对应的 DOM 节点， 然后挂到 Fiber 节点的 StateNode （已经构建好的 DOM 树）上。然后将 DOM 节点插入到之前创建好的 DOM 树中，然后初始化 DOM 对象的属性。</p><p><img src="https://react.iamkasong.com/img/beginWork.png" srcset="/img/loading.gif" lazyload alt="beginWork"><br><img src="https://react.iamkasong.com/img/completeWork.png" srcset="/img/loading.gif" lazyload alt="completeWork"></p><h3 id="更新时-1"><a href="#更新时-1" class="headerlink" title="更新时"></a>更新时</h3><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>beginWork：先判断是否可以复用，如果可以复用直接 Clone 在 current 中对应的 Fiber 节点。如果不能复用，判断当前 Fiber 节点的类型，进入不同的 Update 逻辑，在这里面会使用 JSX 对象与 current Fiber 节点进行对比，将对比的结果创建一个 fiber 节点并返回。</p><p>completeWork：先 diff props，返回一个需要更新的属性名称构成的数组（[key1，value1,key2,value2…]）然后赋值给 workInpProgress.updateQueue，最后再将 effectTag 的 fiber 挂载在父级 fiber 的 effectList 末尾，并返回 workInProgress Fiber 树。</p><p>作为 DOM 操作的依据，commit 阶段需要找到所有有 effectTag 的 Fiber 节点并依次执行 effectTag 对应操作？</p><p>每个执行完 completeWork 且存在 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。effectList 中第一个 Fiber 节点保存在 fiber.firstEffect，最后一个元素保存在 fiber.lastEffect。类似 appendAllChildren，在“归”阶段，所有有 effectTag 的 Fiber 节点都会被追加在 effectList 中，最终形成一条以 rootFiber.firstEffect 为起点的单向链表。这样，在 commit 阶段只需要遍历 effectList 就能执行所有 effect 了。</p><ul><li>注意：近期 React 团队有在重构 Effect List（v18），老的会生成 Effect List，然后在 commit 阶段，直接遍历 EffectList 就能找到所有副作用的节点并执行对应的操作。在重构会会将子节点的副作用冒泡到父节点的 SubtreeFlags 属性。详细可见卡老师的另外一篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-UNN45YttXJPA2TlrnSy3Q">React Effects List 大重构，是为了他？</a></li></ul><h2 id="Commit-阶段"><a href="#Commit-阶段" class="headerlink" title="Commit 阶段"></a>Commit 阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/image-hosting-service@main/2021/12/05/20211205130037.png" srcset="/img/loading.gif" lazyload alt="2021/12/05/20211205130037"><br>主要工作分为三部分：</p><ul><li><p>before mutation 阶段（执行 DOM 操作前）</p></li><li><p>mutation 阶段（执行 DOM 操作）</p></li><li><p>layout 阶段（执行 DOM 操作后）</p></li></ul><h3 id="beforeMutation-阶段"><a href="#beforeMutation-阶段" class="headerlink" title="beforeMutation 阶段"></a>beforeMutation 阶段</h3><ol><li><p>遍历 effectList 并调用<code>commitBeforeMutationEffects</code>函数处理</p></li><li><p>commitBeforeMutationEffects 处理有三步</p><ol><li><p>处理 DOM 节点渲染/删除后 focus 和 blur 逻辑</p></li><li><p>如果是类组件会调用<code>getSnapshotBeforeUpdate</code>生命周期：通过<code>finishedWork.stateNode</code>取得对应 Fiber 节点的原型。如果是函数组件会直接 return 出去。</p></li><li><p>调度<code>useEffect</code>：如果是函数组件，并且他的<code>useEffect</code>被标记为<code>Passive</code> 会在这调度。以 NormalSchedulerPriority 为优先级，异步执行<code>flushPassiveEffects</code>（也就是<code>useEffect</code>的回调函数），由于<code>commit</code>阶段是同步执行的，所以<code>useEffect</code>的回调函数是在 commit 阶段执行完执行的。</p></li></ol></li></ol><h3 id="mutation-阶段"><a href="#mutation-阶段" class="headerlink" title="mutation 阶段"></a>mutation 阶段</h3><ol><li><p>遍历 effectList，并调用<code>commitMutationEffects</code></p></li><li><p><code>commitMutationEffects</code>会遍历 effectList，对每个 Fiber 节点执行如下三个操作：</p><ol><li><p>根据 ContentReset effectTag 重置文字节点</p></li><li><p>更新 ref（对应生命周期图中的 更新 DOM 和 refs）</p></li><li><p>根据 effectTag 分别处理，其中 effectTag 包括（Placement | Update | Deletion | Hydrating）</p></li></ol></li></ol><h4 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h4><p>当 Fiber 节点含有 Placement effectTag，意味着该 Fiber 节点对应的 DOM 节点需要插入到页面中。调用 commitPlacement</p><ol><li><p>向上递归获取该 Fiber 节点的父级 Fiber 节点。</p></li><li><p>根据 fiber 节点找到对应的 DOM 节点（通过 fiber 节点上的 stateNode 属性），然后根据 Fiber 的 Tag 判断是不是 container（HostRoot 和 HostPortal 标记为 true，HostComponent 和 FundamentalComponent 标记为 false）</p></li><li><p>获取该 Fiber 节点的兄弟 DOM。</p></li><li><p>根据 DOM 兄弟节点存在决定调用<code>insertBefore</code> 或<code>appendChild</code>执行 DOM 插入操作</p></li></ol><ul><li>getHostSibling（获取兄弟 DOM 节点）的执行很耗时，当在同一个父 Fiber 节点下依次执行多个插入操作，getHostSibling 算法的复杂度为指数级。</li></ul><p>这是由于 Fiber 节点不只包括 HostComponent，所以 Fiber 树和渲染的 DOM 树节点并不是一一对应的。要从 Fiber 节点找到 DOM 节点很可能跨层级遍历。</p><h4 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h4><p>当 Fiber 节点含有 Update effectTag，意味着该 Fiber 节点需要更新。调用的方法为 commitWork，他会根据 Fiber.tag 分别处理。</p><p>当 fiber.tag 为 FunctionComponent，会调用 commitHookEffectListUnMount。该方法会遍历 effectList，执行所有 useLayoutEffect hook 的销毁函数。</p><p>当 fiber.tag 为 HostComponent，会调用 commitUpdate，更新 Props 和 DOM 的属性。最终会在 updateDOMProperties 中将 render 阶段 completeWork 中为 Fiber 节点赋值的 updateQueue 对应的内容（diff 的结果）渲染在页面上。</p><h4 id="PlacementAndUpdate-effect"><a href="#PlacementAndUpdate-effect" class="headerlink" title="PlacementAndUpdate effect"></a>PlacementAndUpdate effect</h4><p>先执行 placement effect 的内容，再执行 Update effect 的内容</p><h4 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h4><p>当 Fiber 节点含有 Deletion effectTag，意味着该 Fiber 节点对应的 DOM 节点需要从页面中删除。调用的方法为 commitDeletion。</p><ol><li><p>如果是<code>HostComponent</code>或<code>HostText</code>,递归查找的，首先找到它的父级 Fiber 节点，然后在找到它的子孙节点（因为这个整体相当于一个树，消除一个节点，他的下级也要被销毁）。然后调用<code>commitUnmount</code>。</p></li><li><p>如果是函数组件及其相似的，遍历 effectList，进行注册 useEffect 的回调（将 fiber 节点和 effect 的回调放到一个 unmountEffects 队列中）进行调度。</p></li><li><p>如果是类组件，会解绑 Ref，然后调用生命周期中的 componentWillUnmount</p></li><li><p>如果是 <code>HostComponent</code>，会解绑 Ref</p></li></ol><h3 id="mutation-阶段之后-Layout-阶段之前"><a href="#mutation-阶段之后-Layout-阶段之前" class="headerlink" title="mutation 阶段之后 Layout 阶段之前"></a>mutation 阶段之后 Layout 阶段之前</h3><p>在这里会执行双缓存的原理，将 current 指针从 current 树，指向 workInProgress 树。</p><p>为什么在这里执行？</p><p>简单说就是为了确保每个阶段的树能对应上。</p><p>因为 mutation 阶段时需要执行 componentWillUnmount，需要操作 current 树，而 layout 阶段要执行 componentDidMount/Update，需要跟新的 current 树对应上</p><p>卡老师总结版：componentWillUnmount 会在 mutation 阶段执行，此时 current Fiber 树还指向前一次更新的 Fiber 树，在生命周期钩子内获取的 DOM 还是更新前的。componentDidMount 和 componentDidUpdate 会在 layout 阶段执行。此时 current Fiber 树已经指向更新后的 Fiber 树，在生命周期钩子内获取的 DOM 就是更新后的。</p><h3 id="Layout-阶段"><a href="#Layout-阶段" class="headerlink" title="Layout 阶段"></a>Layout 阶段</h3><p>Layout 阶段也是遍历 effectList，执行 commitLayoutEffects 方法。</p><ol><li><p>如果是函数组件会执行<code>useLayoutEffect</code>，如果是类组件会根据 current 有无来判断执行<code>componentDidMount</code>还是<code>componentDidUpdate</code>，并且还会生成会取一个<code>updateQueue</code>，这里存放的其实是 setState 的第二个参数，依赖于未更新前的 dom 属性来操作，也是在这调用的。如果<code>HostRoot</code>，也会有一个<code>updateQueue</code>，存放的是 render 的第三个参数。</p></li><li><p>hostComponent 或 class Component 存在 Ref 时，处理 Ref。</p></li></ol><h4 id="UseEffect-和-UseLayoutEffect-区别"><a href="#UseEffect-和-UseLayoutEffect-区别" class="headerlink" title="UseEffect 和 UseLayoutEffect 区别"></a>UseEffect 和 UseLayoutEffect 区别</h4><table><thead><tr><th align="center"></th><th align="center">useEffect</th><th align="center">useLayoutEffect</th></tr></thead><tbody><tr><td align="center">beforeMutation</td><td align="center">调度 flushPassiveEffects</td><td align="center">无</td></tr><tr><td align="center">mutation</td><td align="center">无</td><td align="center">执行 destroy</td></tr><tr><td align="center">layout</td><td align="center">注册 destroy 和 create</td><td align="center">执行 create</td></tr><tr><td align="center">commit 阶段完成后</td><td align="center">执行 flushPassiveEffects，内部执行注册的回调</td><td align="center">无</td></tr></tbody></table><h3 id="useEffect-的异步调用"><a href="#useEffect-的异步调用" class="headerlink" title="useEffect 的异步调用"></a>useEffect 的异步调用</h3><ol><li><p><code>before mutation</code>阶段在<code>scheduleCallback</code>中调度<code>flushPassiveEffects</code>（对应的本文<code>beforeMutation</code>阶段的第三步）</p></li><li><p><code>layout</code> 阶段之后将 <code>effectList</code> 赋值给 <code>rootWithPendingPassiveEffects</code></p></li><li><p><code>scheduleCallback</code> 触发 <code>flushPassiveEffects</code>， <code>flushPassiveEffects</code> 内部遍历 <code>rootWithPendingPassiveEffects</code></p></li></ol><h4 id="为什么需要异步调用useEffect？"><a href="#为什么需要异步调用useEffect？" class="headerlink" title="为什么需要异步调用useEffect？"></a>为什么需要异步调用<code>useEffect</code>？</h4><blockquote><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p></blockquote><p>所以<code>useEffect</code>主要是防止同步执行时阻塞浏览器渲染。</p><h2 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h2><p><img src="https://cdn.jsdelivr.net/gh/AruSeito/image-hosting-service@main/2021/12/05/20211205222940.png" srcset="/img/loading.gif" lazyload alt="2021/12/05/20211205222940"></p><p>与 DOM 节点有关的概念：</p><ol><li><p>current Fiber。如果该 DOM 节点已在页面中，current Fiber 代表该 DOM 节点对应的 Fiber 节点</p></li><li><p>workInProgress Fiber。如果该 DOM 节点将在本次更新中渲染到页面中，workInProgress Fiber 代表该 DOM 节点对应的 Fiber 节点。</p></li><li><p>DOM 节点本身。</p></li><li><p>JSX 对象。即 ClassComponent 的 render 方法的返回结果，或 FunctionComponent 的调用结果。JSX 对象中包含描述 DOM 节点的信息。</p></li></ol><p>diff 的本质就是比较 1 和 4，然后生产 2。</p><p>为了降低时间复杂度，React 的 diff 算法有三个限制</p><ol><li><p>只比较同级的元素。如果前后两次中某节点跨级了，那么 React 不会复用。</p></li><li><p>只比较相同类型的节点。如果元素由 div 变为 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点。</p></li><li><p>开发者通过 key 来保持稳定。</p></li></ol><h3 id="diff-如何实现？"><a href="#diff-如何实现？" class="headerlink" title="diff 如何实现？"></a>diff 如何实现？</h3><p><code>reconcileChildFibers</code>函数会根据 newChild（即 JSX 对象）类型调用不同的处理函数。</p><ol><li><p>当 newChild 类型为 object、number、string，代表同级只有一个节点</p></li><li><p>当 newChild 类型为 Array，同级有多个节点</p></li></ol><h4 id="单节点时"><a href="#单节点时" class="headerlink" title="单节点时"></a>单节点时</h4><ul><li><p>如果 currentFiber 树中存在对应的节点并遍历。</p><ul><li><p>如果 key 相同，type 相同，标记它的兄弟节点为 Deletion。再复用老的 Fiber，然后 return 出去</p></li><li><p>如果 key 相同，type 不同，先标记它及其兄弟为 Deletion，跳出循环，再根据 JSX 对象创建一个新的 Fiber 节点</p></li></ul></li><li><p>如果 currentFiber 树中不存在对应的节点，直接根据 JSX 对象创建一个新 Fiber 节点。</p></li></ul><p>卡老师总结版：</p><p>上次更新时的 fiber 节点是否存在相应的 DOM 节点，如果不存在，则新生成一个 Fiber 节点，如果存在则判断该节点是否可以复用，如果不能复用则标记 DOM 需要被删除，然后生成一个新 Fiber 节点。如果可以复用，则将上次更新的 Fiber 节点的副本作为本次新生成的 Fiber 节点并返回。</p><ul><li>如何判断 DOM 节点是否可以复用？</li></ul><p>React 通过先判断 key 是否相同，如果 key 相同则判断 type 是否相同，只有都相同时一个 DOM 节点才能复用。key 相同且 type 不同时执行 deleteRemainingChildren 将 child 及其兄弟 fiber 都标记删除。key 不同时仅将 child 标记删除。</p><h4 id="多节点时"><a href="#多节点时" class="headerlink" title="多节点时"></a>多节点时</h4><p>有两种情况（一个 ul 下面有多个 li；一个 ul 下面多个 li 是使用 map 出来的），其实流程是一样的。</p><p>注意：提到的老 Fiber 树其实是本层中兄弟节点构成的链表。</p><p>注意： 因为层级比较深，可能markdown解析出来的不太方便看，请结合该章节头部的图来看。</p><ol><li><p>同时遍历新 jsx 对象数组，老 Fiber 树。</p><ol><li>复用判断<ul><li>如果key相同且type（就是标签相同）相同，复用之前的Fiber，并返回。</li><li>如果key相同且type不同，根据jsx对象创建新Fiber并返回。</li><li>如果key不同，返回null，并跳出循环。</li></ul></li><li>将老的 Fiber 标为 deletion</li><li>将新的 Fiber 节点标为 placement，并记录最后一个可复用的节点在老 Fiber 树中的位置索引。<ol><li>记录新 Fiber 的位置（即在 jsx 对象数组中的索引）</li><li>判断新Fiber是否为复用的<ul><li>是<ol><li>拿到老Fiber节点的位置</li><li>如果老位置小于新位置（表示新Fiber节点右移了），则新的Fiber节点被标记为placement，并返回最后一个可复用的节点在老Fiber树中的位置索引。</li><li>如果老位置大于等于新位置，则直接返回老位置（不会标记为placement）</li><li>注：老位置大于新位置表示要由老位置左移得到新位置，但是React中仅进行右移操作，前面的元素右移后，自己自然被顶到前面去了，实现了左移的效果，相当于变相实现了左移。（关于在React中仅进行右移操作请看<a target="_blank" rel="noopener" href="https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/190.%E7%B2%BE%E8%AF%BB%E3%80%8ADOM%20diff%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E3%80%8B.md">精读《DOM diff 原理详解》</a>）</li></ol></li><li>否，直接标记为placement</li></ul></li></ol></li></ol></li><li><p>如果新 jsx 对象数组遍历完了（即删除节点了），标记没有遍历过的老 Fiber 节点为deletion，然后返回一棵新树（即 workInProgress Fiber 树）</p></li><li><p>如果老 Fiber 树遍历完了且新 jsx 对象数组没遍历完（即新增节点了），遍历剩下的 jsx 对象数组。</p><ol><li>创建新 Fiber 节点</li><li>将新的 Fiber 节点标为 placement，并记录最后一个可复用的节点在老 Fiber 树中的位置索引。</li><li>插入到新 Fiber 树中</li><li>返回 workInProgress Fiber 树。</li></ol></li><li><p>如果 jsx 对象数组没遍历完且老 Fiber 树也没遍历完（即没增没减）</p><ol><li>新建一个以老 Fiber 节点的 key 或者 index 为索引，老 Fiber 节点为 value 的 map</li><li>遍历 jsx 对象数组，根据 jsx 对象的 key 或者 index 为索引，在 map 中找老 Fiber 节点</li><li>如果老 Fiber 节点和 jsx 对象的 type 相同，则复用并返回新 Fiber 节点，如果不相同，则返回 null</li><li>如果返回的新 Fiber 节点不为 null，则将新的 Fiber 节点标记为 placement 并记录位置，然后插入到新的 Fiber 树中</li><li>如果 map 中还有剩余，就将剩下的全都标记为Deletion</li></ol></li><li><p>返回 workInProgress Fiber 树。</p></li></ol><h5 id="卡老师总结版"><a href="#卡老师总结版" class="headerlink" title="卡老师总结版"></a>卡老师总结版</h5><p>会进行两轮遍历。第一轮遍历处理更新的元素。第二轮遍历处理不属于更新的节点。</p><ul><li>为什么不用双指针优化？</li></ul><p>因为同级的 Fiber 节点间是用 sibling 指针连接形成的单链表。</p><p>第一轮遍历的过程：</p><ol><li><p><code>let i = 0</code>，遍历<code>newChildren</code>，将<code>newChildren[i]</code>与<code>oldFiber</code>比较，判断 DOM 节点是否可复用。</p></li><li><p>如果可复用，i++，继续比较<code>newChildren[i]</code>与<code>oldFiber.sibling</code>，可以复用则继续遍历。</p></li><li><p>如果不可复用，分两种情况：</p><ul><li><p>key 不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</p></li><li><p>key 相同 type 不同导致不可复用，会将 oldFiber 标记为 DELETION，并继续遍历</p></li></ul></li><li><p>如果<code>newChildren</code>遍历完（即<code>i === newChildren.length - 1</code>）或者<code>oldFiber</code>遍历完（即<code>oldFiber.sibling === null</code>），跳出遍历，第一轮遍历结束。</p></li></ol><p>第一轮遍历结束有两种结果：</p><p>第一种从 3 跳出来的：<code>newChildren</code>没遍历完<code>oldFiber</code>没遍历完</p><p>第二种从 4 跳出来的：<code>newChildren</code>没遍历完<code>oldFiber</code>遍历完（相当于有新增），<code>oldFiber</code>没遍历完<code>newChildren</code>遍历完（相当于有删减），<code>newChildren</code>和<code>oldFiber</code>都遍历完（相当于没增没减）</p><p>带着上面的结果进行第二轮遍历</p><p>如果<code>newChildren</code>和<code>oldFiber</code>都遍历完，最理想情况，只在第一轮遍历进行更新。Diff 结束。</p><p>如果<code>newChildren</code>没遍历完<code>oldFiber</code>遍历完，有新节点插入，遍历剩下的<code>newChildren</code>为生成的<code>workInProgress fiber</code>依次标记<code>Placement</code>。</p><p>如果<code>oldFiber</code>没遍历完<code>newChildren</code>遍历完，有节点被删了，遍历剩下的<code>oldFiber</code>，一次标记<code>Deletion</code></p><p>如果<code>newChildren</code>没遍历完<code>oldFiber</code>没遍历完，有节点变换了位置。将所有没处理的<code>oldFiber</code>存入以<code>key</code>为 key，<code>oldFiber</code>为 value 的 map 中。然后遍历剩余的<code>newChildren</code>，通过<code>newChildren[i].key</code>就能在<code>existingChildren</code>中找到 key 相同的 oldFiber。先标记最后一个可复用节点的位置，然后保存老节点的位置。两个位置信息比较。如果老位置&lt;最后一个可复用节点的位置，则 该节点 向右移动。如果老位置&gt;=最后一个可复用节点的位置，则该节点不动，然后可复用节点的位置变更为该老位置。</p><p>例子</p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">abcd-&gt;adbc（key和value都为表示的这个）<br><br>在第一轮遍历的时候保存得到，a是最后可复用节点,用lastChangeIndex保存改位置:<span class="hljs-number">0</span>。剩余的<span class="hljs-attr">newChildren</span> = dbc , 剩余的<span class="hljs-attr">oldFiber=</span> bcd。<br>遍历剩余的newChildren，第一个为d，key也是d。在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">3</span>。 因为oldIndex(<span class="hljs-number">3</span>)&gt;=lastChangeIndex(<span class="hljs-number">0</span>)，则该点不动，将<span class="hljs-attr">lasChangeIndex</span> = <span class="hljs-number">3</span>。<br>剩余的<span class="hljs-attr">newChildren</span> = bc , 剩余的<span class="hljs-attr">oldFiber=</span> bc。第二个为b，在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">1</span>。因为oldIndex(<span class="hljs-number">1</span>)&lt;lastChangeIndex(<span class="hljs-number">3</span>)，所以将该点右移。<br>剩余的<span class="hljs-attr">newChildren</span> = c , 剩余的<span class="hljs-attr">oldFiber=</span> c。最后一个为c，在oldFiber中的位置为<span class="hljs-attr">oldIndex</span> = <span class="hljs-number">2</span>。oldIndex(<span class="hljs-number">2</span>)&lt;lastChangeIndex(<span class="hljs-number">3</span>)，所以将该点右移。<br></code></pre></div></td></tr></table></figure><h2 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h2><h3 id="触发更新的方法"><a href="#触发更新的方法" class="headerlink" title="触发更新的方法"></a>触发更新的方法</h3><ul><li><p>ReactDOM.render</p></li><li><p>this.setState</p></li><li><p>this.forceUpdate</p></li><li><p>useState</p></li><li><p>useReducer</p></li></ul><p>这么多方法如何接入同一种更新机制？</p><p>在各自的处理方法里处理出来一个update对象，通过这个update对象进入统一的更新流程</p><h3 id="流程大纲"><a href="#流程大纲" class="headerlink" title="流程大纲"></a>流程大纲</h3><ol start="0"><li><p>触发状态更新（根据场景调用不同方法）</p></li><li><p>创建update对象</p></li><li><p>从触发状态更新的<code>fiber</code>一直向上遍历到<code>rootFiber</code>。</p></li><li><p>调度更新</p></li><li><p>render阶段</p></li><li><p>commit阶段</p></li></ol><h3 id="优先级与Update"><a href="#优先级与Update" class="headerlink" title="优先级与Update"></a>优先级与Update</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 初始化的无优先级</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NoPriority = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 立刻执行的优先级，最高优先级，同步的优先级</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ImmediatePriority = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 用户触发的更新，如点击事件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> UserBlockingPriority = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 一般优先级，最常见的，如请求数据后setState</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NormalPriority = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 低优先级</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LowPriority = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// 空闲优先级</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> IdlePriority = <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure><p>状态计算公式： <code>baseState + Update1 + Update2 = newState</code>。</p><p>假设 update1 为 NormalPriority ，update2 为 UserBlockingPriority 。</p><p>计算状态的时候会先计算<code>baseState+update2</code>得到一个中间状态，然后再去计算<code>update1</code>。</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><ol><li>创建更新</li><li>从触发更新的节点向上递归查找，直到找到FiberRootNode</li><li>在FiberRootNode上保存对应优先级</li><li>以对应优先级调度FiberRootNode。</li><li>触发对应的回调函数（render阶段入口）</li><li>从FiberRootNode深度优先遍历对路径上的节点进行Diff。</li><li>如果有高优先级进来，会先打断之前优先级过程，优先执行高优先级的。</li></ol><h3 id="update计算"><a href="#update计算" class="headerlink" title="update计算"></a>update计算</h3><p>ReactDOM.render（同步更新）：按照顺序排成队更新，就好比正常情况下程序进行迭代升级 从1.0-&gt;1.1-&gt;1.2</p><p>ReactDOM.createBlockingRoot和ReactDOM.createRoot（并发更新）：打断现在的过程，先进行优先级高的，比如线上遇到紧急BUG，那得先暂存当前过程，切换到main分支，进行修复后再rebase一下。</p><h3 id="update类型"><a href="#update类型" class="headerlink" title="update类型"></a>update类型</h3><ul><li>ReactDOM.render —— HostRoot</li><li>this.setState —— ClassComponent</li><li>this.forceUpdate —— ClassComponent</li><li>useState —— FunctionComponent</li><li>useReducer —— FunctionComponent</li></ul><p>由于不同类型组件工作方式不同，所以存在两种不同结构的<code>Update</code>，其中<code>ClassComponent</code>与<code>HostRoot</code>共用一套<code>Update</code>结构，<code>FunctionComponent</code>单独使用一种<code>Update</code>结构。</p><h4 id="HostRoot及ClassComponent"><a href="#HostRoot及ClassComponent" class="headerlink" title="HostRoot及ClassComponent"></a>HostRoot及ClassComponent</h4><h4 id="ClassComponent的update对象"><a href="#ClassComponent的update对象" class="headerlink" title="ClassComponent的update对象"></a>ClassComponent的update对象</h4><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> update: Update&lt;*&gt; = &#123;<br>    eventTime, <span class="hljs-comment">// 任务时间</span><br>    lane, <span class="hljs-comment">// 优先级相关</span><br>    <span class="hljs-attr">tag</span>: UpdateState, <span class="hljs-comment">// 更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate。</span><br>    <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参。</span><br>    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">// 更新的回调函数，setState的第二个参数，ReactDom.render的第三个参数。对应layout阶段提到的回调函数</span><br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 指针，指向另外的update，构成链表</span><br>  &#125;;<br></code></pre></div></td></tr></table></figure><h4 id="update链表与Fiber节点有什么关系？"><a href="#update链表与Fiber节点有什么关系？" class="headerlink" title="update链表与Fiber节点有什么关系？"></a>update链表与Fiber节点有什么关系？</h4><p>fiber节点的updateQueue存的就是这个update链表。</p><p>为什么要有链表？因为可能存在多个更新，比如在一个时间中我连续调用了三个setState。就会有三个update 或者 有多个优先级的update。</p><h4 id="classComponent的updateQueue"><a href="#classComponent的updateQueue" class="headerlink" title="classComponent的updateQueue"></a>classComponent的updateQueue</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> queue: UpdateQueue&lt;State&gt; = &#123;<br>    <span class="hljs-attr">baseState</span>: fiber.memoizedState, <span class="hljs-comment">// 本次更新前的state，update会基于这个来计算newState</span><br>  <span class="hljs-comment">// 之所以在更新产生前该`Fiber节点`内就存在`Update`，是由于某些`Update`优先级较低所以在上次`render阶段`由`Update`计算`state`时被跳过。</span><br>    <span class="hljs-attr">firstBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">//本次更新前该`Fiber节点`已保存的`Update`，链表头为`firstBaseUpdate`，</span><br>    <span class="hljs-attr">lastBaseUpdate</span>: <span class="hljs-literal">null</span>,<span class="hljs-comment">// 本次更新前该`Fiber节点`已保存的`Update`，链表尾为`lastBaseUpdate`</span><br>    <span class="hljs-attr">shared</span>: &#123; <span class="hljs-comment">// 触发更新时，本次更新产生的`Update`会保存在`shared.pending`中形成单向环状链表。当由`Update`计算`state`时这个环会被剪开并连接在`lastBaseUpdate`后面。</span><br>      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,<br>    &#125;,<br>    <span class="hljs-attr">effects</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 数组。保存`update.callback !== null`的`Update`。</span><br>  &#125;;<br></code></pre></div></td></tr></table></figure><h4 id="update计算过程"><a href="#update计算过程" class="headerlink" title="update计算过程"></a>update计算过程</h4><p><code>ReactUpdateQueue.old.js的enqueueUpdate</code>过程</p><p>假设有两个更新u1和u2在上一次render时因为优先级不够并且u1-&gt;u2，那么这两个会作为下次的<code>baseUpdate</code>。</p><p>那么这时</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">queue.firstBaseUpdate</span> = u1<br><span class="hljs-attr">queue.lastBaseUpdate</span> = u2<br></code></pre></div></td></tr></table></figure><p>如果此时再次触发了两个更新u3和u4。</p><p>当插入u3的时候</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">queue.shared.pending =  u3 ─────┐ <br>                         ^      |                                    <br>                         └──────┘<br>												   <br></code></pre></div></td></tr></table></figure><p>然后插入 u4的时候</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c">queue.shared.pending = u4 ──&gt; u3<br>                       ^      <span class="hljs-string">|                                    </span><br>                       └──────┘<br></code></pre></div></td></tr></table></figure><p>然后进入 render阶段的 beginWork阶段</p><figure class="highlight xl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">queue</span>.lastBaseUpdate = u1(-&gt;</span><span class="hljs-function"><span class="hljs-title">u2</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">u3</span>-&gt;</span>u4)<br><span class="hljs-function"><span class="hljs-title">queue</span>.shared.pending = u4( -&gt;</span> u3)<br></code></pre></div></td></tr></table></figure><p>并且也会在 currentFiber 树的对应fiber 节点上保存，确保 update 不会丢失。即<code>current.updateQueue.lastBaseUpdate = u1(-&gt;u2-&gt;u3-&gt;u4)</code>。然后再 render 阶段中断并重新开始的时候会再从<code>current</code>中 clone 出一份 lastBaseUpdate，如果在 commit 阶段中断并重新开始的时候会从<code>workInProgress树</code>上 clone 出一份 lastBaseUpdate</p><p>然后以 baseState 为初始状态并遍历 firstBaseUpdate 开始计算newState。在遍历时如果有优先级低的<code>Update</code>会被跳过，做出来一个<code>newFirstBaseUpdate</code> 和<code>newBaseState</code>作为下次更新用的。如果满足优先级条件，会先计算 newState，然后判断 update 的 callback 有没有，有的话就push到workInProgress 的 effect 里，然后移动 update 的 next 指针，如果这个时候 update 为空了，要判断一下<code>queue.shared.pending</code>是否为空，如果为空就跳出循环，如果没为空（在 setState 里又 setState 了一个）就执行一遍裁剪环那里的操作。</p><p>当遍历完成后判断newLastBaseUpdate是否为空，如果为空则将 newState 赋值给 <code>workInProgress.updateQueue</code> 的<code>baseState</code>，如果不为空的情况则说明本次 更新有 update 因为优先级不足被跳过了。遍历完成获得的 state就是该<code>Fiber节点</code>在本次更新的<code>state</code>（源码中叫做<code>memoizedState</code>）。</p><h4 id="如何保证状态依赖的连续性"><a href="#如何保证状态依赖的连续性" class="headerlink" title="如何保证状态依赖的连续性"></a>如何保证状态依赖的连续性</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">baseState: <span class="hljs-string">&#x27;&#x27;</span><br>shared.pending: A1 --&gt; B2 --&gt; C1 --&gt; D2<br></code></pre></div></td></tr></table></figure><p>其中<code>字母</code>代表该<code>Update</code>要在页面插入的字母，<code>数字</code>代表<code>优先级</code>，值越低<code>优先级</code>越高。</p><p>第一次<code>render</code>，<code>优先级</code>为1。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">baseState: <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">baseUpdate</span>: <span class="hljs-literal">null</span><br>render阶段使用的Update: [A1, C1]<br><span class="hljs-attr">memoizedState</span>: <span class="hljs-string">&#x27;AC&#x27;</span><br></code></pre></div></td></tr></table></figure><p>其中<code>B2</code>由于优先级为2，低于当前优先级，所以他及其后面的所有<code>Update</code>会被保存在<code>baseUpdate</code>中作为下次更新的<code>Update</code>（即<code>B2 C1 D2</code>）。</p><p>这么做是为了保持<code>状态</code>的前后依赖顺序。</p><p>第二次<code>render</code>，<code>优先级</code>为2。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">baseState: <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-attr">baseUpdate</span>: B2 --&gt; C1 --&gt; D2 <br>render阶段使用的Update: [B2, C1, D2]<br><span class="hljs-attr">memoizedState</span>: <span class="hljs-string">&#x27;ABCD&#x27;</span><br></code></pre></div></td></tr></table></figure><p>这里会以 baseState 为初始状态，按照 baseUpdate 的顺序计算，然后得到 memoizedState。</p><p>注意这里<code>baseState</code>并不是上一次更新的<code>memoizedState</code>。这是由于<code>B2</code>被跳过了。</p><p>即当有<code>Update</code>被跳过时，<code>下次更新的baseState !== 上次更新的memoizedState</code>。</p><p>React 不会保证中间状态即第一次 render 时的 memoizedState 正确，只会保证最终 render 的 memoizedStata 正确</p><h3 id="ReactDOM-render流程"><a href="#ReactDOM-render流程" class="headerlink" title="ReactDOM.render流程"></a>ReactDOM.render流程</h3><ol><li>创建rootFiber和fiberRoot</li><li>连接rootFiber与fiberRootNode（将fiberRoot的current指向rootFiber）</li><li>初始化updateQueue</li><li>创建update</li><li>从fiber到rootFiber向上递归</li><li>调度更新</li><li>render阶段</li><li>commit阶段</li></ol><h4 id="与ReactDOM-createRoot-render的不同"><a href="#与ReactDOM-createRoot-render的不同" class="headerlink" title="与ReactDOM.createRoot().render的不同"></a>与ReactDOM.createRoot().render的不同</h4><ol><li>reactDOM.render的lane是1，reactDOM.createRoot的lane是512对应的二进制</li><li>在创建rootFiber时传参不一样。代表并发还是同步</li></ol><h3 id="this-setState流程"><a href="#this-setState流程" class="headerlink" title="this.setState流程"></a>this.setState流程</h3><ol><li>通过组件实例获取对应fiber</li><li>获取优先级</li><li>创建update</li><li>赋值回调函数</li><li>将update插入updateQueue</li><li>调度update</li></ol><h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><h3 id="极简useState-的实现"><a href="#极简useState-的实现" class="headerlink" title="极简useState 的实现"></a>极简useState 的实现</h3><p>见<a target="_blank" rel="noopener" href="https://github.com/AruSeito/daily-practice/blob/main/others/useState/index.html">简易版useState</a></p><p>useState 在不同运行时会调用不同的方法，比如 mont 时会调用<code>mountState</code>，update 时会调用<code>updateState</code>，对应的时简易版的 useState 内的<code>if(isMount)</code>的两块内容</p><p>其实 useReducer 和 useState 的实现方式是一样的，只不过 useState 在 return<code>dispatchAction.bind(baseReducer,queue)</code>时 预设传了一个 reducer。</p><h3 id="useEffect和-useLayout-的实现"><a href="#useEffect和-useLayout-的实现" class="headerlink" title="useEffect和 useLayout 的实现"></a>useEffect和 useLayout 的实现</h3><p>同 useState 一样，在 mount 时会调用<code>mountEffect</code>,在 update 时会调用<code>updateEffect</code></p><ol><li><p>获取当前 hook 对应的数据</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> hook: Hook = &#123;<br>    <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-attr">baseState</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">queue</span>: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>获取依赖项</p></li><li><p>标记 flag，useEffect 和 useLayoutEffect 的 flag 是不同的</p></li><li><p>mout 时和 update 的单独操作</p><ul><li>mount 时，保存 hook 的最后一个 effect 到 hook 的 memoizedState</li><li>update 时<ol><li>取出上一次的 effect，取出上一次 effect 的销毁函数，取出上一次的依赖</li><li>浅比较上一次的依赖和这次的依赖，pushEffect 进去时传入不同的 flag</li></ol></li></ul></li></ol><p>为什么销毁函数在 update 时取？</p><p>因为只有effect 的 create 执行完之后才会有 destroy。</p><p>为什么依赖改变了也要 pushEffect 进去？</p><p>因为 所有 effect 都是存在 fiber 节点上的一条环状单向链表上的，顺序是不变的。</p><h3 id="useRef的实现"><a href="#useRef的实现" class="headerlink" title="useRef的实现"></a>useRef的实现</h3><p>基本流程和上面的两种 hook 一样。</p><p>mount 时</p><ol><li>通过<code>mountWorkInProgressHook</code>获得当前 hook 的数据</li><li>把 initialState 挂到current 下</li><li>把 ref挂到 <code>hook.memoizedState</code>下</li><li>把 ref 返回出去</li></ol><p>update 时</p><ol><li>通过<code>mountWorkInProgressHook</code>获得当前 hook 的数据</li><li>返回<code>hook.memoizedState</code></li></ol><p>classComponet 中 createRef的实现</p><p>创建一个包含<code>currentd</code>的对象并返回。</p><h4 id="ref-的工作流程"><a href="#ref-的工作流程" class="headerlink" title="ref 的工作流程"></a>ref 的工作流程</h4><h5 id="render-阶段（为含有ref属性的fiber添加Ref-effectTag）"><a href="#render-阶段（为含有ref属性的fiber添加Ref-effectTag）" class="headerlink" title="render 阶段（为含有ref属性的fiber添加Ref effectTag）"></a>render 阶段（为含有<code>ref</code>属性的<code>fiber</code>添加<code>Ref effectTag</code>）</h5><ul><li>首屏渲染时（<code>*current* === null &amp;&amp; ref !== null</code>)</li><li>update 时（<code>*current* !== null &amp;&amp; *current*.ref !== ref</code>)</li></ul><p>以上两种情况会进入逻辑，给<code>fiber</code>标记上 Ref effectTag</p><h5 id="commit-阶段（为包含Ref-effectTag的fiber执行对应操作）"><a href="#commit-阶段（为包含Ref-effectTag的fiber执行对应操作）" class="headerlink" title="commit 阶段（为包含Ref effectTag的fiber执行对应操作）"></a>commit 阶段（为包含<code>Ref effectTag</code>的<code>fiber</code>执行对应操作）</h5><ul><li><p>首屏渲染时，会在 commit 阶段的layout 阶段，判断有没有被标记上 Ref effectTag，被标记了的话就会进入不同类型的组件方法获取实例并赋值上去。如果 ref 时函数类型的话，会先执行得出结果再赋值给ref.current。</p></li><li><p>update 时</p><ul><li><p>mutation阶段时，对于<code>ref</code>属性改变的情况，需要先移除之前的<code>ref</code>。</p></li><li><p>对于<code>Deletion effectTag</code>的<code>fiber</code>（对应需要删除的<code>DOM节点</code>），需要递归他的子树，对子孙<code>fiber</code>的<code>ref</code>执行类似<code>commitDetachRef</code>的操作。</p></li><li><p>在 commitDetachRef 中，如果 ref 时函数类型的，会先执行一次该函数，再进行解绑。</p></li></ul></li></ul><h3 id="useCallback-和-useMemo-的实现"><a href="#useCallback-和-useMemo-的实现" class="headerlink" title="useCallback 和 useMemo 的实现"></a>useCallback 和 useMemo 的实现</h3><p>mount 时</p><ol><li>通过<code>mountWorkInProgressHook</code>获得当前 hook 的数据</li><li>获取依赖项</li><li>获取计算结果（useCallback 不会有这一步，update 时同理）</li><li>将<code>[计算结果,依赖]</code>保存到<code>hook.memoizedState</code>（useCallback 会<code>[callback,依赖]</code>存上，update 时同理）</li><li>返回计算结果</li></ol><p>update 时</p><ol><li>通过<code>mountWorkInProgressHook</code>获得当前 hook 的数据</li><li>获取依赖项</li><li>获取上一次计算结果与依赖<code>hook.memoizedState</code></li><li>浅比较上一次的依赖与一下次的依赖，如果相等就返回上一次的结果</li><li>如果不想当，就获取新的计算结果</li><li>将<code>[计算结果,依赖]</code>保存到<code>hook.memoizedState</code></li><li>返回计算结果</li></ol><h2 id="concurrent-Mode"><a href="#concurrent-Mode" class="headerlink" title="concurrent Mode"></a>concurrent Mode</h2><h3 id="scheduler的工作原理及实现"><a href="#scheduler的工作原理及实现" class="headerlink" title="scheduler的工作原理及实现"></a>scheduler的工作原理及实现</h3><p>scheduler 的作用：</p><ul><li>时间切片</li><li>优先级调度</li></ul><h4 id="时间切片原理"><a href="#时间切片原理" class="headerlink" title="时间切片原理"></a>时间切片原理</h4><p>时间切片本质是模拟实现requestIdelCallback</p><p>除去“浏览器重排/重绘”，浏览器中一帧可执行 js 的时机</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback<br></code></pre></div></td></tr></table></figure><p><code>requestIdleCallback</code>是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。</p><p>浏览器并没有提供其他<code>API</code>能够在同样的时机（浏览器重排/重绘后）调用以模拟其实现。</p><p>唯一能精准控制调用时机的<code>API</code>是<code>requestAnimationFrame</code>，他能让我们在“浏览器重排/重绘”之前执行<code>JS</code>。</p><p>所以，退而求其次，<code>Scheduler</code>的<code>时间切片</code>功能是通过<code>task</code>（宏任务）实现的。</p><p>最常见的<code>task</code>当属<code>setTimeout</code>了。但是有个<code>task</code>比<code>setTimeout</code>执行时机更靠前，那就是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel">MessageChanne</a>。</p><p><code>Scheduler</code>将需要被执行的回调函数作为<code>MessageChannel</code>的回调执行。如果当前宿主环境不支持<code>MessageChannel</code>，则使用<code>setTimeout</code>。</p><p>在<code>React</code>的<code>render</code>阶段，开启<code>Concurrent Mode</code>时，每次遍历前，都会通过<code>Scheduler</code>提供的<code>shouldYield</code>方法判断是否需要中断遍历，使浏览器有时间渲染</p><p>是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。</p><p>在<code>Schdeduler</code>中，为任务分配的初始剩余时间为<code>5ms</code>。</p><p>随着应用运行，会通过<code>fps</code>动态调整分配给任务的可执行时间。</p><h4 id="优先级调度的实现"><a href="#优先级调度的实现" class="headerlink" title="优先级调度的实现"></a>优先级调度的实现</h4><p><code>runWithPriority</code>接受一个<code>优先级</code>与一个<code>回调函数</code>，在<code>回调函数</code>内部调用获取<code>优先级</code>的方法都会取得第一个参数对应的<code>优先级</code></p><p>scheduler有五种优先级</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">ImmediatePriority:<br>UserBlockingPriority:<br>NormalPriority:<br>LowPriority:<br>IdlePriority:<br></code></pre></div></td></tr></table></figure><p>在<code>React</code>内部凡是涉及到<code>优先级</code>调度的地方，都会使用<code>runWithPriority</code>。</p><p>不同<code>优先级</code>意味着不同时长的任务过期时间，优先级越高越快过期，越先执行</p><h4 id="不同优先级的排序"><a href="#不同优先级的排序" class="headerlink" title="不同优先级的排序"></a>不同优先级的排序</h4><p>按照过期时间，可以将任务分为两类</p><ul><li>已就绪任务</li><li>未就绪任务</li></ul><p>所以 scheduler 存在两个队列</p><ul><li>timerQueue：保存未就绪任务</li><li>taskQueue：保存已就绪任务</li></ul><p>每当有新的未就绪的任务被注册，我们将其插入<code>timerQueue</code>并根据开始时间重新排列<code>timerQueue</code>中任务的顺序。</p><p>当<code>timerQueue</code>中有任务就绪，即<code>startTime &lt;= currentTime</code>，我们将其取出并加入<code>taskQueue</code>。</p><p>取出<code>taskQueue</code>中最早过期的任务并执行他：当注册的回调函数执行后的返回值<code>continuationCallback</code>为<code>function</code>，会将<code>continuationCallback</code>作为当前任务的回调函数。如果返回值不是<code>function</code>，则将当前被执行的任务清除出<code>taskQueue</code>。</p><p>为了能在O(1)复杂度找到两个队列中时间最早的那个任务，<code>Scheduler</code>使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanhaicode/p/10546257.html">小顶堆 </a>实现了<code>优先级队列</code>。</p><h3 id="Lane-模型的实现"><a href="#Lane-模型的实现" class="headerlink" title="Lane 模型的实现"></a>Lane 模型的实现</h3><p>卡老师总结：<a target="_blank" rel="noopener" href="https://react.iamkasong.com/concurrent/lane.html">Lane模型的实现</a></p><h3 id="异步可中断更新与饥饿问题"><a href="#异步可中断更新与饥饿问题" class="headerlink" title="异步可中断更新与饥饿问题"></a>异步可中断更新与饥饿问题</h3><p>如果低优先级的更新一直被高优先级的更新打断，随着时间的推移，低优先级的更新会过期，这个时候会被设为 <code>同步优先级</code>，来解决饥饿问题。</p><p>在<code>workLoopConcurrent</code>方法内，会使用<code>!shouldYeid</code>来判断当前时间片是否用尽。</p><p>在 <code>scheduler.js</code>中有个<code>workLoop</code>方法会取到当前被执行任务的 callBack，然后判断 callBack类型，如果是函数，会执行callBack，然后在判断 callback 的执行结果是否还是为 function，如果还是 function ，会把这个执行结果赋值给当前任务的 callback 然后再次调度这个 task，如果不是了，就考虑从小顶堆中剔除出去，高优先级中断低优先级任务的逻辑之一。</p><h3 id="batchedUpdates的实现"><a href="#batchedUpdates的实现" class="headerlink" title="batchedUpdates的实现"></a>batchedUpdates的实现</h3><p>react 的内部优化方法。用来合并 update的。</p><p>老版本的实现：在<code>ReactFiberWorkLoop.old.js</code>下的<code>unbatchedUpdates</code>方法</p><p>获取 setState 时的上下文，当获取到的上下文包含<code>BatchedContext</code>时，不会马上触发更新，在事件回调结束时，才会触发更新。</p><p>缺陷：</p><p>都是同步的操作。比如：如果给这个事件回调将 setState 做异步调用时，就不会生效了。</p><p>因为异步调用后，他已经脱离了当前的上下文。</p><p>新版本的实现：在<code>ReactFiberWorkLoop.old.js</code>下的<code>ensureRootIsScheduled</code>方法</p><p>基于 lane 模型实现，第一个setState 进去的时候按照正常的流程安排调度，第二个 setState 进去的时候因为这两个优先级分配的都是一样的就直接 return 出去了，所以第二次调度就不会调度回调函数了（也就是进入 render 阶段的函数了）</p><p>关键点在于他们的 lane 是相同的。相同 lane 的条件：</p><ul><li>相同的优先级</li><li>当前事件的 lanes 相同（<code>currentEventWipLanes</code>)</li></ul><h3 id="高优先级更新如何插队"><a href="#高优先级更新如何插队" class="headerlink" title="高优先级更新如何插队"></a>高优先级更新如何插队</h3><ol><li>先取消掉低优先级的callback</li><li>在 render 阶段通过 prepareFreshStack 取消低优先级带来的影响。</li><li>调度高优先级的任务</li><li>再调度低优先级的任务</li></ol></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">源码学习</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/React/">React</a> <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/article/c0cc8344/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">近期面试复盘</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/article/db2c0d0e/"><span class="hidden-mobile">在React中因浅拷贝引发的BUG</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/custom.js"></script><script src="/js/boot.js"></script></body></html>