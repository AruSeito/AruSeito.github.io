---
title: 性能优化之渲染优化
categories:
  - 性能优化
tags:
  - 浏览器渲染原理
  - 重排和重绘
index_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg4.jpg
banner_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg4.jpg
date: 2021-02-26 22:10:21
---

## 浏览器渲染过程（对应面试题：从用户输入url到显示都发生了什么）

0. 省略网络相关部分。

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。

2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

3. 创建布局树，并计算元素的布局信息。

4. 对布局树进行分层，并生成分层树。

5. 为每个图层生成绘制列表，并将其提交到合成线程。

6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。

8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

主流程：DOM -》Style-》Layout-》Layer-》Paint


## 布局
### 重排（回流）和重绘

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段（即从上文序号2开始），这个过程就叫重排。

通过 JavaScript 或者 CSS 修改元素没有引起几何位置的变换（即绘制属性（元素的颜色、背景色、边框等）），布局阶段将不会被执行，直接进入了绘制阶段，然后执行之后的一系列子阶段（即跳过序号3，4），这个过程就叫重绘。


### 影响重排（回流）的操作

- 添加/删除元素

- 操作styles

- display:none

- offsetLeft,scrollTop,clientWidth

- 移动元素位置

- 修改浏览器大小，字体大小。

### 避免Layout thrashing

- 避免重排（回流）

- 读写分离：FastDom，原理：读写分离，批量操作，使用window.requestAnimationFrame。

![帧的生命周期](https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/life-of-a-frame.png)



### 减少重绘的方案

- 利用DevTools识别paint的瓶颈

- 利用will-change创建新图层

### 触发合成过程的属性

渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。

- 位置：transform：translate

- 缩放：transform：scale

- 旋转：transform：rotate

- 透明度：opacity

## 高频事件处理

### 防抖

任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。

比如当监听鼠标移动等事件时：

```JavaScript
//用来表示事件是否在执行中。
let ticking =false;

window.addEventListener("pointermove",(e)=>{
  if(ticking) return;
  ticking = true;
  //执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画
  window.requestAnimationFrame(()=>{
    changeWidth();
    ticking = false;
  })
})
```

## React时间调度实现

React Fiber：把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。

### 基本原理

- requestIdleCallback的问题：兼容性不好。在浏览器的空闲时段内调用的函数排队，能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件。

- 通过rAF模拟rIC：在requestAnimationFrame获取一桢的开始时间，触发一个postMessage，在空闲的时候调用idleTick来完成异步任务。
