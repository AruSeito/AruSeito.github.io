---
title: 性能优化之代码优化
categories:
  - 性能优化
tags:
  - 性能优化
  - 代码优化
index_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg5.jpg
banner_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg5.jpg
date: 2021-02-28 18:28:13
---

## JS开销和如何缩短解析时间

### JS开销

![js时间开销](https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/cost-of-javascript-2019.png)

### 解决方案

1. 网络加载方面：JS文件压缩 

2. 编译和解析：代码拆分，按需加载

3. 编译和解析：删除没必要的代码

4. 执行：减少主线程工作量


### 减少主线程工作量

1. 避免长任务（long task）

2. 避免超过1kB的行间脚本

3. 使用 rAF 和 rIC 进行时间调度


## 配合 V8 有效优化代码

### V8编译原理

1. 生成抽象语法树（AST）和执行上下文：先进行词法分析将源代码拆解成token。在进行语法分析，将token根据语法规则转化为AST。

2. 生成字节码：会根据 AST 生成字节码，并解释执行字节码

3. 执行代码：在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器就会把该段热点的字节码编译为机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。经过编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行。


eg.:
```javaScript
const {performance,PerformanceObserver} = require('perf_hooks);

const add = (a,b) => a + b;

const num1 = 1;
const numb = 2;

performance.mark('start);
for(let i = 0 ; i < 100000 ; i ++){
  add(num1,num2)
}
//分别注释拼接字符串的代码进行时间比较，发现时间差距极大。
add(num1,'s');

for(let i = 0 ; i < 100000 ; i ++){
  add(num1,num2)
}

performance.mark('end');

const observer = new PerformanceObserver((list)=>{
  console.log(list.getEntries()[0]);
})
```

查看V8对哪些进行了优化，哪些进行了反优化可以执行`node --trace-opt --trace-deopt file.js`

### V8优化机制

1. 脚本流：下载的过程中对已经下载的足够大的js文件开辟新线程先解析，等都加载完后将全部解析结果合并。

2. 字节码缓存

3. 懒解析（lazy-parsing）：主要对于函数而言，先不解析函数内部逻辑，等用的时候在解析。


## 函数优化

### 函数的解析方式

- 懒解析（lazy-parsing）：不会创建ast，会创建作用域，但不会在里面包含变量引用或者声明。

- 饥饿解析（eager-parsing）：会建立AST,创建完整的作用域，找出所有语法错误

问题：一个马上要执行的函数在声明的时候会进行一个懒解析，发现是该函数要执行了，又会进行饥饿解析，效率降低。

eg.:

```JavaScript
const main = ()=>{
  //可通过将函数转为立即执行函数，告诉V8，add进行饥饿解析。
  // const add =((a,b)=>a+b);
  const add = (a,b)=>a+b;
  const num1 = 1;
  const num2 = 2;
  add(num1 + num2);
}
```

问题：使用部分压缩工具（老版本的uglyfy 和 webpack等）时，可能会将上述括号取消掉。
解决：利用Optimize.js优化加载时间。（将括号再加回来）

## 对象优化

### 1. 以相同顺序初始化对象成员，避免隐藏类的调整

隐藏类可以理解为“按图索骥”中的图。提高对象属性的访问速度，快速存取对象属性，节省内存空间。

详细可看 [ V8 中的对象表示 ](https://www.cnblogs.com/chargeworld/p/12236848.html)。

文章 [ JavaScript 引擎基础：Shapes 和 Inline Caches ](https://zhuanlan.zhihu.com/p/38202123)中详细了隐藏类的相关内容。

```JavaScript
class RectArea{//HC0
  constructor(l,w){ 
    this.l = l;//HC1
    this.w = w;//HC2
  }
}

//这种实例化时，rect2会复用rect1时产生的HC（hidden class）。
const rect1 = new RectArea(3,4);
const rect2 = new RectArea(5,6);

//反面例子
const car1 = {color:'red'}; //HC0
car1.seats = 4; //HC1

const car2 = {seats:2}; //无法复用以上两种,HC2
cat2.color = 'blue'; //HC3
```





### 2. 实例化后避免添加新属性

### 3. 尽量使用Array代替array-like对象

## HTML优化

## CSS对性能的影响