---
title: 社招-字节跳动前端面试
categories:
  - 面经
tags:
  - 字节跳动
  - 面经
index_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg10.jpg
banner_img: https://cdn.jsdelivr.net/gh/AruSeito/AruSeito.github.io@main/source/img/banner/bg10.jpg
date: 2021-03-10 17:29:27
---

## 前言

找了朋友帮忙内推了字节跳动-飞书。没想到响应非常迅速，本以为会过一段时间才会安排面试。没想到隔天就安排上了面试，本来还想在面字节之前先拿其他几家试水，然后再来面试，没想到字节效率太高了。

## 一面

现在回顾一下面试题，发现大佬好像问了好多关于函数式编程的问题，组内可能已经在进行函数式编程的实践了？

### 堆和栈的区别？

栈和堆没有本质区别，使用栈内存时，是从地址高位开始分配内存空间。使用堆内存时，是从地址低位开始分配空间。栈中存放的主要是执行上下文，函数调用栈等。堆中存放的是对象这种复杂数据。需要按地址访问。

### 递归会引发什么问题？为什么会爆栈？

过深的递归会引起爆栈。内存中特地用来存放函数调用的栈区内存是有限的，如果递归太深，就会出现只入栈不出栈的情况。

### 进程和线程的区别。

进程是资源分配的最小单位，线程是CPU调度的最小单位。

### Chrome都有什么进程。

1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

### HTTPs怎么回事？

#### 第一版：使用对称加密

1. 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。

2. 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。

3. 最后浏览器和服务器分别返回确认消息。

4. 然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。


#### 第二版：使用非对称加密

1. 首先浏览器发送加密套件列表给服务器。

2. 然后服务器会选择一个加密套件，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。

3. 最后就是浏览器和服务器返回确认消息。

4. 在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据

#### 第三版：对称加密和非对称加密搭配使用

1. 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；

2. 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；

3. 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；

4. 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

5. 服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥。

#### 第四版：添加数字证书

1. 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；

2. 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和 证书

3. 浏览器验证证书，生成随机数pre-master，利用公钥对 pre-master 加密，并向服务器发送加密后的数据；

4. 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

5. 服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥。

### 证书验证的流程。

1. 首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A

2. 然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；

3. 对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的。同时浏览器还会验证证书相关的域名信息、有效时间等信息。


### 如何尽可能的多发包并且不丢包？

到目前为止不知道怎么答。


### 滑动窗口

[滑动窗口详解](https://blog.csdn.net/yao5hed/article/details/81046945)

### HTTP2的多路复用是怎么回事？

在一个 TCP 连接中可以存在多条流。也就是可以发送多个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### HTTP中的响应头拥塞怎么回事？

HTTP/1.1通过管道技术实现一次性发送多个请求，以期提高吞吐和性能。然而，这种技术在接收响应时，要求必须按照发送请求的顺序返回。如果，第一个请求被堵塞了，则后面的请求即使处理完毕了，也需要等待。

### WEBPACK构建如何优化？

详见[构建优化](https://aruseito.github.io/2021/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9E%84%E5%BB%BA%E4%BC%98%E5%8C%96/)

### React的生命周期
react 15:
挂载时：

- constructor

- componentWillMount

- render

- componentDidMount

更新：

- componentWillRecieveProps（由父组件的更新触发）

- shouldComponentUpdate

- componentWillUpdate

- render

- componentDidUpdate

卸载：

- componentWillUnmount

react 16:

挂载时：

- constructor

- getDerivedStatesFromProps

- render

- componentDidMount

更新：

- getDerivedStatesFromProps （16.3以前只有New Props会触发，16.4以后New Props、setState、forceUpdate都可以触发）

- shouldComponentUpdate

- render

- getSnapshotBeforeUpdate

- componentDidUpdate

卸载：

- componentWillUnmount

### React的组件类型

类组件和函数组件

函数组件：符合React设计理念，函数编程
类组件：面向对象编程思想

### pureComponet与Component

- PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行浅比较，并根据浅比较的结果，决定是否需要继续更新流程。

- Component没有实现shouldComponentUpdate。

### useCallback和useMemo

- useCallback返回一个 memoized 回调函数

- useMemo返回memoized值

useCallback(fn, deps) 相当于 useMemo(() => fn, deps)


### forwardref

forwardref：转发 refs 到 DOM 组件、在高阶组件中转发 refs


### Redux的最佳实践

[个人理解加官方文档翻译版](https://aruseito.github.io/2021/03/12/Redux%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/)
[Redux的最佳实践官方文档](https://redux.js.org/style-guide/style-guide#priority-a-rules-essential)


### 算法

算法题就不放具体题了把。我看面试官那面标记了我的名字+题目。。。不知道直接放原题会不会有问题。

算法题一共两道，第一道考察：数据结构栈和链表 第二题考查函数式编程柯里化。

都不难，但是一紧张脑梗了。第一道题写了个蠢死了的算法，在面试官的引导下完成了优化。

第二题直接没了思路，面试结束后看了一下，发现还是很简单的，可以直接用扩展运算符。。。
