---
title: 腾讯前端面试-校招-2019
categories:
  - 旧博客文章
tags:
 - 前端
 - 面经
date: 2021-02-14 22:13:51
index_img: /img/banner/bg34.jpg
banner_img: /img/banner/bg34.jpg
---
## 前言

最近在准备笔试面试，所以又搁置了博文更新计划。强迫自己更新文章，所以来一个腾讯的面经。将之前翻车的答案都更正为正确答案。

## 一面

一面的机会纯属偶然获得，和笔试相隔了很久，早已经忘记了腾讯的事，都已经愉快的放飞自我了，各种吃喝玩乐，突然之间就收到了腾讯的一面，一天都很亢奋。

### 输入url到显示的过程

> 1. 首先浏览器有五大线程:渲染线程，JS线程，事件线程，网络线程，定时器线程
> 2. 输入URl后会进行解析.然后开辟一个网络线程,请求资源。从应用层发送的http请求,到传输层通过三次握手建立tcp/ip链接,再到网络层的ip寻址,然后再到数据链路层的封装成帧,最后到物理层的利用物理介质传输。
>   * DNS查询：如果浏览器有缓存,则直接使用浏览器缓存否则使用本机缓存,再没有就是用host.如果没有缓存就向dns域名服务器查询,查询到对应ip
>   *  三次握手 seq->ack seq ack
>   *  四次挥手
> 3. 从服务器接受到的请求到对应后台收到请求,后台进行处理.一般有的后台有统一性验证,安全拦截,跨域验证之类的.如果这一步不符合规则,就直接返回了相应的http报文,如果通过,才会进行实际的后台代码,此时是程序接收到请求,然后执行.等程序执行完毕后,就会返回一个http响应包.然后将这个包从后端发送到前端,完成交互。前端后端交互时http报文作为信息的载体.
> 4. 然后开始前端渲染
>  1. 浏览器解析html,构建dom树 过程:字节数据 字符串 tokens nodes dom
>  2. 解析css 生成css规则树 过程:字节数据 字符串 tokens nodes cssom 在这过程中浏览器会确定下每一个节点的样式.
>  3. 合并dom树和css规则,生成render树  计算css样式,渲染树只会包括需要现实的节点和这些节点的样式信息
>  4. 布局render树
>  5. 绘制render树
>  6. 浏览器会将各层的信息发送给GPU,GPU将各层合成显示在屏幕上
>  7. 遇到script标签时，会执行并阻塞渲染:因为浏览器渲染和js执行公用一个线程,而且这里必须是单线程操作,多线程会产生渲染DOM冲突.等script标签完成后,浏览器会继续渲染.这也可以解释为什么js放在html底部,JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。

### linux指令

  指令有点多，问我的我也记不太清了2333，多看看[鸟哥的私房菜](http://linux.vbird.org/linux_basic/)吧
  
###  同源策略怎么回事？以及如何实现跨域请求

> 同源策略目的是为了保护用户的信息安全，防止恶意的网站窃取数据，比如A网站的cookie，B网站就不能使用，同源指的是协议，url，端口全部一致。实现跨域的方法有多种。
> 同源策略限制了以下三种行为:
>  - Ajax请求不能发送，所以就出现了跨域
>  - DOM无法获得
>  - cookie，localstroge，indexDB无法读取
> 解决cookie不能共享，可以设置相同的document.domain就可以.
> 跨域解决方案:
> 1. JSONP:JSONP = json + padding 填充式json利用的是动态创建script标签，向服务器请求json数据，服务器收到请求后，服务器将传回来的数据放在指定名字的回调函数中传回来，这样就可以实现跨域访问。简单实用，老旧浏览器都适用,但是只支持GET请求。
> 2. 配置nginx代理
> 3. CORS:服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

###  用什么版本控制器

git。git指令推荐看看：[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

###  闭包是什么？闭包会带来什么问题？

> 当执行上下文中创建的函数执行时,如果访问了执行上下文中变量对象中的值,闭包就会产生
> JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。
> 闭包副作用会造成内存泄露，正面作用利用闭包可以实现块级作用域，IIFE，模块化

###  性能优化
> 性能优化可以分为两种：减少页面体积,提升网络加载 和 优化页面渲染
> * 减少页面体积,提升网络加载
>   * 静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）
>   * 静态资源缓存（资源名称加 MD5 戳）
>   * 使用 CDN 让资源加载更快
> * 优化页面渲染
>   * CSS 放前面，JS 放后面
>   * 懒加载（图片懒加载、下拉加载更多）
>   * 减少DOM 查询，对 DOM 查询做缓存
>   * 减少DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）
>   * 事件节流
>   * 尽早执行操作（DOMContentLoaded）
>   * 使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间

#### 为什么操作DOM慢
因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，然后会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

###  如何阻止事件冒泡
> dom标准事件流的触发的先后顺序为：先捕获再冒泡.事件捕获：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。使用stopPropagation()阻止事件冒泡.使用preventDefault()阻止默认行为

## 二面
二面和一面相隔了三天，不过一面面完的下午就变成了复试状态，截止写此文为止还没消息，一直是复试状态。感觉要加面。

### React有哪些优点

1. 使用了虚拟节点，性能好
2. 因为强调只从this.props和this.state生成HTML，对函数式编程友好
3. 生态好，应对各种场景的包都有。

### 怎么实现的虚拟节点？

> 虚拟节点的本质：虚拟节点的本质就是在JS和DOM之间做一个缓存，可以类比CPU和硬盘，既然硬盘这么慢，我们就也在他们之间添加一个缓存； 既然DOM这么慢，我们就可以在JS和DOM之间添加一个缓存。 CPU（JS）只操作内存（虚拟DOM），最后的时候在把变更写入硬盘（DOM）。
> 
> diff算法：
> 1. 用Js对象来表示DOM树的结构，需要记录他的节点类型（tagName）、属性（props）、子节点（children）； 然后用这个树构建一个真正的DOM树，插入到文档中。
> 2. 当状态变更的时候，重新构造一个新的对象树，然后用这个新的树和旧的树作对比，记录两个树的差异。
>   1. 深度遍历优先，记录差异
>   2. 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比，如果有差异的话就记录到一个对象里面。差异包括：替换原来的节点； 移动、删除、新增子节点；修改了节点的属性。 ；对于文本节点，文本内容可能会改变。 
> 1. 把2所记录的差异应用在步骤一所构建的真正的DOM树上，视图就更新了。

### 解释一下304

304 not modified，表示服务器允许访问资源，但因为发生请求未满足条件的情况。用于协商缓存，缓存分为强缓存和协商缓存，协商缓存的机制是如果缓存过期了，就需要发起请求验证资源是否有更新。当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回304状态，并且更新服务器缓存有效期。


### 如何判断服务器资源是否更新

> last-modified:last-modified 和 if-modified-since 是成对出现的
> - last-modified 在响应头里，服务器告诉浏览器，这个资源的最后修改时间是什么
> - if-modified-since 在请求头里，告诉服务器我所请求的这个资源最后修改时间是什么。服务器根据这个值来判断，如果这个值和服务端这个资源现有的值一致，直接返回 304 和空的 body，如果和服务端现有的值不一致（资源已经更新），则返回 200 和最新资源。
> etag:etag 和 if-none-match 是成对出现的
> - etag 是服务器根据一定规则生成的资源‘指纹’，传递给客户端，客户端将其与缓存一起保存
> - if-none-match 是客户端在向服务端请求指定资源时，将本地的 etag 值通过信息头传递给服务端，服务端与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用。如果 etag 值匹配不成功，返回 200 code 和资源内容。

### 对http了解多少？http header中都有哪些东西？

> HTTP协议最大的特点是「无状态」。客户端向服务器端发起一个请求。然后服务器端返回一个响应。HTTP协议传输的内容是HTTP message。
> 报文分成两种，一种是Request请求，通常用于浏览器告诉服务器它想要什么；一种是Response响应，通常用于服务器给浏览器返回它要的内容。
> 报文的基本格式：开始行，消息头，空行，消息体。
> Request:请求行，请求头，空行，消息体（可空）
>  * 请求行：请求方法 URI 协议版本号 。
>  * 请求头：Referrer 请求发起页面的地址 User-Agent 客户端信息 Host 主机域名 Max-forwards 请求最大转发次数 
> Response：状态行，响应头，空行，消息体。
> * 状态行：协议版本号 状态码  
> * 响应头：ETage：Entity的唯一编码，修改后更新；Retry-after：N秒后重试；Location：转向到 Server Web Server相关信息
> 消息体：可空。
> 实体头字段：Allow：支持的HTTP方法；Expires：过期时间； Content-Encoding：编码格式；Content-Language：编码格式； Content-Length：内容长度（字节）；Content-Type：媒体类型。

### 页面出现空白，怎么排查定位问题？
1. 先确保网络连接通畅。
2. 查看网络url地址是否输入有误。
3. 打开控制台查看报错信息。
4. 查看接口访问是否有请求。
5. 查看路由是否有path或者name的错误，导致加载了不存在的页面。

### 一个父元素div里面有n个a标签，对a有一些事件需要处理，怎么处理？

使用事件代理，绑定在父元素上，看事件的出发点是不是a标签。代码如下：
```js
$("#div").addEventListener('click', function (e) {
    // e.target 可以监听到触发点击事件的元素是哪一个
    var target = e.target
    if (e.nodeName === 'A') {
        // 点击的是 <a> 元素
        // 进行要处理的内容
    }
})
```

### 利用了什么性质？

> 事件冒泡。dom标准事件流的触发的先后顺序为：先捕获再冒泡
> 事件捕获：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。
> 事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。使用stopPropagation()阻止事件冒泡.使用preventDefault()阻止默认行为

### 垂直水平居中怎么做？

1. 利用css3的translate属性，设置子元素为绝对定位，top，left为50%，translate（-50%。-50%）
2. 利用flex布局，对父元素使用，align-items：center让其在侧轴垂直，就是说垂直居中,如果要水平居中的话，可以使用justify-centent：center

### 对于性能优化你有什么看法

参看一面

### 为什么说dom操作耗时？

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当通过 JS 操作 DOM 的时候，这个操作涉及到了两个线程之间的通信，然后会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信。操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

### 什么是重绘？什么是回流？

> 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘
> 回流是布局或者几何属性需要改变就称为回流。
> 回流一定会触发重绘，而重绘不一定会回流
> 原因:
> * 添加或删除可见的DOM元素
> * 元素的位置发生变化
> * 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
> * 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
> * 页面一开始渲染的时候（这肯定避免不了）
> * 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
>
> 如何避免:
> * 使用transform替代top,left,right,bottom
> * 使用visibility替换display:none,前者只会重绘,后者会引发回流
> * 不把界面的属性值放在一个循环里当循环的变量
> * 不用table布局
